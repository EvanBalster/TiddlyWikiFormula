core-version: >=5.1.20
created: NaNNaNNaNNaNNaNNaNNaN
dependents: 
description: Spreadsheet-like formulas in TiddlyWiki.
list: readme settings license
modified: NaNNaNNaNNaNNaNNaNNaN
name: TiddlyFormula
plugin-type: plugin
revision: 0
title: $:/plugins/ebalster/formula
type: application/json
version: 0.2.4

{
    "tiddlers": {
        "$:/plugins/ebalster/formula/coerce.js": {
            "title": "$:/plugins/ebalster/formula/coerce.js",
            "created": "20180113183000431",
            "description": "",
            "modified": "20180112071139424",
            "module-type": "library",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/plugins/ebalster/formula/coerce.js\ntype: application/javascript\nmodule-type: macro\n\nType coercion logic for formulas.\nSupported types for coercion:\n\n* text\n* number\n* boolean\n* array\n* date\n\nAdditional types that may be coerced:\n\n* undefined\n* regular expression\n\n\\*/\n(function(){\n\n\"use strict\";\n\n\n// Value-to-text coercion.\nvar _ToText = {\n\t\"undefined\" : function(v,ctx) {return \"undefined\";},\n\t\"string\"    : function(v,ctx) {return v;},\n\t\"number\"    : function(v,ctx) {return ctx.formats.number(v);},\n\t\"symbol\"    : function(v,ctx) {return String(v);},\n\t\"function\"  : function(v,ctx) {return \"function\" + (v.formulaSrc || \" [built-in]\");},\n\t\"boolean\"   : function(v,ctx) {return (v ? \"TRUE\" : \"FALSE\");},\n\t\"object\"    : function(v,ctx) {\n\t\tif (v instanceof Date)   return ctx.formats.date(v);\n\t\tif (v instanceof Array)  return ctx.formats.array(v,ctx);\n\t\tif (v instanceof RegExp) return String(v);\n\t\tif (v instanceof Error)  throw v;\n\t\treturn JSON.stringify(v); // Last resort\n\t},\n};\n\n// Value-to-number coercion.\nvar _ToNum = {\n\t\"undefined\" : function(v,ctx) {throw \"Cannot convert undefined value to number!\";},\n\t\"string\"    : function(v,ctx) {\n\t\tvar n = Number(v);\n\t\tif (isNaN(n)) throw \"Cannot convert \\\"\"+v+\"\\\" to number!\";\n\t\treturn n;\n\t},\n\t\"number\"    : function(v,ctx) {return v;},\n\t\"symbol\"    : function(v,ctx) {throw \"Cannot convert symbol to number!\";},\n\t\"function\"  : function(v,ctx) {throw \"Cannot convert function to number!\";},\n\t\"boolean\"   : function(v,ctx) {return (v ? 1 : 0);},\n\t\"object\"    : function(v,ctx) {throw \"Cannot convert \\\"\" + _ToText.object(v,ctx) + \"\\\" to number!\";},\n};\n\n// Value-to-boolean coercion.\nvar _ToBool = {\n\t\"undefined\" : function(v,ctx) {return false;},\n\t\"string\"    : function(v,ctx) {return !(/^\\s*(undefined|false|null|0+|0*\\.0+|0+\\.0*|)\\s*$/i.test(v));},\n\t\"number\"    : function(v,ctx) {return Boolean(v);},\n\t\"symbol\"    : function(v,ctx) {return Boolean(v);},\n\t\"function\"  : function(v,ctx) {return true;},\n\t\"boolean\"   : function(v,ctx) {return v;},\n\t\"object\"    : function(v,ctx) {return Boolean(v);},\n};\n\nexports.ToSelf = function ToSelf(v,ctx) {return v;};\nexports.ToText = function ToText(v,ctx) {return _ToText[typeof v](v,ctx);};\nexports.ToNum  = function ToNum (v,ctx) {return _ToNum [typeof v](v,ctx);};\nexports.ToBool = function ToBool(v,ctx) {return _ToBool[typeof v](v,ctx);};\n\nexports.ToDate = function ToDate(v,ctx) {\n\tif (v instanceof Date) return v;\n\tthrow \"Cannot auto-convert \\\"\" + exports.ToText(v,ctx) + \"\\\" to a date!\";\n};\n\nvar rxJsRegex = /^\\/((?:[^\\\\\\/\\[]|\\[(?:[^\\]]|\\\\\\])*\\]|\\\\.)+)\\/([a-z]*)$/;\nvar rxTwRegexFlags = /^\\(\\?[a-z]*\\)|\\(\\?[a-z]*\\)$/i;\n\nexports.ToRegex = function ToRegex(v,ctx) {\n\tif (v instanceof RegExp) return v;\n\tif (typeof v === \"string\") {\n\t\tv = v.trim();\n\t\t// Try JavaScript style regex\n\t\tvar match = rxJsRegex.exec(v);\n\t\tif (match) {\n\t\t\treturn new RegExp(term[1].replace(\"\\\\/\", \"/\"), term[2]);\n\t\t}\n\t\t// Try TiddlyWiki style regex\n\t\tmatch = rxTwRegexFlags.exec(v);\n\t\tif (match) {\n\t\t\tvar flagLen = match[0].length;\n\t\t\tvar flags = match[0].substr(2, match[0].length-3);\n\t\t\tif (match.index == 0) return new RegExp(v.substr(flagLen), flags);\n\t\t\telse                  return new RegExp(v.substr(0, v.length-flagLen), flags);\n\t\t}\n\t\treturn new RegExp(v, \"g\");\n\t\t\n\t}\n\tthrow \"Cannot auto-convert \\\"\" + exports.ToText(v,ctx) + \"\\\" to a regular expression!\";\n};\nexports.ToArray = function ToArray(v,ctx) {\n\tif (v instanceof Array) return v;\n\tthrow \"Cannot auto-convert \\\"\" + exports.ToText(v,ctx) + \"\\\" to an array!\";\n};\nexports.ToFunc = function ToFunc(v,ctx) {\n\tif (v instanceof Function) return v;\n\tthrow \"Cannot convert \\\"\" + exports.ToText(v,ctx) + \"\\\" to a function!\";\n};\n// Maybe add ToRegex\n\n\n// Build a coerce rule from a source string.\nvar CoerceFuncs = {\n\tT: exports.ToText,\n\tN: exports.ToNum,\n\tB: exports.ToBool,\n\tA: exports.ToArray,\n\tD: exports.ToDate,\n\tR: exports.ToRegex,\n\tF: exports.ToFunc,\n\t_: exports.ToSelf,\n};\n\nfunction BuildCoerceRule(src) {\n\tvar rule = {\n\t\tmain: [],\n\t\textra: [],\n\t};\n\tvar i = 0, func;\n\t// Main part\n\twhile (i < src.length) {\n\t\tfunc = CoerceFuncs[src[i]]; ++i;\n\t\tif (func) {rule.main.push(func); continue;}\n\t\tif (src[i-1] == '+') break;\n\t\tthrow \"Unknown coerce rule: '\"+src[i-1]+\"'\";\n\t}\n\t// Extra arguments (loops)\n\twhile (i < src.length) {\n\t\tfunc = CoerceFuncs[src[i]]; ++i;\n\t\tif (func) {rule.extra.push(func); continue;}\n\t\tthrow \"Unknown coerce rule: '\"+src[i-1]+\"'\";\n\t}\n\treturn rule;\n}\n\nvar NoCoerce = {rule: {main:[], extra:[]}, gen: []};\nvar CoerceCache = {'': NoCoerce};\n\nfunction GetCoerceCache(src) {\n\tif (!CoerceCache[src]) {\n\t\ttry {\n\t\t\tCoerceCache[src] = {rule: BuildCoerceRule(src), gen: []};\n\t\t}\n\t\tcatch (err) {\n\t\t\tthrow err + \" in rule string '\" + src + \"'\";\n\t\t}\n\t}\n\treturn CoerceCache[src];\n}\n\n// Generate the coercing function array.\nfunction GenCoerceFuncs(rule,len) {\n\tvar result = [], i = 0, x = 0;\n\tresult = rule.main;\n\tif (rule.extra.length) {\n\t\twhile (result.length < len) result = result.concat(rule.extra);\n\t}\n\treturn result;\n}\n\n// Get an array of coercing (ToXXX) functions based on the function.\nexports.GetCoerceFuncs = function GetCoerceFuncs(func,args) {\n\t// Possibly set up coercion for this function.\n\tif (!func._coerce) {\n\t\tif (func.inCast) {\n\t\t\ttry {\n\t\t\t\tfunc._coerce = GetCoerceCache(func.inCast);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthrow err + \" for function \" + func.toString();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfunc._coerce = NoCoerce;\n\t\t}\n\t}\n\tvar gen = func._coerce.gen[args.length];\n\tif (gen) return gen;\n\tgen = GenCoerceFuncs(func._coerce.rule, args.length);\n\tfunc._coerce.gen[args.length] = gen;\n\treturn gen;\n};\n\n\n// Coerce\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/compile.js": {
            "title": "$:/plugins/ebalster/formula/compile.js",
            "created": "20171210195223539",
            "description": "",
            "modified": "20171211181652443",
            "module-type": "library",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n\"use strict\";\n\nvar Nodes  = require(\"$:/plugins/ebalster/formula/nodes.js\");\n\nvar rxDatumIsFormula      = /^\\s*\\(=.*=\\)\\s*$/;\nvar rxDatumIsTrue         = /^s*TRUE\\s*$/i;\nvar rxDatumIsFalse        = /^s*FALSE\\s*$/i;\n\nvar rxLet               = /let/gi;\n\nvar rxSkipInert         = /(\\s*|\\/\\/.*?([\\r\\n]|$)|\\/\\*[\\s\\S]*?\\*\\/)*/g;\nvar rxNotWhitespace     = /[^\\s]+/g;\nvar rxOperandFilter     = /\\[(([^\\[\\]]|\\[[^\\[\\]]*\\])+(\\](\\s*[+-])?\\s*\\[)?)+\\]/g;\nvar rxOperandTransclusion =     /\\{\\{([^\\{\\}]+)\\}\\}/g;\nvar rxDatumIsTransclusion = /^\\s*\\{\\{([^\\{\\}]+)\\}\\}\\s*$/;\nvar rxOperandVariable     =     /<<([^<>]+)>>/g;\nvar rxDatumIsVariable     = /^\\s*<<[^<>]+>>\\s*$/;\nvar rxCellName            = /\\$?([A-Z]{1,2})\\$?([0-9]+)/g;\nvar rxCellRange           = /\\$?([A-Z]{1,2})\\$?([0-9]+):\\$?([A-Z]{1,2})\\$?([0-9]+)/g;\nvar rxIdentifier          = /[_a-zA-Z][_a-zA-Z0-9]*/g;\nvar rxKeyword             = /(function|let|for|foreach|if|then|else|while|do|this|self|currentTiddler)/gi;\n\nvar rxUnsignedDecimal =          /((\\d+(\\.\\d*)?)|(\\.\\d+))/g;\nvar rxDecimal         =     /[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))/g;\nvar rxDatumIsDecimal  = /^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/;\n\nvar rxDate            =     /\\d{2,4}-\\d{2}-\\d{2}(\\s*\\d{1,2}:\\d{2}(:\\d{2}(.\\d+)?)?)?/g;\nvar rxDatumIsDate     = /^\\s*\\d{2,4}-\\d{2}-\\d{2}(\\s*\\d{1,2}:\\d{2}(:\\d{2}(.\\d{3})?)?)?\\s*$/;\nvar rxRegex           =     /\\/((?:[^\\\\\\/\\[]|\\[(?:[^\\]]|\\\\\\])*\\]|\\\\.)+)\\/([a-z]*)/g;\nvar rxDatumIsRegex    = /^\\s*\\/((?:[^\\\\\\/\\[]|\\[(?:[^\\]]|\\\\\\])*\\]|\\\\.)+)\\/([a-z]*)\\s*$/;\nvar rxDatumIsTwDate   = /^([0-9]{4})(1[0-2]|0[1-9])(3[01]|[12][0-9]|0[1-9])(2[0-3]|[01][0-9])([0-5][0-9])([0-5][0-9])([0-9]{3})?$/;\nvar rxDateFragment    = /\\d+/g;\n\nvar rxString          = /(\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*')/g;\nvar rxEscapeSequence  = /\\\\([a-tv-z0\"'\\\\]|u[a-fA-F0-9]{0,4}|$)/g;\n\nvar formulaFunctions   = null;\nvar operatorsUnaryPre  = null;\nvar operatorsUnaryPost = null;\nvar operatorsBinary    = null;\nvar operatorsTernary   = null;\n\nfunction Parser(src)\n{\n\tthis.src = src;\n\tthis.pos = 0;\n\tthis.end = src.length;\n\tthis.locals = {};\n\tthis.localStack = [];\n\tthis.assignStack = [];\n}\nParser.prototype.getChar = function()\n{\n\treturn this.src.charAt(this.pos);\n};\nParser.prototype.nextGlyph = function()\n{\n\tthis.skipInert();\n\tif (this.pos >= this.end) return '';\n\t++this.pos;\n\treturn this.src.charAt(this.pos-1);\n};\nParser.prototype.remaining = function()\n{\n\treturn this.src.substring(this.pos, this.end);\n};\nParser.prototype.nextToken = function()\n{\n\tthis.skipInert();\n\trxNotWhitespace.lastIndex = this.pos;\n\trxNotWhitespace.test(this.src);\n\treturn this.src.substring(this.pos, rxNotWhitespace.lastIndex);\n};\nParser.prototype.match_here = function(regex)\n{\n\t// TODO this is doing much more work than is necessary\n\tregex.lastIndex = this.pos;\n\tvar result = regex.exec(this.src);\n\tif (!result || result.index != this.pos || result.index+result[0].length > this.end) return null;\n\tthis.pos = regex.lastIndex;\n\treturn result;\n};\nParser.prototype.skipInert = function()\n{\n\trxSkipInert.lastIndex = this.pos;\n\trxSkipInert.test(this.src);\n\tthis.pos = Math.min(rxSkipInert.lastIndex, this.end);\n};\n\n// Push a new set of local variables onto the parser's stack.\nParser.prototype.pushLocals = function(assigns) {\n\tvar id;\n\tvar newLocals = {};\n\tthis.localStack.push(this.locals); for (id in this.locals) newLocals[id] = 0;\n\tthis.assignStack.push(assigns);    for (id in assigns)     newLocals[id] = 0;\n\tthis.locals = newLocals;\n};\n\n// Pop the last set of local variables off the parser's stack and return usage-counts.\nParser.prototype.popLocals = function() {\n\tvar id, count, usage = {captures: {}, assigns: {}},\n\t\tassigns = this.assignStack.pop(),\n\t\toldLocals = this.localStack.pop();\n\tfor (id in this.locals) {\n\t\tcount = this.locals[id];\n\t\tif (count > 0) {\n\t\t\tif (assigns[id]) {\n\t\t\t\tusage.assigns[id] = count;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tusage.captures[id] = count;\n\t\t\t\toldLocals[id] += count;\n\t\t\t}\n\t\t}\n\t}\n\tthis.locals = oldLocals;\n\treturn usage;\n};\n\nvar initialize = function() {\n\tformulaFunctions = {};\n\tvar operators = {};\n\t$tw.modules.applyMethods(\"formula-function\", formulaFunctions);\n\t$tw.modules.applyMethods(\"formula-operator\", operators);\n\n\toperatorsUnaryPre = {};\n\toperatorsUnaryPost = {};\n\toperatorsBinary = {}; //{}; //{plus: {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"}};\n\toperatorsTernary = {};\n\tfor (var opName in operators)\n\t{\n\t\tvar op = operators[opName];\n\n\t\t// Bind the associated function.  \n\t\tvar func = formulaFunctions[op.function];\n\t\tif (!func) continue;\n\t\top.func_bind = func;\n\n\t\t// Sort the op by arity and position.\n\t\tswitch (op.arity)\n\t\t{\n\t\tcase 2:           operatorsBinary  [opName] = op; break;\n\t\tcase 3:           operatorsTernary [opName] = op; break;\n\t\tcase 1:\n\t\t\tswitch (op.position)\n\t\t\t{\n\t\t\t\tcase \"pre\":  operatorsUnaryPre [opName] = op; break;\n\t\t\t\tcase \"post\": operatorsUnaryPost[opName] = op; break;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\n\nexports.compileExpression = function(expression) {\n\n\t// Create a parser and process the formula as an expression.\n\tvar parser = new Parser(expression);\n\n\tvar operand = buildExpression(parser);\n\n\treturn operand;\n};\n\nexports.compileDatum = function(datum) {\n\t\n\tvar parser, term;\n\n\t// Short-hand formula\n\tif (datum.charAt(0) == \"=\") {\n\t\tparser = new Parser(datum);\n\t\tparser.pos = 1;\n\t\treturn buildExpression(parser);\n\t}\n\n\t// Could be a TiddlyWiki date?\n\tif (rxDatumIsTwDate.test(datum)) {\n\t\treturn new Nodes.Date($tw.utils.parseDate(datum));\n\t}\n\n\t// Could be a number?\n\tif (rxDatumIsDecimal.test(datum)) {\n\t\t// Treat as a number constant\n\t\treturn new Nodes.Number(Number(datum));\n\t}\n\n\t// Could be a formula?\n\tif (rxDatumIsFormula.test(datum)) {\n\t\t// Parse contents as a formula\n\t\tparser = new Parser(datum);\n\t\tparser.pos = datum.indexOf(\"=\")+1;\n\t\tparser.end = datum.lastIndexOf(\"=\");\n\t\treturn buildExpression(parser);\n\t}\n\n\t// Could be a transclusion or variable?\n\tif (rxDatumIsTransclusion.test(datum) ||\n\t\t\trxDatumIsVariable.test(datum)) {\n\t\t// Defer to the operand parser...\n\t\tparser = new Parser(datum);\n\t\treturn buildOperand(parser);\n\t}\n\n\t// Booleans?\n\tif (rxDatumIsFalse.test(datum)) return new Nodes.Bool(false);\n\tif (rxDatumIsTrue .test(datum)) return new Nodes.Bool(true);\n\n\t// Date?\n\tif (rxDatumIsDate.test(datum))\n\t{\n\t\trxDateFragment.lastIndex = 0;\n\t\tvar parts = [];\n\t\twhile (true)\n\t\t{\n\t\t\tvar res = rxDateFragment.exec(datum);\n\t\t\tif (!res) break;\n\t\t\tparts.push(parseInt(res[0]));\n\t\t}\n\t\tif (parts.length)\n\t\t{\n\t\t\treturn new Nodes.Date(new Date(\n\t\t\t\tparts[0], (parts[1] || 1)-1, parts[2] || 1,\n\t\t\t\tparts[3] || 0, parts[4] || 0, parts[5] || 0, parts[6] || 0));\n\t\t}\n\t}\n\n\t// Regex?\n\tif ((term = rxDatumIsRegex.exec(datum))) {\n\t\treturn new Nodes.Regex(new RegExp(term[1].replace(\"\\\\/\", \"/\"), term[2]));\n\t}\n\n\t// Otherwise, treat as a string constant\n\treturn new Nodes.Text(datum);\n};\n\nexports.compileFormula = function(formulaString)\n{\n\t// Process the formula string into a root operand\n\ttry {\n\t\treturn exports.compileExpression(formulaString);\n\t}\n\tcatch (err) {\n\t\tthrow \"CompileError: \" + err;\n\t}\n};\n\n\n// Compile an operator\nfunction parseOperator(parser, operatorGroup) {\n\n\t// Skip more whitespace\n\tparser.skipInert();\n\n\tvar result = null;\n\n\t// Find the longest operator matching the current text.\n\tfor (var opName in operatorGroup)\n\t{\n\t\tvar op = operatorGroup[opName];\n\t\tif (parser.src.substr(parser.pos, op.operator.length) == op.operator\n\t\t\t&& parser.pos+op.operator.length <= parser.end)\n\t\t{\n\t\t\tif (!result || result.operator.length < op.operator.length) result = op;\n\t\t}\n\t}\n\n\tif (result) parser.pos += result.operator.length;\n\n\treturn result;\n}\n\n// Parse a text reference.  This function is pased on $tw.utils.getTextReference.\nfunction buildTextReference(textReference) {\n\tvar tr = $tw.utils.parseTextReference(textReference);\n\tvar title;\n\tif (tr.title) title = new Nodes.Text(tr.title);\n\telse          title = new Nodes.Variable(new Nodes.Text(\"currentTiddler\"));\n\tif (tr.field) {\n\t\tif (tr.field == \"title\") {\n\t\t\treturn title;\n\t\t}\n\t\telse {\n\t\t\treturn new Nodes.TranscludeField(title, new Nodes.Text(tr.field));\n\t\t}\n\t}\n\telse if (tr.index) {\n\t\treturn new Nodes.TranscludeIndex(title, new Nodes.Text(tr.index));\n\t}\n\telse {\n\t\treturn new Nodes.TranscludeText(title);\n\t}\n}\n\n// Parse a formula.\nfunction buildExpression(parser, nested) {\n\t\n\t// Make sure math functions are initialized\n\tif (!formulaFunctions) initialize();\n\n\tparser.skipInert();\n\n\t// Expression compiler state\n\tvar operands = [];\n\tvar operators = [];\n\tvar precedences = [];\n\tvar operand = null, callArgs;\n\t\n\t// Unary stacking function\n\tvar applyUnary = function(unary) {\n\t\toperand = new Nodes.CallJS(unary.func_bind, [operand]);\n\t};\n\n\twhile (true)\n\t{\n\t\tvar unaries = [];\n\n\t\t// Prefix operators\n\t\twhile (true)\n\t\t{\n\t\t\tvar prefix = parseOperator(parser, operatorsUnaryPre);\n\t\t\tif (prefix) unaries.unshift(prefix);\n\t\t\telse break;\n\t\t}\n\n\t\t// Grab the operand\n\t\toperand = buildOperand(parser);\n\n\t\t// Missing operand is an error\n\t\tif (operand === null)\n\t\t{\n\t\t\tvar token = parser.nextToken();\n\t\t\tif (token && token[0] != \")\" && token[0] != \",\")\n\t\t\t\tthrow \"invalid operand \\\"\" + token + \"\\\"\";\n\t\t\telse if (operators.length)\n\t\t\t\tthrow \"missing operand after \\\"\" + operators[operators.length-1].operator + \"\\\"\";\n\t\t\telse throw \"empty expression\";\n\t\t}\n\n\t\t// Check for a function call (precedes all operators).\n\t\tcallArgs = buildArguments(parser);\n\t\tif (callArgs) operand = new Nodes.CallFunc(operand, callArgs);\n\n\t\t// Postfix operators\n\t\twhile (true)\n\t\t{\n\t\t\tvar postfix = parseOperator(parser, operatorsUnaryPost);\n\t\t\tif (postfix) unaries.push(postfix);\n\t\t\telse break;\n\t\t}\n\n\t\tunaries.forEach(applyUnary);\n\n\t\t// Operand is complete.\n\t\toperands.push(operand);\n\n\t\t// Infix operators\n\t\tvar operator = parseOperator(parser, operatorsBinary);\n\n\t\t// Missing operator ends the expression\n\t\tif (operator === null) break;\n\n\t\t// Add the operator and its precedence level.\n\t\toperators.push(operator);\n\t\tvar precedence = operator.precedence;\n\t\tif (precedences.indexOf(precedence || 0) == -1) precedences.push(precedence);\n\t}\n\n\t// Sanity check\n\tif (operands.length != operators.length+1)\n\t\tthrow \"internal error: operator/operand parsing inconsistency\";\n\n\t// Resolve operators by precedence\n\tprecedences.sort(function(a,b) {return (a>b)?-1:1;});\n\n\tfor (var j = 0; j < precedences.length; ++j)\n\t{\n\t\tvar prec = precedences[j];\n\t\tfor (var i = 0; i < operators.length; )\n\t\t{\n\t\t\t// Process only operators at the current precedence level.\n\t\t\tvar op = operators[i];\n\t\t\tif (op.precedence != prec) {++i; continue;}\n\n\t\t\t// Collapse the previous and next operands with this operator.\n\t\t\toperands[i] = new Nodes.CallJS(op.func_bind, [operands[i], operands[i+1]]);\n\t\t\toperators.splice(i, 1);\n\t\t\toperands.splice(i+1, 1);\n\t\t}\n\t}\n\n\t// Sanity check\n\tif (operators.length !== 0 || operands.length != 1)\n\t\tthrow \"internal error: resoving failed; \" + operands.length + \" operands and \" + operators.length + \" operators remain\";\n\n\t// For non-nested expressions, throw if any tokens remain.\n\tif (!nested)\n\t{\n\t\tparser.skipInert();\n\n\t\tif (parser.pos < parser.end)\n\t\t{\n\t\t\tthrow \"expected operator, got \\\"\" + parser.nextToken() + \"\\\"\";\n\t\t}\n\t}\n\t\n\t// Otherwise return the operand directly\n\treturn operands[0];\n}\n\n// Compile a list expression, which could be function arguments or an array...\nfunction buildCommaList(parser, braces, afterHint) {\n\n\t// Is an open-brace present?\n\tparser.skipInert();\n\tif (parser.getChar() !== braces[0]) return null;\n\t++parser.pos;\n\n\t// Zero arguments?\n\tparser.skipInert();\n\tif (parser.getChar() === braces[1]) {++parser.pos; return [];}\n\t\n\tvar nodeList = [];\n\n\twhile (true)\n\t{\n\t\t// Compile an expression.\n\t\tnodeList.push(buildExpression(parser, true));\n\n\t\t// Expect close-brace or , after argument.\n\t\tvar char = parser.nextGlyph();\n\t\tif (char === braces[1]) break;\n\t\tif (char !== \",\") throw \"Expect ',' or '\" + braces[1] + \"' after \" + afterHint;\n\t}\n\n\treturn nodeList;\n}\n\n// Build an argument list.\nfunction buildArguments(parser) {\n\treturn buildCommaList(parser, \"()\", \"function argument.\");\n}\n\n// Build an array literal.\nfunction buildArrayLiteral(parser) {\n\tvar array = buildCommaList(parser, \"{}\", \"array element (use {{double braces}} for transclusions).\");\n\tif (!array) throw \"Expect '{' to begin array literal.\";\n\treturn array;\n}\n\n// Build a let or foreach expression (parser starts after the keyword)\nfunction buildLetExpression(parser) {\n\n\tif (parser.nextGlyph() !== \"(\") throw \"Expect '(' after LET.\";\n\n\t// Gradually push locals.\n\tvar assigns = {}, id, c;\n\tparser.pushLocals(assigns);\n\twhile (true) {\n\t\t// Look for a name (identifier)\n\t\tparser.skipInert();\n\t\tid = parser.match_here(rxIdentifier);\n\t\tif (!id) throw \"Expected name in LET assignment, got '\" + parser.nextToken() + \"'.\";\n\t\tid = id[0];\n\t\tif (rxKeyword.test(id)) throw \"Illegal name for LET: \" + id;\n\t\t\n\t\t// Look for an equals, then an expression.\n\t\tif (parser.nextGlyph() !== '=') throw \"Expect '=' after LET value.\";\n\n\t\t// Build the expression...  Each let can use the ones before it.\n\t\ttry {\n\t\t\tassigns[id] = buildExpression(parser, true);\n\t\t}\n\t\tcatch (err) {\n\t\t\tthrow \"compiling LET '\" + id + \"': \" + err;\n\t\t}\n\t\tparser.locals[id] = 0;\n\n\t\t// Expect ) or , after argument.\n\t\tvar char = parser.nextGlyph();\n\t\tif (char == \")\") break;\n\t\tif (char != \",\") throw \"Expect ',' or ')' after LET assignment.\";\n\t}\n\n\tif (parser.nextGlyph() !== \":\") throw \"Expect ':' after LET assignment list.\";\n\tif (parser.nextGlyph() !== \"(\") throw \"Expect LET expression in parentheses after ':'.\";\n\n\t// Compile the body expression, with additional locals.\n\tvar body = buildExpression(parser, true);\n\tvar usage = parser.popLocals();\n\n\t// TODO could examine usage.assigns and letLocals to see if any values were unused.\n\n\tif (parser.nextGlyph() !== \")\") throw \"Expect ')' after LET expression.\";\n\n\treturn new Nodes.LetVars(assigns,body);\n}\n\n// Build a function (parser starts after the keyword \"function\")\nfunction buildFunction(parser) {\n\t\n\tvar srcBegin = parser.pos;\n\n\tif (parser.nextGlyph() !== \"(\") throw \"Expect '(' after 'function'.\";\n\n\tparser.skipInert();\n\n\t// Build the parameter list, if any.\n\tvar params = [], assigns = {};\n\tif (parser.getChar() === \")\") {++parser.pos;}\n\telse while (true)\n\t{\n\t\t// Get a parameter name (identifier).\n\t\tvar param = parser.match_here(rxIdentifier);\n\t\tif (!param) throw \"Expect list of parameter names after 'function'.\";\n\t\tparam = param[0];\n\t\tif (rxKeyword.test(param)) throw \"Illegal parameter name: \" + param;\n\t\tparams.push(param);\n\t\tif (assigns[param]) throw \"Parameter name used twice: \" + param;\n\t\tassigns[param] = true;\n\n\t\t// Expect ) or , after argument.\n\t\tvar char = parser.nextGlyph();\n\t\tif (char == \")\") break;\n\t\tif (char != \",\") throw \"Expect ',' or ')' after function parameter name.\";\n\n\t\t// Skip inert stuff\n\t\tparser.skipInert();\n\t}\n\n\tif (parser.nextGlyph() !== \":\") throw \"Expect ':' after function parameter list.\";\n\tif (parser.nextGlyph() !== \"(\") throw \"Expect function body beginning with '(' after ':'.\";\n\n\t// Compile the body expression, with parameters as locals.  Closures are NOT currently supported.\n\tparser.pushLocals(assigns);\n\tvar body = buildExpression(parser, true);\n\tvar usage = parser.popLocals();\n\tvar captures = usage.captures;\n\n\tif (parser.nextGlyph() !== \")\") throw \"Expect ')' after function body.\";\n\n\t// Create the function object (must be called with this = context)\n\tvar func = function() {\n\t\tvar locals = Object.assign({}, func.captured || {});\n\t\tfor (var i = 0; i < arguments.length; ++i) locals[params[i]] = arguments[i];\n\t\treturn body.compute(this.let(locals));\n\t};\n\t//func.params = params;\n\tfunc.min_args = params.length;\n\tfunc.max_args = params.length;\n\tfunc.formulaSrc = parser.src.substring(srcBegin, parser.pos);\n\treturn new Nodes.Function(func, captures);\n}\n\n// Compile an operand into a function returning the operand value.\nfunction buildOperand(parser) {\n\n\tvar term;\n\t\n\t// Skip whitespace & comments\n\tparser.skipInert();\n\n\tif (parser.pos == parser.end) return null;\n\n\tvar char = parser.getChar();\n\n\tif (char.match(/[0-9\\.+]/i))\n\t{\n\t\t// Number constant\n\t\tterm = parser.match_here(rxDecimal);\n\t\tif (term) return new Nodes.Number(Number(term[0]));\n\t\tthrow \"Invalid number: \" + parser.nextToken();\n\t}\n\telse if (char.match(/[$a-z_]/i))\n\t{\n\t\t// Cell range?\n\t\tterm = parser.match_here(rxCellRange);\n\t\tif (term) throw \"Cell ranges are currently unsupported!\";\n\n\t\t// Cell name?\n\t\tterm = parser.match_here(rxCellName);\n\t\tif (term) return new Nodes.Datum(\n\t\t\tnew Nodes.TranscludeIndex(\n\t\t\t\tnew Nodes.Variable(new Nodes.Text(\"currentTiddler\")),\n\t\t\t\tnew Nodes.Text(term[1]+term[2])));\n\n\t\t// Identifier?\n\t\tterm = parser.match_here(rxIdentifier);\n\t\tif (!term) return null;\n\n\t\tif (parser.locals[term] != undefined)\n\t\t{\n\t\t\t// Scoped variable.  We count up references to each.\n\t\t\t++parser.locals[term];\n\t\t\treturn new Nodes.ScopeVar(term[0]);\n\t\t}\n\n\t\tvar termLower = term[0].toLowerCase();\n\t\tswitch (termLower)\n\t\t{\n\t\tcase \"let\":\n\t\t\t// LET expression.\n\t\t\treturn buildLetExpression(parser);\n\n\t\tcase \"function\":\n\t\t\t// Function declaration.\n\t\t\treturn buildFunction(parser);\n\n\t\tdefault:\n\t\t\t// Function call.\n\t\t\tvar func = formulaFunctions[termLower];\n\n\t\t\tif (!func) throw \"unknown function: \" + term[0];\n\n\t\t\tvar args = buildArguments(parser);\n\n\t\t\t// Omitting arguments is only OK for constant functions\n\t\t\tif (args === null)\n\t\t\t{\n\t\t\t\tif (!func.isConstant) throw \"Expected '(' after \" + term[0];\n\t\t\t\targs = [];\n\t\t\t}\n\n\t\t\tif (func instanceof Function) {\n\t\t\t\t// Check parameter count\n\t\t\t\tif (args.length > func.length && !func.variadic)\n\t\t\t\t\tthrow \"too many arguments for \" + term[0] + \" (requires \" + func.length + \")\";\n\t\t\t\tif (args.length < func.length)\n\t\t\t\t\tthrow \"too few arguments for \" + term[0] + (func.variadic?\" (min \":\" (requires \") + func.length + \")\";\n\t\t\t}\n\t\t\telse if (func.select || func.construct) {\n\t\t\t\t// Check argument range\n\t\t\t\tif (func.max_args && args.length > func.max_args)\n\t\t\t\t\tthrow \"too many arguments for \" + term[0] + \" (max \" + func.max_args + \")\";\n\t\t\t\tif (func.min_args && args.length < func.min_args)\n\t\t\t\t\tthrow \"too few arguments for \" + term[0] + \" (min \" + func.min_args + \")\";\n\t\t\t\t\n\t\t\t\t// If a construct function is present, use it to generate an operand.\n\t\t\t\tif (func.construct) return func.construct(args);\n\n\t\t\t\t// If a select function is present, prepare to bind it with a CallJS.\n\t\t\t\tfunc = func.select(args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow \"Function \" + term[0] + \" seems to be unusable.\";\n\t\t\t}\n\n\t\t\treturn new Nodes.CallJS(func, args);\n\t\t}\n\t}\n\telse switch (char)\n\t{\n\tcase \"(\": // Parenthesized expression\n\t\t++parser.pos;\n\t\tvar parentheses = buildExpression(parser, true);\n\t\tparser.skipInert();\n\t\tif (parser.getChar() !== \")\")\n\t\t{\n\t\t\tif (parser.pos == parser.end) throw \"missing ')' at end of formula\";\n\t\t\telse                          throw \"expected ')', got \\\"\" + parser.nextToken() + \"\\\"\";\n\t\t}\n\t\t++parser.pos;\n\t\treturn parentheses;\n\n\tcase \"'\":\n\tcase \"\\\"\": // String constant\n\t\tterm = parser.match_here(rxString);\n\t\tif (!term) throw \"Invalid string: \" + parser.nextToken();\n\t\tterm = term[0].substr(1, term[0].length-2);\n\t\tterm = term.replace(rxEscapeSequence, function(esc) {\n\t\t\tswitch (esc.charAt(1)) {\n\t\t\t\tcase '\"': return '\"';\n\t\t\t\tcase '\\'': return '\\'';\n\t\t\t\tcase '\\\\': return '\\\\';\n\t\t\t\tcase 'n': return '\\n';\n\t\t\t\tcase 'r': return '\\r';\n\t\t\t\tcase 'b': return '\\b';\n\t\t\t\tcase 'f': return '\\f';\n\t\t\t\tcase 't': return '\\t';\n\t\t\t\tcase 'v': return '\\v';\n\t\t\t\tcase '0': return '\\0';\n\t\t\t\tcase 'u':\n\t\t\t\t\tif (esc.length < 6) throw \"Invalid escape sequence: \" + esc;\n\t\t\t\t\treturn String.fromCharCode(parseInt(esc.substr(2), 16));\n\t\t\t\tdefault: throw \"Invalid escape sequence: \" + esc;\n\t\t\t}\n\t\t});\n\t\treturn new Nodes.Text(term);\n\n\tcase \"[\": // Filter operand\n\t\tterm = parser.match_here(rxOperandFilter);\n\t\tif (term) return new Nodes.Filter(term[0]);\n\t\tbreak;\n\n\tcase \"{\": // Transclusion or array\n\t\t++parser.pos;\n\t\tchar = parser.getChar();\n\t\t--parser.pos;\n\t\tif (char == '{') {\n\t\t\t// Possible transclusion operand\n\t\t\tterm = parser.match_here(rxOperandTransclusion);\n\t\t\tif (term) return new Nodes.Datum(buildTextReference(term[1]));\n\t\t}\n\t\t// Array operand\n\t\treturn new Nodes.ArrayDef(buildArrayLiteral(parser));\n\n\tcase \"<\": // Variable operand\n\t\tterm = parser.match_here(rxOperandVariable);\n\t\tif (term) return new Nodes.Datum(\n\t\t\tnew Nodes.Variable(new Nodes.Text(term[1])));\n\t\tbreak;\n\n\tcase \"/\": // Regular expression?\n\t\tterm = parser.match_here(rxRegex);\n\t\tif (term) return new Nodes.Regex(new RegExp(term[1].replace(\"\\\\/\", \"/\"), term[2]));\n\t\t\tbreak;\n\t}\n\n\t// Didn't recognize the operand\n\treturn null;\n}\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/compute.js": {
            "title": "$:/plugins/ebalster/formula/compute.js",
            "created": "20180114170308058",
            "description": "",
            "modified": "20180114170348576",
            "module-type": "library",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n\"use strict\";\n\nvar Nodes    = require(\"$:/plugins/ebalster/formula/nodes.js\");\nvar Compiler = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Coerce   = require(\"$:/plugins/ebalster/formula/coerce.js\");\n\nvar Numeral  = require(\"$:/plugins/ebalster/formula/lib/numeral.js\");\n\n// TiddlyWiki array format\nfunction arrayFormatTW(arr,ctx) {\n\tvar result = \"\";\n\tfor (var i = 0; i < arr.length; ++i) {\n\t\tvar part = Coerce.ToText(arr[i],ctx);\n\t\tif (i && part.length) result += \" \";\n\t\tif (part.indexOf(/\\s/g) >= 0) result += \"[[\" + part + \"]]\";\n\t\telse result += part;\n\t}\n\treturn result;\n}\n\n// Number format functions...\n\n// SANE number formatting: if we find five consecutive 9s or 0s after the decimal point, round them off.\nfunction NumberStringSane(n) {\n\tvar s = String(n);\n\tvar parse = /^(0\\.0*[1-9]\\d*?|\\d*\\.\\d*?)(0{5}\\d*|9{5}\\d*)(|e[+-]\\d*)$/.exec(s);\n\tif (!parse) return s;\n\tvar kept = parse[1], exp = parse[3];\n\tvar end = kept.slice(-1);\n\tif (parse[2][0] === '0') return ((end === '.') ? kept.substr(0,kept.length-1) : kept) + exp;\n\tif (end === '.') return (Number(kept.substr(0,kept.length-1))+1) + exp;\n\treturn kept.substr(0,kept.length-1) + (Number(end)+1) + exp;\n}\nvar numeralFormat      = function(fmt)      {return function(num) {return Numeral(num).format(fmt);};};\nvar numeralFormatPrec  = function(fmt,digs) {return function(num) {return Numeral(num.toPrecision(digs)).format(fmt);};};\nvar numberFormatFixed  = function(prec)     {return function(num) {return num.toFixed    (prec);};};\nvar numberFormatPrec   = function(digs)     {return function(num) {return num.toPrecision(digs);};};\nvar numberFormatSelect = function(settings)\n{\n\tif (settings.precision == \"true\" || settings.precision > 100) return String;\n\tif (typeof settings.numberFormat == \"string\") {\n\t\t// Use numeral\n\t\treturn isNaN(settings.precision) ?\n\t\t\tnumeralFormat    (settings.numberFormat) :\n\t\t\tnumeralFormatPrec(settings.numberFormat, settings.precision);\n\t}\n\tif (!isNaN(settings.fixed))     return numberFormatFixed(settings.fixed);\n\tif (!isNaN(settings.precision)) return numberFormatPrec (settings.precision);\n\treturn NumberStringSane;\n\t// return String;\n};\n\nexports.computeFormula = function(compiledFormula, widget, formatOptions, debug) {\n\t\n\tvar value, context;\n\t\n\tformatOptions = formatOptions || {};\n\n\tvar dateFormat = formatOptions.dateFormat || \"0hh:0mm, DDth MMM YYYY\";\n\n\t// Specify format.  These are all required!\n\tvar formats = {\n\t\tnumber: numberFormatSelect(formatOptions),\n\t\tdate:   function(date) {return $tw.utils.formatDateString(date, dateFormat);},\n\t\tarray:  arrayFormatTW,\n\t};\n\n\tcontext = new Nodes.Context(widget, formats);\n\n\t// Compute a value from the root node of the compiled formula.\n\ttry {\n\t\tvalue = compiledFormula.computeText(context);\n\t}\n\tcatch (err) {\n\t\tthrow \"ComputeError: \" + String(err) + (err.fileName || \"\") + (err.lineNumber || \"\")\n\t\t\t+ (debug ? \"\\nNodes: \" + JSON.stringify(compiledFormula) : \"\");\n\t}\n\n\t// Format the root node as a string.\n\tif (debug) return value + \"\\n - Val:\" + String(value) + \", Op:\" + compiledFormula.name;\n\telse       return value;\n};\n\nexports.evalFormula = function(formulaString, widget, formatOptions, debug) {\n\t\n\tvar compiledFormula;\n\n\t// Compile the formula\n\ttry {\n\t\tcompiledFormula = Compiler.compileExpression(formulaString);\n\t}\n\tcatch (err) {\n\t\tthrow \"CompileError: \" + String(err);\n\t}\n\n\t// Compute the formula\n\treturn exports.computeFormula(compiledFormula, widget, formatOptions, debug);\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/filters/range.js": {
            "title": "$:/plugins/ebalster/formula/filters/range.js",
            "created": "20171221181646560",
            "modified": "20171221181907646",
            "module-type": "filteroperator",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/plugins/ebalster/formula/filters/range.js\ntype: application/javascript\nmodule-type: filteroperator\n\nFilter operator for generating a numeric range.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\nExport our filter function\n*/\nexports.range = function(source,operator,options) {\n\tvar results = [];\n\n\t// Split the operand into numbers delimited by these symbols\n\tvar parts = operator.operand.split(/[,:;]/g), beg, end, inc, i, fixed = 0;\n\n\tfor (i = 0; i < parts.length; ++i) {\n\t\t// Validate real number\n\t\tif (!/^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/.test(parts[i]))\n\t\t\treturn [\"range: bad number \\\"\"+parts[i]+\"\\\"\"];\n\n\t\t// Count digits; the most precise number determines decimal places in output.\n\t\tvar frac = /\\.\\d+/.exec(parts[i]);\n\t\tif (frac) fixed = Math.max(fixed, frac[0].length-1);\n\t\t\n\t\tparts[i] = parseFloat(parts[i]);\n\t}\n\n\tswitch (parts.length) {\n\t\tcase 1:\n\t\t\tbeg = 0;\n\t\t\tend = parts[0];\n\t\t\tinc = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbeg = parts[0];\n\t\t\tend = parts[1];\n\t\t\tinc = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbeg = parts[0];\n\t\t\tend = parts[1];\n\t\t\tinc = Math.abs(parts[2]);\n\t\t\tbreak;\n\t}\n\n\tif (inc === 0) return [\"range: increment 0 causes infinite loop\"];\n\n\t// May need to count backwards\n\tvar direction = ((end<beg) ? -1 : 1);\n\tinc *= direction;\n\n\t// Estimate number of resulting elements\n\tif ((end-beg)/inc > 10000) return [\"range: too many steps (over 10K)\"];\n\n\t// Avoid rounding error on last step\n\tend += direction * 0.5 * Math.pow(0.1, fixed);\n\n\tvar safety = 10010;\n\n\t// Enumerate the range\n\tif (end<beg) {for (i = beg; i > end; i += inc) {results.push(i.toFixed(fixed)); if (--safety<0) break;}}\n\telse         {for (i = beg; i < end; i += inc) {results.push(i.toFixed(fixed)); if (--safety<0) break;}}\n\n\tif (safety<0) return [\"range: unexpectedly large output\"];\n\n\t// Reverse?\n\tif (operator.prefix === \"!\") results.reverse();\n\n\treturn results;\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/functions/arithmetic.js": {
            "title": "$:/plugins/ebalster/formula/functions/arithmetic.js",
            "created": "20171211192843088",
            "modified": "20171212223526867",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Unary sign operators\nexports.uplus  = function(a)    {return a;};\nexports.uminus = function(a)    {return -a;};\nexports.uminus.inCast = 'N';\n\n// Add\nexports.add = function(a, b)    {return a + b;};\nexports.add.inCast = 'NN';\nexports.sub = function(a, b)    {return a - b;};\nexports.sub.inCast = 'NN';\n\n// Multiply\nexports.mul = function(a, b)    {return a * b;};\nexports.mul.inCast = 'NN';\nexports.div = function(a, b)    {return a / b;};\nexports.div.inCast = 'NN';\n\n// Percent -- TODO make this a different value-type\nexports.percent = function(a)    {return a / 100;};\nexports.percent.inCast = 'N';\n\n\n// Aliases\nexports.subtract = exports.sub;\nexports.minus    = exports.sub;\nexports.multiply = exports.mul;\nexports.divide   = exports.div;\nexports.quotient = exports.div;\nexports.power    = exports.pow;\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/arrays.js": {
            "title": "$:/plugins/ebalster/formula/functions/arrays.js",
            "created": "20171219014903147",
            "modified": "20171219014910148",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Array constructor function\nexports.array = function() {\n\treturn Array.prototype.slice.call(arguments);\n};\nexports.array.variadic = true;\n\n\nexports.nth = function(a, i) {\n\ti = Math.floor(i);\n\tif (i < 1 || i > a.length) return undefined;\n\treturn a[i-1];\n};\nexports.nth.inCast = 'AN';\n\nexports.first = function(a) {\n\tif (a.length) return a[0];\n\treturn undefined;\n};\nexports.first.inCast = 'A';\n\nexports.last = function(a) {\n\tif (a.length) return a[a.length-1];\n\treturn undefined;\n};\nexports.last.inCast = 'A';\n\n// MAP function\nexports.map = function(f, a) {\n\tif (f.min_args > 1 || f.max_args < 1) throw \"MAP requires single-argument function.\";\n\tvar result = [];\n\tvar func = f.bind(this);\n\tfor (var i = 0; i < a.length; ++i) result.push(func(a[i]));\n\treturn result;\n};\nexports.map.inCast = 'FA';\n\n\n/*\n\tCounting subroutines...\n\t\tcountA counts every non-array value\n\t\tcountS counts every non-array value but null, undefined and empty strings.\n*/\nfunction countS(a) {\n\tif (!(a instanceof Array)) return (a == null || a.length === 0) ? 0 : 1;\n\tvar n = 0;\n\tfor (var i = 0; i < a.length; ++i) n += countS(a[i]);\n\treturn n;\n}\nfunction countA(a) {\n\tif (!(a instanceof Array)) return 1;\n\tvar n = 0;\n\tfor (var i = 0; i < a.length; ++i) n += countA(a[i]);\n\treturn n;\n}\nfunction countS_multi() {\n\tvar n = 0;\n\tfor (var i = 0; i < arguments.length; ++i) n += countS(arguments[i]);\n\treturn n;\n}\nfunction countA_multi() {\n\tvar n = 0;\n\tfor (var i = 0; i < arguments.length; ++i) n += countA(arguments[i]);\n\treturn n;\n}\nexports.count =\n{\n\tmin_args : 1,\n\tselect : function(operands)\n\t{\n\t\tswitch (operands)\n\t\t{\n\t\tcase 1: return countS;\n\t\tdefault: return countS_multi;\n\t\t}\n\t}\n};\nexports.counta =\n{\n\tmin_args : 1,\n\tselect : function(operands)\n\t{\n\t\tswitch (operands)\n\t\t{\n\t\tcase 1: return countA;\n\t\tdefault: return countA_multi;\n\t\t}\n\t}\n};\n\n// COUNTA function, currently counts everything\nexports.counta = exports.count;\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/compare.js": {
            "title": "$:/plugins/ebalster/formula/functions/compare.js",
            "created": "20171214050022626",
            "modified": "20171214050803365",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Equality\nexports.eq  = function(a, b)    {return a == b;};\nexports.ne  = function(a, b)    {return a != b;};\n\n// Inequality\nexports.gt  = function(a, b)    {return a >  b;};\nexports.gte = function(a, b)    {return a >= b;};\nexports.lt  = function(a, b)    {return a <  b;};\nexports.lte = function(a, b)    {return a <= b;};\n\n\n// Aliases\nexports.equal            = exports.eq;\nexports.not_equal        = exports.ne;\nexports.greater          = exports.gt;\nexports.greater_or_equal = exports.gte;\nexports.less             = exports.lt;\nexports.less_or_equal    = exports.lte;\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/datetime.js": {
            "title": "$:/plugins/ebalster/formula/functions/datetime.js",
            "created": "20171217192129179",
            "modified": "20171217192149101",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\nvar MS_PER_DAY = 86400000;\nvar MS_PER_HOUR = 3600000;\nvar MS_PER_MINUTE = 60000;\nvar MS_PER_SECOND =  1000;\n\nvar UNIX_EPOCH_JULIAN_DAY = 2440587;\n\n\n/*!\n * isoWeekNum from pikaday <https://github.com/actano/Pikaday>\n */\nfunction isoWeekOfYear(date, dayInFirstWeek) {\n\tdayInFirstWeek = dayInFirstWeek || 4;\n\tdate = date instanceof Date ? date : new Date();\n\tdate.setHours(0, 0, 0, 0);\n\tvar yearDay        = date.getDate(),\n\t\tweekDay        = date.getDay(),\n\t\tdayShift       = dayInFirstWeek - 1, // counting starts at 0\n\t\tprevWeekDay    = function(day) { return (day + 7 - 1) % 7; };\n\tdate.setDate(yearDay + dayShift - prevWeekDay(weekDay));\n\tvar jan4th      = new Date(date.getFullYear(), 0, dayInFirstWeek),\n\t\tdaysBetween = (date.getTime() - jan4th.getTime()) / MS_PER_DAY,\n\t\tweekNum     = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / 7);\n\treturn weekNum;\n}\nfunction isLeapYear(year) {\n\treturn year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0);\n}\nfunction daysInYear(year) {\n\treturn isLeapYear(year) ? 366 : 365;\n}\nfunction daysInMonth(year, monthIndex) {\n\tswitch (monthIndex) {\n\tcase  0: case  2: case  4: case  6: case  7: case  9: case 11:return 31;\n\tcase  3: case  5: case  8: case 10: return 30;\n\tcase  1: return (isLeapYear(year) ? 29 : 28);\n\tdefault: throw \"days_in_month: invalid monthIndex: \" + monthIndex;\n\t}\n}\n\n// Utility: Add some months or years to a date\nfunction dateAddMonths(date, monthDiff, yearDiff) {\n\tyearDiff = yearDiff || 0;\n\tvar newMonth = date.getMonth() + Math.round(monthDiff);\n\tvar newYear = date.getFullYear() + Math.round(yearDiff);\n\n\tvar yearShift = ((newMonth < 0) ? -Math.floor(-(newMonth-11)/12) : Math.floor(newMonth/12));\n\tnewYear  += yearShift;\n\tnewMonth -= 12*yearShift;\n\n\treturn new Date(newYear, newMonth,\n\t\tMath.min(date.getDate(), daysInMonth(newYear, newMonth)),\n\t\tdate.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\n\n// Utility: Get date difference in whole years and months\nfunction dateDelta(date1, date2) {\n\tif (date2.getTime() < date1.getTime())\n\t{\n\t\tvar d = dateDelta(date2, date1);\n\t\treturn {years: -d.years, months: -d.months};\n\t}\n\tvar dMonths = 12*(date2.getYear()-date1.getYear()) + (date2.getMonth()-date1.getMonth());\n\tif (date2.getDate() < date1.getDate()) dMonths -= 1;\n\tvar dYears = Math.floor(dMonths/12);\n\t//dMonths -= dYears*12;\n\t/*var dDays = (new Date(\n\t\tdate1.getFullYear()+dYears, date1.getMonth()+dMonths, date2.getDate(),\n\t\tdate2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()\n\t\t).getTime() - date1.getTime()) / MS_PER_DAY;*/\n\treturn {years: dYears, months: dMonths};\n}\n\n\n// Get the current time\nexports.now         = function()     {return new Date(Date.now());};\n\n// Decompose dates\nexports.year        = function(d)    {return (d.getFullYear());};\nexports.year.inCast = 'D';\nexports.month       = function(d)    {return (d.getMonth()+1);};\nexports.month.inCast = 'D';\nexports.day         = function(d)    {return (d.getDate());};\nexports.day.inCast = 'D';\nexports.hour        = function(d)    {return (d.getHours());};\nexports.hour.inCast = 'D';\nexports.minute      = function(d)    {return (d.getMinutes());};\nexports.minute.inCast = 'D';\nexports.second      = function(d)    {return (d.getSeconds());};\nexports.second.inCast = 'D';\nexports.millisecond = function(d)    {return (d.getMilliseconds());};\nexports.millisecond.inCast = 'D';\n\n// Week functions\nexports.weekday     = function(d)    {return (d.getDay()+1);};\nexports.weekday.inCast = 'D';\nexports.weeknum     = function(d)    {return (isoWeekOfYear(d, 1));};\nexports.weeknum.inCast = 'D';\nexports.isoweekday  = function(d)    {return ((d.getDay()+6) % 7 + 1);};\nexports.isoweekday.inCast = 'D';\nexports.isoweeknum  = function(d)    {return (isoWeekOfYear(d));};\nexports.isoweeknum.inCast = 'D';\n\n\n/*\n\tDate math\n*/\nfunction makeTimeDiffFunction(milliseconds) {\n\tvar f = function(a, b) {return (b.getTime() - a.getTime()) / milliseconds;};\n\tf.inCast = 'DD';\n\treturn f;\n}\nfunction makeTimeAddFunction(milliseconds) {\n\tvar f = function(a, b) {return new Date(a.getTime() + b * milliseconds);};\n\tf.inCast = 'DN';\n\treturn f;\n}\n\nexports.years  = function(a, b) {return dateDelta(a, b).years;};\nexports.years.inCast = 'DD';\nexports.months = function(a, b) {return dateDelta(a, b).months;};\nexports.months.inCast = 'DD';\nexports.days            = makeTimeDiffFunction(MS_PER_DAY);\nexports.hours           = makeTimeDiffFunction(MS_PER_HOUR);\nexports.minutes         = makeTimeDiffFunction(MS_PER_MINUTE);\nexports.seconds         = makeTimeDiffFunction(MS_PER_SECOND);\nexports.milliseconds    = makeTimeDiffFunction(1);\n\nexports.add_years  = function(a, b) {return dateAddMonths(a, 0, b);};\nexports.add_years.inCast = 'DN';\nexports.add_months = function(a, b) {return dateAddMonths(a, b);};\nexports.add_months.inCast = 'DN';\nexports.add_days         = makeTimeAddFunction(MS_PER_DAY);\nexports.add_hours        = makeTimeAddFunction(MS_PER_HOUR);\nexports.add_minutes      = makeTimeAddFunction(MS_PER_MINUTE);\nexports.add_seconds      = makeTimeAddFunction(MS_PER_SECOND);\nexports.add_milliseconds = makeTimeAddFunction(1);\n\nexports.is_leap_year  = function(year)       {return (isLeapYear(year));};\nexports.is_leap_year.inCast = 'N';\nexports.days_in_year  = function(year)       {return (daysInYear(year));};\nexports.days_in_year.inCast = 'N';\nexports.days_in_month = function(yr, mon)    {return (daysInMonth(yr, mon-1));};\nexports.days_in_month.inCast = 'NN';\n\n/*exports.datedif = function(a, b, c) {\n\tswitch (c.toUpperCase())\n\t{\n\tcase \"D\": return ((b.getTime() - a.getTime()) / MS_PER_DAY);\n\tcase \"M\": {var d=dateDelta(a, b); return d.months+12*d.years;}\n\tcase \"Y\": return dateDelta(a, b).years;\n\tcase \"YM\": return dateDelta(a, b).months;\n\tcase \"MD\": return dateDelta(a, b).days;\n\t}\n};\nexports.datedif.inCast = 'DDT';*/\n\n\n// Parse TiddlyWiki date\nexports.tw_date = function(timestamp) {\n\tvar date = $tw.utils.parseDate(timestamp);\n\tif (!date) throw \"Bad timestamp: \\\"\" + date + \"\\\"\";\n\treturn (date);\n};\nexports.tw_date.inCast = 'T';\n\n// Stringify as TiddlyWiki date\nexports.to_tw_date = function(date) {\n\treturn $tw.utils.stringifyDate(date);\n};\nexports.to_tw_date.inCast = 'D';\n\n// Create ISO date\nexports.make_date = function(year, month, day) {\n\treturn (new Date(year, month-1, day));\n};\nexports.make_date.inCast = 'NNN';\n\n// Create ISO time\nexports.make_time = function(hour, minute, second) {\n\treturn (new Date(0, 0, 0, hour, minute, second));\n};\nexports.make_time.inCast = 'NNN';\n\n// Create from julian\nexports.julian = function(julian) {\n\treturn (new Date((julian - UNIX_EPOCH_JULIAN_DAY) * MS_PER_DAY));\n};\nexports.julian.inCast = 'N';\n\n// Convert to julian\nexports.to_julian = function(date) {\n\treturn (UNIX_EPOCH_JULIAN_DAY + (date.getTime() / MS_PER_DAY));\n};\nexports.to_julian.inCast = 'D';\n\nexports.time = exports.make_time;\n\n\n// Cast the incoming value into a date.\nfunction interpret_date(a) {\n\tif (a instanceof Date) return a;\n\treturn exports.tw_date(a);\n}\ninterpret_date.inCast = 'D';\n\n\n// Consruct a date from a TiddlyWiki timestamp or a set of parts\nexports.date = {\n\tmin_args: 1, max_args: 3,\n\tselect: function(operands) {\n\t\tswitch (operands.length) {\n\t\tcase 1: return interpret_date;\n\t\tcase 3: return exports.make_date;\n\t\tdefault: throw \"Bad arguments to DATE. Should be (timestamp) or (year, month, day).\";\n\t\t}\n\t}\n};\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/logic.js": {
            "title": "$:/plugins/ebalster/formula/functions/logic.js",
            "created": "20171214054240274",
            "modified": "20171214060456114",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Node = require(\"$:/plugins/ebalster/formula/nodes.js\").Node;\n\n\n// Constants\nexports.true  = function()    {return true;};\nexports.false = function()    {return false;};\n\nexports.true.isConstant = true;\nexports.false.isConstant = true;\n\n// Logical operators\nexports.not = function(a)       {return !a;};\nexports.not.inCast = 'B';\nexports.and = function(a, b)    {return a && b;};\nexports.and.inCast = 'BB';\nexports.or  = function(a, b)    {return a || b;};\nexports.or .inCast = 'BB';\nexports.xor = function(a, b)    {return a ? !b : b;};\nexports.xor.inCast = 'BB';\n\n// Ternary\nfunction IfNode(pred, tval, fval) {\n\tthis.pred = pred;\n\tthis.tval = tval;\n\tthis.fval = fval;\n}\nIfNode.prototype = new Node();\nIfNode.prototype.name = \"if\";\nIfNode.prototype.compute = (function(ctx) {\n\treturn (this.pred.computeBool(ctx) ? this.tval.compute(ctx) : this.fval.compute(ctx));\n});\nexports.if = {\n\tmin_args: 3, max_args: 3,\n\tconstruct: function(operands) {\n\t\treturn new IfNode(operands[0], operands[1], operands[2]);\n\t}\n};\n\n\n// IFERROR\n/*exports.iferror = {\n\tmin_args = 2, max_args = 2,\n\tfunc = function(a, b) {\n\tselect: function(operands) {\n\t\ttry {return a.compute();}\n\t\tcatch (err) {return b.compute();}\n\t}\n\t};*/\n\n\n// SWITCH (variadic)\nexports.switch =\n{\n\tmin_args: 3,\n\tselect: function(operands)\n\t{\n\t\tswitch (operands.length % 2)\n\t\t{\n\t\tdefault:\n\t\tcase 0: return function(a) // Switch with default\n\t\t\t{\n\t\t\t\tvar value = a;\n\t\t\t\tfor (var i = 1; i+1 < arguments.length; i += 2)\n\t\t\t\t\t{if (arguments[i] == value) return arguments[i+1];}\n\t\t\t\treturn arguments[arguments.length-1];\n\t\t\t};\n\t\tcase 1: return function(a) // Switch, no default\n\t\t\t{\n\t\t\t\tvar value = a;\n\t\t\t\tfor (var i = 1; i+1 < arguments.length; i += 2)\n\t\t\t\t\t{if (arguments[i] == value) return arguments[i+1];}\n\t\t\t\treturn undefined;\n\t\t\t};\n\t\t}\n\t}\n};\n\n// CHOOSE (variadic)\nexports.choose = function(a, b)\n{\n\tvar index = Math.floor(a);\n\tvar result = arguments[index];\n\tif (index < 1 || !result) return undefined;\n\treturn result;\n};\nexports.choose.inCast = 'N';\nexports.choose.variadic = true;\n\n// IFS function (variadic)\nfunction ifsFunc() {\n\tfor (var i = 0; i < arguments.length; i += 2)\n\t\t{if (arguments[i]) return arguments[i+1];}\n\treturn undefined;\n};\nifsFunc.inCast = '+B_';\n\nexports.ifs =\n{\n\tmin_args : 2,\n\tinput: '+B_',\n\tselect : function(operands) {\n\t\tif (operands.length % 2 !== 0) throw \"Odd number of arguments to IFS\";\n\t\treturn ifsFunc;\n\t}\n};\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/math.js": {
            "title": "$:/plugins/ebalster/formula/functions/math.js",
            "created": "20171214171454666",
            "modified": "20171214171708994",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Coerce = require(\"$:/plugins/ebalster/formula/coerce.js\");\n\n\n// Constants\nexports.pi = function()    {return (Math.PI);};\nexports._e = function()    {return (Math.E);};\n\nexports.pi.isConstant = true;\nexports._e.isConstant = true;\n\n\n// Random\nexports.rand        = function()        {return Math.random();};\nexports.randbetween = function(a, b)    {return (a+(b-a)*Math.random());};\nexports.randbetween.inCast = 'NN';\nexports.random = exports.rand;\n\n\n// Sign and absolute value\nexports.abs  = function(a)    {return Math.abs(a);};\nexports.abs.inCast = 'N';\nexports.sign = function(x)    {return (((x > 0) - (x < 0)) || +x);};\nexports.sign.inCast = 'N';\n\n// Min/max\nexports.min = function(a)\n{\n\tvar min = a;\n\tfor (var i = 1; i < arguments.length; ++i) min = Math.min(min, arguments[i]);\n\treturn min;\n};\nexports.min.variadic = true;\nexports.min.inCast = '+N';\n\nexports.max = function(a)\n{\n\tvar max = a;\n\tfor (var i = 1; i < arguments.length; ++i) max = Math.max(max, arguments[i]);\n\treturn max;\n};\nexports.max.variadic = true;\nexports.max.inCast = '+N';\n\nexports.clamp = function(a, min, max) {\n\treturn (Math.min(Math.max(a, min), max));\n};\nexports.clamp.inCast = 'NNN';\n\n\n/*\n\tSeries arithmetic\n*/\nfunction Count(a) {\n\tif (a instanceof Array) {\n\t\tvar n = 0;\n\t\tfor (var i = 0; i < a.length; ++i) n += Count(a[i]);\n\t\treturn n;\n\t}\n\treturn 1;\n}\nfunction Sum(a) {\n\tif (a instanceof Array) {\n\t\tvar n = 0;\n\t\tfor (var i = 0; i < a.length; ++i) n += Sum(a[i]);\n\t\treturn n;\n\t}\n\treturn Coerce.ToNum(a,this);\n}\nfunction Product(a) {\n\tif (a instanceof Array) {\n\t\tvar n = 1;\n\t\tfor (var i = 0; i < a.length; ++i) n *= Product(a[i]);\n\t\treturn n;\n\t}\n\treturn Coerce.ToNum(a,this);\n}\nfunction Average(a) {\n\treturn Sum(a) / Count(a);\n}\n\nfunction GenSeriesFunc(func) {\n\treturn {\n\t\tmin_args : 1,\n\t\tselect : function(operands) {\n\t\t\tswitch (operands.length) {\n\t\t\tcase 1: return func;\n\t\t\tdefault: return function() {return func(Array.prototype.slice.call(arguments));};\n\t\t\t}\n\t\t}\n\t};\n}\n\nexports.sum     = GenSeriesFunc(Sum);\nexports.average = GenSeriesFunc(Average);\nexports.product = GenSeriesFunc(Product);\n\n\n/*\n\tExponential\n*/\n\n// Exponentiation and logarithm\nexports.pow   = function(a, b)    {return (Math.pow(a, b));};\nexports.pow.inCast = 'NN';\nexports.log   = function(a, b)    {return (Math.log(a) / Math.log(b));};\nexports.log.inCast = 'NN';\nexports.exp   = function(a)       {return (Math.exp(a));};\nexports.exp.inCast = 'N';\nexports.ln    = function(a)       {return (Math.log(a));};\nexports.ln.inCast = 'N';\nexports.log2  = function(a)       {return (Math.log2(a));};\nexports.log2.inCast = 'N';\nexports.log10 = function(a)       {return (Math.log10(a));};\nexports.log10.inCast = 'N';\n\nexports.power = exports.pow;\n\n// Precise exponentiation and logarithm\nexports.expm1 = function(a)       {return (Math.expm1(a));};\nexports.expm1.inCast = 'N';\nexports.log1p = function(a)       {return (Math.log1p(a));};\nexports.log1p.inCast = 'N';\n\n// Roots\nexports.sqrt = function(a)    {return (Math.sqrt(a));};\nexports.sqrt.inCast = 'N';\nexports.cbrt = function(a)    {return (Math.cbrt(a));};\nexports.cbrt.inCast = 'N';\n\n\n/*\n\tTrigonometry\n*/\n\n// Conversion\nexports.radians = function(a)    {return (Math.PI*a/180);};\nexports.radians.inCast = 'N';\nexports.degrees = function(a)    {return (180*a/Math.PI);};\nexports.degrees.inCast = 'N';\n\n// Trigonometry\nexports.sin = function(a)    {return (  Math.sin(a));};\nexports.sin.inCast = 'N';\nexports.cos = function(a)    {return (  Math.cos(a));};\nexports.cos.inCast = 'N';\nexports.tan = function(a)    {return (  Math.tan(a));};\nexports.tan.inCast = 'N';\nexports.csc = function(a)    {return (1/Math.sin(a));};\nexports.csc.inCast = 'N';\nexports.sec = function(a)    {return (1/Math.cos(a));};\nexports.sec.inCast = 'N';\nexports.cot = function(a)    {return (1/Math.tan(a));};\nexports.cot.inCast = 'N';\n\n// Inverse Trigonometry\nexports.asin = function(a)    {return (Math.asin(  a));};\nexports.asin.inCast = 'N';\nexports.acos = function(a)    {return (Math.acos(  a));};\nexports.acos.inCast = 'N';\nexports.atan = function(a)    {return (Math.atan(  a));};\nexports.atan.inCast = 'N';\nexports.acsc = function(a)    {return (Math.asin(1/a));};\nexports.acsc.inCast = 'N';\nexports.asec = function(a)    {return (Math.acos(1/a));};\nexports.asec.inCast = 'N';\nexports.acot = function(a)    {return (Math.atan(1/a));};\nexports.acot.inCast = 'N';\nexports.atan2 = function(y,x)    {return (Math.atan2(y, x));};\nexports.atan2.inCast = 'NN';\n\n// Hyperbolic Trigonometry\nexports.sinh = function(a)    {return (  Math.sinh(a));};\nexports.sinh.inCast = 'N';\nexports.cosh = function(a)    {return (  Math.cosh(a));};\nexports.cosh.inCast = 'N';\nexports.tanh = function(a)    {return (  Math.tanh(a));};\nexports.tanh.inCast = 'N';\nexports.csch = function(a)    {return (1/Math.sinh(a));};\nexports.csch.inCast = 'N';\nexports.sech = function(a)    {return (1/Math.cosh(a));};\nexports.sech.inCast = 'N';\nexports.coth = function(a)    {return (1/Math.tanh(a));};\nexports.coth.inCast = 'N';\n\n// Inverse Hyperbolic Trigonometry\nexports.asinh = function(a)    {return (Math.asinh(  a));};\nexports.asinh.inCast = 'N';\nexports.acosh = function(a)    {return (Math.acosh(  a));};\nexports.acosh.inCast = 'N';\nexports.atanh = function(a)    {return (Math.atanh(  a));};\nexports.atanh.inCast = 'N';\nexports.acsch = function(a)    {return (Math.asinh(1/a));};\nexports.acsch.inCast = 'N';\nexports.asech = function(a)    {return (Math.acosh(1/a));};\nexports.asech.inCast = 'N';\nexports.acoth = function(a)    {return (Math.atanh(1/a));};\nexports.acoth.inCast = 'N';\n\n/*\n\tRounding, ceiling and floor functions.\n\t\tSpecial measures were taken to reproduce the conventions.\n*/\n\nvar signedFloor = Math.trunc || function(n) {return (n<0) ? Math.ceil (n) : Math.floor(n);};\nvar signedCeil  =               function(n) {return (n<0) ? Math.floor(n) : Math.ceil (n);};\n\nfunction genCeilFloor(func) {\n\tvar by1 = function(a) {return func(a);},\n\t\tbyN = function(a, b) {var prec = b; return (func(a/prec) * prec);};\n\tby1.inCast = 'NN';\n\tbyN.inCast = 'NN';\n\treturn {\n\t\tmin_args : 1, max_args : 2,\n\t\tinput: 'NN',\n\t\tselect: function(operands) {\n\t\t\tswitch (operands.length)\n\t\t\t{\n\t\t\tcase 1: return by1;\n\t\t\tcase 2: return byN;\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction genRound(func) {\n\tvar lndigit = Math.log(0.1);\n\tvar by1 = function(a)    {return func(a);},\n\t\tbyN = function(a, b) {var prec = Math.exp(lndigit*b); return (func(a/prec) * prec);};\n\tby1.inCast = 'NN';\n\tbyN.inCast = 'NN';\n\treturn {\n\t\tmin_args : 1, max_args : 2,\n\t\tinput: 'NN',\n\t\tselect: function(operands) {\n\t\t\tswitch (operands.length)\n\t\t\t{\n\t\t\tcase 1: return by1;\n\t\t\tcase 2: return byN;\n\t\t\t}\n\t\t}\n\t};\n}\n\nexports.floor     = genCeilFloor(Math.floor);\nexports.ceil      = genCeilFloor(Math.ceil);\n//exports.floor_precise  = genCeilFloor(Math.floor);\n//exports.ceil_precise  = genCeilFloor(Math.ceil);\nexports.round     = genRound(Math.round);\nexports.roundup   = genRound(signedCeil);\nexports.rounddown = genRound(signedFloor);\nexports.trunc     = exports.rounddown;\n\n// Related functions\nexports.fract  = function(a)      {return (a-signedFloor(a));};\nexports.fract.inCast = 'NN';\nexports.modulo = function(a,b)    {return (a-b*Math.floor(a/b));};\nexports.modulo.inCast = 'NN';\n\nexports.mod = exports.modulo;\n\n\n/*\n\tInterpolation\n*/\nexports.mix = function(a,b,m) {return (a + (b-a) * m);};\nexports.mix.inCast = 'NNN';\n\nexports.step = function(e,x)    {return ((x<e) ? 0.0 : 1.0);};\nexports.step.inCast = 'NN';\n\nexports.smoothstep = function(e0,e1,x) {\n\tif (x < e0) return (0.0);\n\tif (x > e1) return (1.0);\n\tx = (x-e0) / (e1-e0);\n\treturn (3*x*x - 2*x*x*x);\n};\nexports.smoothstep.inCast = 'NNN';\n\n\n/*\n\tAlgorithms\n*/\nexports.gcd = function(a,b) {\n\ta = Math.abs(Math.round(a));\n\tb = Math.abs(Math.round(b));\n\tif (b > a) {var temp = a; a = b; b = temp;}\n\tvar limit = 1000;\n\twhile (true) {\n\t\tif (b == 0) return a;\n\t\ta %= b;\n\t\tif (a == 0) return b;\n\t\tb %= a;\n\t\tif (--limit < 0) throw \"GCD function is nonterminal!\";\n\t}\n};\nexports.gcd.inCast = 'NN';\n\nexports.lcm = function(a,b) {\n\ta = Math.abs(Math.round(a));\n\tb = Math.abs(Math.round(b));\n\treturn (!a || !b) ? 0 : Math.abs((a * b) / exports.gcd(a, b));\n};\nexports.lcm.inCast = 'NN';\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/regexp.js": {
            "title": "$:/plugins/ebalster/formula/functions/regexp.js",
            "created": "20171220230845098",
            "modified": "20171220230855457",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Compile regex.  TODO: Precompile these where possible\n/*var TW_RX_FLAGS = /^\\(\\?[a-z]*\\)|\\(\\?[a-z]*\\)$/i;\n\nfunction tw_regex(rx_str, defaultFlags) {\n\tif (!rx_str) throw \"Empty regular expression\";\n\tvar flagPart = TW_RX_FLAGS.exec(rx_str);\n\tif (flagPart) {\n\t\tvar flagLen = flagPart[0].length;\n\t\tvar flags = flagPart[0].substr(2, flagPart[0].length-3);\n\t\tif (flagPart.index == 0) return new RegExp(rx_str.substr(flagLen), flags);\n\t\telse                     return new RegExp(rx_str.substr(0, rx_str.length-flagLen), flags);\n\t}\n\treturn new RegExp(rx_str, defaultFlags);\n}*/\n\n\n// Regex replace\nexports.regexreplace = function(s, rx, b) {\n\t//rx = tw_regex(rx, \"g\");\n\trx.lastIndex = 0;\n\treturn s.replace(rx, b);\n};\nexports.regexreplace.inCast = 'TRT';\n\n// Regex match\nexports.regexmatch = function(s, rx) {\n\t//rx = tw_regex(rx, \"\");\n\trx.lastIndex = 0;\n\treturn rx.test(s);\n};\nexports.regexmatch.inCast = 'TR';\n\n// Regex extract\nfunction regexextract(s, rx) {\n\t//rx = tw_regex(rx, \"g\");\n\trx.lastIndex = 0;\n\ts = s;\n\tvar captureIndex = arguments[2] || 0;\n\tvar matches = [];\n\tvar match;\n\twhile ((match = rx.exec(s)) != null) {\n\t\tif (match[0].length == 0) ++rx.lastIndex;\n\t\tmatches.push(match[captureIndex] || \"\");\n\t\tif (!rx.global) break;\n\t}\n\treturn matches;\n}\nregexextract.inCast = 'TRN';\n\nexports.regexextract = {\n\tmin_args: 2, max_args: 3,\n\tselect: function(operands) {return regexextract;}\n};\n\n// Regex extract, single argument\nfunction regexextract1(s, rx, dfl) {\n\t//rx = tw_regex(rx, \"\");\n\trx.lastIndex = 0;\n\ts = s;\n\tvar captureIndex = arguments[3] || 0;\n\tvar match = rx.exec(s);\n\treturn (match && match[captureIndex]) ? match[captureIndex] : dfl;\n}\nregexextract1.inCast = 'TRTN';\n\nexports.regexextract1 = {\n\tmin_args: 3, max_args: 4,\n\tselect: function(operands) {return regexextract1;}\n};\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/strings.js": {
            "title": "$:/plugins/ebalster/formula/functions/strings.js",
            "created": "20171213003135495",
            "modified": "20171213003237206",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Coerce = require(\"$:/plugins/ebalster/formula/coerce.js\");\n\n\n// Cast to text.  Second argument not yet supported.\nexports.t = function(a)    {return a;};\nexports.t.inCast = 'T';\n\nfunction t_format(a, format) {return a;}\nt_format.inCast = 'TT';\n\nexports.text = {\n\tmin_args: 1, max_args: 1,\n\tinput: 'TT',\n\tselect: function(operands) {\n\t\tif (operands.length == 1) return exports.t;\n\t\treturn t_format;\n\t}\n};\n\n// Cast string to number.\nexports.value = function(a)    {return a;};\nexports.inCast = 'N';\n\n// Array to string\nvar JoinFunc = function(delimiter, ignore_empty, array, startIndex) {\n\tvar join = \"\", part;\n\tfor (var i = startIndex; i < array.length; ++i)\n\t{\n\t\tvar arg = array[i];\n\t\tif (arg instanceof Array) {\n\t\t\tpart = JoinFunc(delimiter, ignore_empty, arg, 0);\n\t\t}\n\t\telse {\n\t\t\tpart = Coerce.ToText(arg,this);\n\t\t}\n\t\tif (part.length || !ignore_empty) {\n\t\t\tif (join.length) join += delimiter;\n\t\t\tjoin += part;\n\t\t}\n\t}\n\treturn join;\n};\n\n// Join\nexports.join = function(delimiter) {\n\treturn JoinFunc.call(this, delimiter, false, arguments, 1);\n};\nexports.join.variadic = true;\nexports.join.inCast = 'T';\n\n// Textjoin\nexports.textjoin = function(delimiter, ignore_empty) {\n\treturn JoinFunc.call(this, delimiter, ignore_empty, arguments, 2);\n};\nexports.textjoin.variadic = true;\nexports.textjoin.inCast = 'T';\n\n// Split string to array\nexports.split = function(str, delimiter) {\n\treturn str.split(delimiter);\n};\nexports.split.inCast = 'T';\n\n// String length\nexports.len = function(str)     {return str.length;};\nexports.len.inCast = 'T';\n\n// String exact match\nexports.exact = function(a, b)    {return a === b;};\nexports.exact.inCast = 'TT';\n\n\n// Substrings\nexports.mid = function(str, i, n)    {return str.substr(i-1, n);};\nexports.exact.inCast = 'TNN';\n\nexports.substr = exports.mid;\n\n\n// Substitute\nexports.substitute = function(s, f, r)    {return s.split(f).join(r);};\nexports.substitute.inCast = 'TTT';\n\n// Replace (N/I)\n//exports.replace = function(s, p, l, r)    {return (s.splice(a, b));};\n\n\n// Concatenate\nexports.cat = function(a, b)    {return a + b;};\nexports.cat.inCast = 'TT';\n\n// Trim space\nexports.trim = function(a)      {return a.split(/^\\s+|\\s+$/g).join(\"\");};\nexports.trim.inCast = 'T';\n\n\n// Aliases\nexports.concatenate = exports.cat;\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/functions/wiki.js": {
            "title": "$:/plugins/ebalster/formula/functions/wiki.js",
            "created": "20180108011928370",
            "modified": "20180108012007186",
            "module-type": "formula-function",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Nodes = require(\"$:/plugins/ebalster/formula/nodes.js\");\n\n\n// Get variable string by name.\nexports.transclude = {\n\tmin_args: 1, max_args: 2,\n\tconstruct: function(operands) {\n\t\tswitch (operands.length) {\n\t\t\tcase 1: return new Nodes.TranscludeText(operands[0]);\n\t\t\tcase 2: return new Nodes.TranscludeField(operands[0], operands[1]);\n\t\t}\n\t}\n};\n\n// Transclude tiddler text string by name.\nexports.transclude_index = {\n\tmin_args: 2, max_args: 2,\n\tconstruct: function(operands) {return new Nodes.TranscludeIndex(operands[0], operands[1]);}\n};\n\n// Transclude field string by name.\nexports.variable = {\n\tmin_args: 1, max_args: 1,\n\tconstruct: function(operands) {return new Nodes.Variable(operands[0]);}\n};\n\n// Interpret value as a datum.\nexports.datum = {\n\tmin_args: 1, max_args: 1,\n\tconstruct: function(operands) {return new Nodes.Datum(operands[0]);}\n};\n\n\n})();"
        },
        "$:/plugins/ebalster/formula/lib/numeral.js": {
            "title": "$:/plugins/ebalster/formula/lib/numeral.js",
            "created": "20180114171007227",
            "modified": "20180114171115244",
            "module-type": "library",
            "revision": "0",
            "type": "application/javascript",
            "text": "/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n!function(a,b){\"function\"==typeof define&&define.amd?define(b):\"object\"==typeof module&&module.exports?module.exports=b():a.numeral=b()}(this,function(){function a(a,b){this._input=a,this._value=b}var b,c,d=\"2.0.6\",e={},f={},g={currentLocale:\"en\",zeroFormat:null,nullFormat:null,defaultFormat:\"0,0\",scalePercentBy100:!0},h={currentLocale:g.currentLocale,zeroFormat:g.zeroFormat,nullFormat:g.nullFormat,defaultFormat:g.defaultFormat,scalePercentBy100:g.scalePercentBy100};return b=function(d){var f,g,i,j;if(b.isNumeral(d))f=d.value();else if(0===d||\"undefined\"==typeof d)f=0;else if(null===d||c.isNaN(d))f=null;else if(\"string\"==typeof d)if(h.zeroFormat&&d===h.zeroFormat)f=0;else if(h.nullFormat&&d===h.nullFormat||!d.replace(/[^0-9]+/g,\"\").length)f=null;else{for(g in e)if(j=\"function\"==typeof e[g].regexps.unformat?e[g].regexps.unformat():e[g].regexps.unformat,j&&d.match(j)){i=e[g].unformat;break}i=i||b._.stringToNumber,f=i(d)}else f=Number(d)||null;return new a(d,f)},b.version=d,b.isNumeral=function(b){return b instanceof a},b._=c={numberToFormat:function(a,c,d){var e,g,h,i,j,k,l,m=f[b.options.currentLocale],n=!1,o=!1,p=0,q=\"\",r=1e12,s=1e9,t=1e6,u=1e3,v=\"\",w=!1;if(a=a||0,g=Math.abs(a),b._.includes(c,\"(\")?(n=!0,c=c.replace(/[\\(|\\)]/g,\"\")):(b._.includes(c,\"+\")||b._.includes(c,\"-\"))&&(j=b._.includes(c,\"+\")?c.indexOf(\"+\"):0>a?c.indexOf(\"-\"):-1,c=c.replace(/[\\+|\\-]/g,\"\")),b._.includes(c,\"a\")&&(e=c.match(/a(k|m|b|t)?/),e=e?e[1]:!1,b._.includes(c,\" a\")&&(q=\" \"),c=c.replace(new RegExp(q+\"a[kmbt]?\"),\"\"),g>=r&&!e||\"t\"===e?(q+=m.abbreviations.trillion,a/=r):r>g&&g>=s&&!e||\"b\"===e?(q+=m.abbreviations.billion,a/=s):s>g&&g>=t&&!e||\"m\"===e?(q+=m.abbreviations.million,a/=t):(t>g&&g>=u&&!e||\"k\"===e)&&(q+=m.abbreviations.thousand,a/=u)),b._.includes(c,\"[.]\")&&(o=!0,c=c.replace(\"[.]\",\".\")),h=a.toString().split(\".\")[0],i=c.split(\".\")[1],k=c.indexOf(\",\"),p=(c.split(\".\")[0].split(\",\")[0].match(/0/g)||[]).length,i?(b._.includes(i,\"[\")?(i=i.replace(\"]\",\"\"),i=i.split(\"[\"),v=b._.toFixed(a,i[0].length+i[1].length,d,i[1].length)):v=b._.toFixed(a,i.length,d),h=v.split(\".\")[0],v=b._.includes(v,\".\")?m.delimiters.decimal+v.split(\".\")[1]:\"\",o&&0===Number(v.slice(1))&&(v=\"\")):h=b._.toFixed(a,0,d),q&&!e&&Number(h)>=1e3&&q!==m.abbreviations.trillion)switch(h=String(Number(h)/1e3),q){case m.abbreviations.thousand:q=m.abbreviations.million;break;case m.abbreviations.million:q=m.abbreviations.billion;break;case m.abbreviations.billion:q=m.abbreviations.trillion}if(b._.includes(h,\"-\")&&(h=h.slice(1),w=!0),h.length<p)for(var x=p-h.length;x>0;x--)h=\"0\"+h;return k>-1&&(h=h.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g,\"$1\"+m.delimiters.thousands)),0===c.indexOf(\".\")&&(h=\"\"),l=h+v+(q?q:\"\"),n?l=(n&&w?\"(\":\"\")+l+(n&&w?\")\":\"\"):j>=0?l=0===j?(w?\"-\":\"+\")+l:l+(w?\"-\":\"+\"):w&&(l=\"-\"+l),l},stringToNumber:function(a){var b,c,d,e=f[h.currentLocale],g=a,i={thousand:3,million:6,billion:9,trillion:12};if(h.zeroFormat&&a===h.zeroFormat)c=0;else if(h.nullFormat&&a===h.nullFormat||!a.replace(/[^0-9]+/g,\"\").length)c=null;else{c=1,\".\"!==e.delimiters.decimal&&(a=a.replace(/\\./g,\"\").replace(e.delimiters.decimal,\".\"));for(b in i)if(d=new RegExp(\"[^a-zA-Z]\"+e.abbreviations[b]+\"(?:\\\\)|(\\\\\"+e.currency.symbol+\")?(?:\\\\))?)?$\"),g.match(d)){c*=Math.pow(10,i[b]);break}c*=(a.split(\"-\").length+Math.min(a.split(\"(\").length-1,a.split(\")\").length-1))%2?1:-1,a=a.replace(/[^0-9\\.]+/g,\"\"),c*=Number(a)}return c},isNaN:function(a){return\"number\"==typeof a&&isNaN(a)},includes:function(a,b){return-1!==a.indexOf(b)},insert:function(a,b,c){return a.slice(0,c)+b+a.slice(c)},reduce:function(a,b){if(null===this)throw new TypeError(\"Array.prototype.reduce called on null or undefined\");if(\"function\"!=typeof b)throw new TypeError(b+\" is not a function\");var c,d=Object(a),e=d.length>>>0,f=0;if(3===arguments.length)c=arguments[2];else{for(;e>f&&!(f in d);)f++;if(f>=e)throw new TypeError(\"Reduce of empty array with no initial value\");c=d[f++]}for(;e>f;f++)f in d&&(c=b(c,d[f],f,d));return c},multiplier:function(a){var b=a.toString().split(\".\");return b.length<2?1:Math.pow(10,b[1].length)},correctionFactor:function(){var a=Array.prototype.slice.call(arguments);return a.reduce(function(a,b){var d=c.multiplier(b);return a>d?a:d},1)},toFixed:function(a,b,c,d){var e,f,g,h,i=a.toString().split(\".\"),j=b-(d||0);return e=2===i.length?Math.min(Math.max(i[1].length,j),b):j,g=Math.pow(10,e),h=(c(a+\"e+\"+e)/g).toFixed(e),d>b-e&&(f=new RegExp(\"\\\\.?0{1,\"+(d-(b-e))+\"}$\"),h=h.replace(f,\"\")),h}},b.options=h,b.formats=e,b.locales=f,b.locale=function(a){return a&&(h.currentLocale=a.toLowerCase()),h.currentLocale},b.localeData=function(a){if(!a)return f[h.currentLocale];if(a=a.toLowerCase(),!f[a])throw new Error(\"Unknown locale : \"+a);return f[a]},b.reset=function(){for(var a in g)h[a]=g[a]},b.zeroFormat=function(a){h.zeroFormat=\"string\"==typeof a?a:null},b.nullFormat=function(a){h.nullFormat=\"string\"==typeof a?a:null},b.defaultFormat=function(a){h.defaultFormat=\"string\"==typeof a?a:\"0.0\"},b.register=function(a,b,c){if(b=b.toLowerCase(),this[a+\"s\"][b])throw new TypeError(b+\" \"+a+\" already registered.\");return this[a+\"s\"][b]=c,c},b.validate=function(a,c){var d,e,f,g,h,i,j,k;if(\"string\"!=typeof a&&(a+=\"\",console.warn&&console.warn(\"Numeral.js: Value is not string. It has been co-erced to: \",a)),a=a.trim(),a.match(/^\\d+$/))return!0;if(\"\"===a)return!1;try{j=b.localeData(c)}catch(l){j=b.localeData(b.locale())}return f=j.currency.symbol,h=j.abbreviations,d=j.delimiters.decimal,e=\".\"===j.delimiters.thousands?\"\\\\.\":j.delimiters.thousands,k=a.match(/^[^\\d]+/),null!==k&&(a=a.substr(1),k[0]!==f)?!1:(k=a.match(/[^\\d]+$/),null!==k&&(a=a.slice(0,-1),k[0]!==h.thousand&&k[0]!==h.million&&k[0]!==h.billion&&k[0]!==h.trillion)?!1:(i=new RegExp(e+\"{2}\"),a.match(/[^\\d.,]/g)?!1:(g=a.split(d),g.length>2?!1:g.length<2?!!g[0].match(/^\\d+.*\\d$/)&&!g[0].match(i):1===g[0].length?!!g[0].match(/^\\d+$/)&&!g[0].match(i)&&!!g[1].match(/^\\d+$/):!!g[0].match(/^\\d+.*\\d$/)&&!g[0].match(i)&&!!g[1].match(/^\\d+$/))))},b.fn=a.prototype={clone:function(){return b(this)},format:function(a,c){var d,f,g,i=this._value,j=a||h.defaultFormat;if(c=c||Math.round,0===i&&null!==h.zeroFormat)f=h.zeroFormat;else if(null===i&&null!==h.nullFormat)f=h.nullFormat;else{for(d in e)if(j.match(e[d].regexps.format)){g=e[d].format;break}g=g||b._.numberToFormat,f=g(i,j,c)}return f},value:function(){return this._value},input:function(){return this._input},set:function(a){return this._value=Number(a),this},add:function(a){function b(a,b,c,e){return a+Math.round(d*b)}var d=c.correctionFactor.call(null,this._value,a);return this._value=c.reduce([this._value,a],b,0)/d,this},subtract:function(a){function b(a,b,c,e){return a-Math.round(d*b)}var d=c.correctionFactor.call(null,this._value,a);return this._value=c.reduce([a],b,Math.round(this._value*d))/d,this},multiply:function(a){function b(a,b,d,e){var f=c.correctionFactor(a,b);return Math.round(a*f)*Math.round(b*f)/Math.round(f*f)}return this._value=c.reduce([this._value,a],b,1),this},divide:function(a){function b(a,b,d,e){var f=c.correctionFactor(a,b);return Math.round(a*f)/Math.round(b*f)}return this._value=c.reduce([this._value,a],b),this},difference:function(a){return Math.abs(b(this._value).subtract(a).value())}},b.register(\"locale\",\"en\",{delimiters:{thousands:\",\",decimal:\".\"},abbreviations:{thousand:\"k\",million:\"m\",billion:\"b\",trillion:\"t\"},ordinal:function(a){var b=a%10;return 1===~~(a%100/10)?\"th\":1===b?\"st\":2===b?\"nd\":3===b?\"rd\":\"th\"},currency:{symbol:\"$\"}}),function(){b.register(\"format\",\"bps\",{regexps:{format:/(BPS)/,unformat:/(BPS)/},format:function(a,c,d){var e,f=b._.includes(c,\" BPS\")?\" \":\"\";return a=1e4*a,c=c.replace(/\\s?BPS/,\"\"),e=b._.numberToFormat(a,c,d),b._.includes(e,\")\")?(e=e.split(\"\"),e.splice(-1,0,f+\"BPS\"),e=e.join(\"\")):e=e+f+\"BPS\",e},unformat:function(a){return+(1e-4*b._.stringToNumber(a)).toFixed(15)}})}(),function(){var a={base:1e3,suffixes:[\"B\",\"KB\",\"MB\",\"GB\",\"TB\",\"PB\",\"EB\",\"ZB\",\"YB\"]},c={base:1024,suffixes:[\"B\",\"KiB\",\"MiB\",\"GiB\",\"TiB\",\"PiB\",\"EiB\",\"ZiB\",\"YiB\"]},d=a.suffixes.concat(c.suffixes.filter(function(b){return a.suffixes.indexOf(b)<0})),e=d.join(\"|\");e=\"(\"+e.replace(\"B\",\"B(?!PS)\")+\")\",b.register(\"format\",\"bytes\",{regexps:{format:/([0\\s]i?b)/,unformat:new RegExp(e)},format:function(d,e,f){var g,h,i,j,k=b._.includes(e,\"ib\")?c:a,l=b._.includes(e,\" b\")||b._.includes(e,\" ib\")?\" \":\"\";for(e=e.replace(/\\s?i?b/,\"\"),h=0;h<=k.suffixes.length;h++)if(i=Math.pow(k.base,h),j=Math.pow(k.base,h+1),null===d||0===d||d>=i&&j>d){l+=k.suffixes[h],i>0&&(d/=i);break}return g=b._.numberToFormat(d,e,f),g+l},unformat:function(d){var e,f,g=b._.stringToNumber(d);if(g){for(e=a.suffixes.length-1;e>=0;e--){if(b._.includes(d,a.suffixes[e])){f=Math.pow(a.base,e);break}if(b._.includes(d,c.suffixes[e])){f=Math.pow(c.base,e);break}}g*=f||1}return g}})}(),function(){b.register(\"format\",\"currency\",{regexps:{format:/(\\$)/},format:function(a,c,d){var e,f,g,h=b.locales[b.options.currentLocale],i={before:c.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],after:c.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]};for(c=c.replace(/\\s?\\$\\s?/,\"\"),e=b._.numberToFormat(a,c,d),a>=0?(i.before=i.before.replace(/[\\-\\(]/,\"\"),i.after=i.after.replace(/[\\-\\)]/,\"\")):0>a&&!b._.includes(i.before,\"-\")&&!b._.includes(i.before,\"(\")&&(i.before=\"-\"+i.before),g=0;g<i.before.length;g++)switch(f=i.before[g]){case\"$\":e=b._.insert(e,h.currency.symbol,g);break;case\" \":e=b._.insert(e,\" \",g+h.currency.symbol.length-1)}for(g=i.after.length-1;g>=0;g--)switch(f=i.after[g]){case\"$\":e=g===i.after.length-1?e+h.currency.symbol:b._.insert(e,h.currency.symbol,-(i.after.length-(1+g)));break;case\" \":e=g===i.after.length-1?e+\" \":b._.insert(e,\" \",-(i.after.length-(1+g)+h.currency.symbol.length-1))}return e}})}(),function(){b.register(\"format\",\"exponential\",{regexps:{format:/(e\\+|e-)/,unformat:/(e\\+|e-)/},format:function(a,c,d){var e,f=\"number\"!=typeof a||b._.isNaN(a)?\"0e+0\":a.toExponential(),g=f.split(\"e\");return c=c.replace(/e[\\+|\\-]{1}0/,\"\"),e=b._.numberToFormat(Number(g[0]),c,d),e+\"e\"+g[1]},unformat:function(a){function c(a,c,d,e){var f=b._.correctionFactor(a,c),g=a*f*(c*f)/(f*f);return g}var d=b._.includes(a,\"e+\")?a.split(\"e+\"):a.split(\"e-\"),e=Number(d[0]),f=Number(d[1]);return f=b._.includes(a,\"e-\")?f*=-1:f,b._.reduce([e,Math.pow(10,f)],c,1)}})}(),function(){b.register(\"format\",\"ordinal\",{regexps:{format:/(o)/},format:function(a,c,d){var e,f=b.locales[b.options.currentLocale],g=b._.includes(c,\" o\")?\" \":\"\";return c=c.replace(/\\s?o/,\"\"),g+=f.ordinal(a),e=b._.numberToFormat(a,c,d),e+g}})}(),function(){b.register(\"format\",\"percentage\",{regexps:{format:/(%)/,unformat:/(%)/},format:function(a,c,d){var e,f=b._.includes(c,\" %\")?\" \":\"\";return b.options.scalePercentBy100&&(a=100*a),c=c.replace(/\\s?\\%/,\"\"),e=b._.numberToFormat(a,c,d),b._.includes(e,\")\")?(e=e.split(\"\"),e.splice(-1,0,f+\"%\"),e=e.join(\"\")):e=e+f+\"%\",e},unformat:function(a){var c=b._.stringToNumber(a);return b.options.scalePercentBy100?.01*c:c}})}(),function(){b.register(\"format\",\"time\",{regexps:{format:/(:)/,unformat:/(:)/},format:function(a,b,c){var d=Math.floor(a/60/60),e=Math.floor((a-60*d*60)/60),f=Math.round(a-60*d*60-60*e);return d+\":\"+(10>e?\"0\"+e:e)+\":\"+(10>f?\"0\"+f:f)},unformat:function(a){var b=a.split(\":\"),c=0;return 3===b.length?(c+=60*Number(b[0])*60,c+=60*Number(b[1]),c+=Number(b[2])):2===b.length&&(c+=60*Number(b[0]),c+=Number(b[1])),Number(c)}})}(),b});"
        },
        "$:/plugins/ebalster/formula/license": {
            "title": "$:/plugins/ebalster/formula/license",
            "caption": "license",
            "created": "20171220071005710",
            "modified": "20171220211838536",
            "revision": "0",
            "tags": "",
            "type": "text/vnd.tiddlywiki",
            "text": "!!The MIT License (MIT)\n\nCopyright (c) 2017 Evan Balster\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        "$:/plugins/ebalster/formula/macros/formula.js": {
            "title": "$:/plugins/ebalster/formula/macros/formula.js",
            "created": "20171210215758530",
            "modified": "20171212194124031",
            "module-type": "macro",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Compute = require(\"$:/plugins/ebalster/formula/compute.js\");\n\n/*\n\tInformation about this macro\n*/\n\nexports.name = \"formula\";\nexports.params = [{\"name\": \"formula\"}];\n\n/*\nRun the macro\n*/\nexports.run = function(formula) {\n\n\ttry {\n\t\treturn Compute.evalFormula(formula, this);\n\t}\n\tcatch (err) {\n\t\treturn \"`\" + String(err) + \"`\";\n\t}\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/nodes.js": {
            "title": "$:/plugins/ebalster/formula/nodes.js",
            "created": "20171211183000431",
            "description": "",
            "modified": "20180112071139424",
            "module-type": "library",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/plugins/ebalster/formula/nodes.js\ntype: application/javascript\nmodule-type: macro\n\nLibrary defining computation \"nodes\" used to build compiled formulas.\nOperands represent some value within the formula: an expression, datum, operator, constant or query...\nOperands may be constant, allowing the formula compiler to optimize them away.\n\n\\*/\n(function(){\n\n\"use strict\";\n\nvar Coerce = require(\"$:/plugins/ebalster/formula/coerce.js\");\n\n\n// A Context has all the information necessary for computations.\nexports.Context = function(widget, formats, locals, depth, maxDepth) {\n\tthis.widget = widget;\n\tthis.formats = formats || {};\n\tthis.locals = locals || {};\n\tthis.depth = depth || 1;\n\tthis.maxDepth = maxDepth || 256;\n\tif (this.maxDepth < this.depth) throw \"Formula recursion exceeds limit of \" + this.maxDepth + \".  Infinite regress?\";\n};\nexports.Context.prototype.sub          = function()        {return new exports.Context(this.widget,this.formats,null,this.depth+1,this.maxDepth);};\nexports.Context.prototype.let          = function(locals)  {return new exports.Context(this.widget,this.formats,locals,this.depth,this.maxDepth);};\nexports.Context.prototype.wiki         = function()        {return this.widget.wiki;};\nexports.Context.prototype.wikiVariable = function(name)    {return this.widget.getVariable(name);};\n\n\nexports.Node = function() {\n};\nexports.Node.prototype.is_constant = false;\nexports.Node.prototype.name = \"unknown-operand\";\nexports.Node.prototype.toString = function()    {return \"[Node \" + this.name + \"]\";};\n\n// Compute the Node's value.\nexports.Node.prototype.compute = function(ctx) {return undefined;};\n\n// Compute a specific type of value, with coercion if necessary.\nexports.Node.prototype.computeNum   = function(ctx) {return Coerce.ToNum  (this.compute(ctx), ctx);};\nexports.Node.prototype.computeText  = function(ctx) {return Coerce.ToText (this.compute(ctx), ctx);};\nexports.Node.prototype.computeBool  = function(ctx) {return Coerce.ToBool (this.compute(ctx), ctx);};\nexports.Node.prototype.computeDate  = function(ctx) {return Coerce.ToDate (this.compute(ctx), ctx);};\nexports.Node.prototype.computeArray = function(ctx) {return Coerce.ToArray(this.compute(ctx), ctx);};\nexports.Node.prototype.computeFunc  = function(ctx) {return Coerce.ToFunc (this.compute(ctx), ctx);};\n\n\n// An operand that just throws an error.\nexports.ThrowError = function(exception) {\n\tthis.exception = exception;\n};\nexports.ThrowError.prototype = new exports.Node();\nexports.ThrowError.prototype.name = \"error\";\nexports.ThrowError.prototype.compute = function(ctx)\n{\n\t// Throw up\n\tthrow this.exception;\n};\n\n// Scoped variable node.\nexports.ScopeVar = function(name) {\n\tthis.name = name;\n};\nexports.ScopeVar.prototype = new exports.Node();\n//exports.ScopeVar.prototype.name = \"scope-var\";\nexports.ScopeVar.prototype.compute = function(ctx) {return ctx.locals[this.name];};\n\n// Scoped variable assignment node.\nexports.LetVars = function(assigns, expr) {\n\tthis.assigns = assigns;\n\tthis.expr = expr;\n};\nexports.LetVars.prototype = new exports.Node();\nexports.LetVars.prototype.name = \"let\";\nexports.LetVars.prototype.compute = function(ctx) {\n\t// Each let-expression can access the ones before it.\n\tvar locals = Object.assign({}, ctx.locals);\n\tctx = ctx.let(locals);\n\tfor (var id in this.assigns) {\n\t\ttry {\n\t\t\tlocals[id] = this.assigns[id].compute(ctx);\n\t\t}\n\t\tcatch (err) {\n\t\t\tthrow \"computing LET '\" + id + \"': \" + err;\n\t\t}\n\t}\n\treturn this.expr.compute(ctx);\n};\n\n// Call a function by reference.\nexports.CallFunc = function CallFunc(func, args) {\n\tthis.func = func;\n\tthis.args = args;\n};\nexports.CallFunc.prototype = new exports.Node();\nexports.CallFunc.prototype.name = \"function-builtin\";\nexports.CallFunc.prototype.compute = (function(ctx) {\n\t// Check the function parameters.\n\tvar func = this.func.computeFunc(ctx);\n\tif (this.args.length < func.min_args) throw \"Too few parameters for function\";\n\tif (this.args.length > func.max_args) throw \"Too many parameters for function\";\n\t// Compute arguments.\n\tvar vals = [];\n\tfor (var i = 0; i < this.args.length; ++i) vals.push(this.args[i].compute(ctx));\n\t// Call the function!\n\treturn func.apply(ctx, vals);\n});\n\n// JavaScript function call with possible coercion.\nexports.CallJS = function CallJS(func, args) {\n\tthis.func = func;\n\tthis.args = args;\n\tthis.coerce = Coerce.GetCoerceFuncs(func, args);\n\tthis.n_coerce = Math.min(this.args.length, this.coerce.length);\n};\nexports.CallJS.prototype = new exports.Node();\nexports.CallJS.prototype.name = \"function-builtin\";\nexports.CallJS.prototype.compute = function(ctx) {\n\tvar vals = [];\n\tvar i = 0;\n\tfor (; i < this.n_coerce; ++i) vals.push(this.coerce[i](this.args[i].compute(ctx), ctx));\n\tfor (; i < this.args.length; ++i) vals.push(this.args[i].compute(ctx));\n\treturn this.func.apply(ctx, vals);\n};\n\n// Call a function by reference.\nexports.ArrayDef = function ArrayDef(elems) {\n\tthis.elems = elems;\n};\nexports.ArrayDef.prototype = new exports.Node();\nexports.ArrayDef.prototype.name = \"function-builtin\";\nexports.ArrayDef.prototype.compute = (function(ctx) {\n\t// Compute elements.\n\tvar elems = [];\n\tfor (var i = 0; i < this.elems.length; ++i) elems.push(this.elems[i].compute(ctx));\n\treturn elems;\n});\n\n\n// Function declaration operand.\nexports.Function = function(func, captures) {\n\tthis.func = func;\n\tthis.captures = captures;\n};\nexports.Function.prototype = new exports.Node();\nexports.Function.prototype.name = \"function\";\nexports.Function.prototype.is_constant = true;\nexports.Function.prototype.compute = function(ctx) {\n\tthis.func.captured = {};\n\tif (this.captures) {\n\t\tfor (var name in this.captures) {\n\t\t\tthis.func.captured[name] = ctx.locals[name];\n\t\t}\n\t}\n\treturn this.func;\n};\n\n// String constant operand.\nexports.Text = function(value) {this.value = value;};\nexports.Text.prototype = new exports.Node();\nexports.Text.prototype.name = \"string\";\nexports.Text.prototype.is_constant = true;\nexports.Text.prototype.compute = function(ctx) {return this.value;};\n\n// Date constant operand.\nexports.Date = function(value) {this.value = value;};\nexports.Date.prototype = new exports.Node();\nexports.Date.prototype.name = \"date\";\nexports.Date.prototype.is_constant = true;\nexports.Date.prototype.compute = function(ctx) {return this.value;};\n\n// Boolean constant operand.\nexports.Bool = function(value) {this.value = value;};\nexports.Bool.prototype = new exports.Node();\nexports.Bool.prototype.name = \"boolean\";\nexports.Bool.prototype.is_constant = true;\nexports.Bool.prototype.compute = function(ctx) {return this.value;};\n\n// Number constant operand.\nexports.Number = function(value) {this.value = value;};\nexports.Number.prototype = new exports.Node();\nexports.Number.prototype.name = \"number\";\nexports.Number.prototype.is_constant = true;\nexports.Number.prototype.compute = function(ctx) {return this.value;};\n\n// Regex constant operand.\nexports.Regex = function(value) {this.value = value;};\nexports.Regex.prototype = new exports.Node();\nexports.Regex.prototype.name = \"regex\";\nexports.Regex.prototype.is_constant = true;\nexports.Regex.prototype.compute = function(ctx) {return this.value;};\n\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n\n// \"Automatic\" operand; a compiled string value\nexports.Datum = function(origin) {\n\tthis.origin = origin;\n\tthis.text = null;\n\tthis.op = null;\n};\nexports.Datum.prototype = new exports.Node();\nexports.Datum.prototype.name = \"automatic\";\n\nexports.Datum.prototype.compute = function(ctx) {\n\n\tvar newText = this.origin.computeText(ctx);\n\n\tif (newText != this.text)\n\t{\n\t\tthis.text = newText;\n\t\ttry {\n\t\t\tthis.op = Compile.compileDatum(newText);\n\t\t}\n\t\tcatch (err) {\n\t\t\t// Save the error\n\t\t\tthis.op = new exports.ThrowError(\n\t\t\t\terr + \"\\n  source: \\\"\" + this.datum + \"\\\"\\n  from \" + origin.name);\n\t\t}\n\t}\n\n\treturn this.op.compute(ctx.sub());\n};\n\n\n// Transcluded text operand.\nexports.TranscludeText = function(title) {\n\tthis.title = title;\n};\nexports.TranscludeText.prototype = new exports.Node();\nexports.TranscludeText.prototype.name = \"transclude\";\n\nexports.TranscludeText.prototype.compute = function(ctx) {\n\treturn ctx.wiki().getTiddlerText(this.title.computeText(ctx),\"\");\n};\n\n// Transcluded field operand.\nexports.TranscludeField = function(title, field) {\n\tthis.title = title;\n\tthis.field = field;\n};\nexports.TranscludeField.prototype = new exports.Node();\nexports.TranscludeField.prototype.name = \"transclude-field\";\n\nexports.TranscludeField.prototype.compute = function(ctx) {\n\tvar tiddler = ctx.wiki().getTiddler(this.title.computeText(ctx)),\n\t\tfield = this.field.computeText(ctx);\n\treturn (tiddler && $tw.utils.hop(tiddler.fields,field)) ? tiddler.getFieldString(field) : \"\";\n};\n\n// Transcluded index operand.\nexports.TranscludeIndex = function(title, index) {\n\tthis.title = title;\n\tthis.index = index;\n};\nexports.TranscludeIndex.prototype = new exports.Node();\nexports.TranscludeIndex.prototype.name = \"transclude-index\";\n\nexports.TranscludeIndex.prototype.compute = function(ctx) {\n\treturn ctx.wiki().extractTiddlerDataItem(\n\t\tthis.title.computeText(ctx),\n\t\tthis.index.computeText(ctx),\"\");\n};\n\n\n// Variable operand.\nexports.Variable = function(variable) {\n\tthis.variable = variable;\n};\nexports.Variable.prototype = new exports.Node();\nexports.Variable.prototype.name = \"variable\";\n\nexports.Variable.prototype.compute = function(ctx) {\n\treturn ctx.wikiVariable(this.variable.computeText(ctx)) || \"\";\n};\n\n\n// Filter operand, with some lazy-compile optimizations.\nexports.Filter = function(filter) {\n\tthis.filter = filter;\n\tthis.elements = {}; // Each has count, op, value\n\t//this.array = [];\n\tthis.compileError = null;\n};\nexports.Filter.prototype = new exports.Node();\nexports.Filter.prototype.name = \"filter\";\n\nexports.Filter.prototype.compute = function(ctx) {\n\t// Apply the filter and compile each result\n\tvar i, expr, elem, exprs = ctx.wiki().filterTiddlers(this.filter, ctx.widget);\n\n\t// Clear the array and mark all existing elements for removal\n\tfor (expr in this.elements) this.elements[expr].count = 0;\n\t//this.array = [];\n\n\t// Selectively re-compile any filter results that have changed\n\tfor (i = 0; i < exprs.length; ++i)\n\t{\n\t\texpr = exprs[i];\n\t\telem = this.elements[expr];\n\t\t//this.array.push(expr);\n\t\t\n\t\tif (elem) ++elem.count;\n\t\telse try {\n\t\t\tthis.elements[expr] = {count: 1, op: Compile.compileDatum(expr), value: null};\n\t\t}\n\t\tcatch (err) {\n\t\t\t// Save the error\n\t\t\tthis.elements[expr] = new exports.ThrowError(\n\t\t\t\terr + \"\\n  source: \\\"\" + expr + \"\\\"\\n  from \\\"\" + this.filter + \"\\\"\");\n\t\t}\n\t}\n\n\t// Compute (unique) values.  Delete any elements with no copies left.\n\tfor (expr in this.elements) {\n\t\telem = this.elements[expr];\n\t\tif (elem.count === 0) delete this.elements[expr];\n\t\telse elem.val = elem.op.compute(ctx.sub());\n\t}\n\n\t// Return value computes an array of datum values.\n\tvar results = [];\n\tfor (i = 0; i < exprs.length; ++i) {\n\t\texpr = exprs[i];\n\t\tresults.push(this.elements[expr].val);\n\t}\n\treturn results;\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/operators/arithmetic.js": {
            "title": "$:/plugins/ebalster/formula/operators/arithmetic.js",
            "created": "20171212223503019",
            "modified": "20171212223539769",
            "module-type": "formula-operator",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Unary sign operators\nexports.uplus    = {arity: 1, position: \"pre\",  operator: \"+\", function: \"uplus\"};\nexports.uminus   = {arity: 1, position: \"pre\",  operator: \"-\", function: \"uminus\"};\n\n// Add\nexports.plus     = {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"};\nexports.minus    = {arity: 2, precedence: 10,   operator: \"-\", function: \"sub\"};\n\n// Multiply\nexports.multiply = {arity: 2, precedence: 20,   operator: \"*\", function: \"mul\"};\nexports.divide   = {arity: 2, precedence: 20,   operator: \"/\", function: \"div\"};\n\n// Exponential\nexports.pow      = {arity: 2, precedence: 30,   operator: \"^\", function: \"pow\", associativity: \"right\"};\n\n// Percentage\nexports.percent  = {arity: 1, position: \"post\", operator: \"%\", function: \"percent\"};\n\n})();"
        },
        "$:/plugins/ebalster/formula/operators/compare.js": {
            "title": "$:/plugins/ebalster/formula/operators/compare.js",
            "created": "20171214050556123",
            "modified": "20171214050739104",
            "module-type": "formula-operator",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Equality\nexports.eq  = {arity: 2, precedence: 0,   operator: \"=\",  function: \"eq\"};\nexports.ne  = {arity: 2, precedence: 0,   operator: \"<>\", function: \"ne\"};\n\n// Inequality\nexports.gt  = {arity: 2, precedence: 0,   operator: \">\",  function: \"gt\"};\nexports.gte = {arity: 2, precedence: 0,   operator: \">=\", function: \"gte\"};\nexports.lt  = {arity: 2, precedence: 0,   operator: \"<\",  function: \"lt\"};\nexports.lte = {arity: 2, precedence: 0,   operator: \"<=\", function: \"lte\"};\n\n})();"
        },
        "$:/plugins/ebalster/formula/operators/strings.js": {
            "title": "$:/plugins/ebalster/formula/operators/strings.js",
            "created": "20171213003246267",
            "modified": "20171213003346943",
            "module-type": "formula-operator",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Concatenate\nexports.concatenate = {arity: 2, precedence: 4, operator: \"&\", function: \"cat\"};\n\n})();"
        },
        "$:/plugins/ebalster/formula/readme": {
            "title": "$:/plugins/ebalster/formula/readme",
            "caption": "readme",
            "created": "20171220042006170",
            "modified": "20171220212520970",
            "revision": "0",
            "tags": "",
            "type": "text/vnd.tiddlywiki",
            "text": "''Formula'' for TiddlyWiki, version {{$:/plugins/ebalster/formula!!version}}, by Evan Balster. Updated by [[Joshua Fontany||https://joshuafontany.github.com/]]\n\nFormulas are written between `(=` mushroom brackets `=)`.  Where possible, their functions and syntax are designed to emulate popular spreadsheet software (Microsoft Excel and Google Sheets).  They //also// support WikiText-like syntax for `{{`transclusion`}}`, `[`filters`]`, `<<`variables`>>`, and a large number of functions.\n\nFormulas can also be evaluated by the `$formula` widget, the `$formula-vars` widget and the `<<formula>>` macro.\n\nFurther documentation is available here: [[https://evanbalster.com/tiddlywiki/formulas.html]].\n\nThis plugin is a work in progress; please report any issues on GitHub: [[https://github.com/EvanBalster/TiddlyWikiFormula/issues]]."
        },
        "$:/plugins/ebalster/formula/settings": {
            "title": "$:/plugins/ebalster/formula/settings",
            "caption": "readme",
            "created": "20171221001634811",
            "modified": "20171221002035357",
            "revision": "0",
            "tags": "",
            "type": "text/vnd.tiddlywiki",
            "text": "Currently no global settings are implemented, but formulas can be controlled by setting some global macros.  For example:\n\n|Macro|Meaning|h\n|`\\define formulaFixed() 2`|makes numbers display with 2 decimal points.|\n|`\\define formulaPrecision() 4`|makes numbers display with 4 significant digits (but `formulafixed` takes priority.|\n|`\\define formulaDateFormat() YYYY-MM-0DD`|Sets a date display format using the same rules as TiddlyWiki.|\n\nPlace these at the top of the tiddler where they should take effect, or create a tiddler tagged with <<tag $:/tags/Macro>> to make them apply to all tiddlers.\n\nIn the future, we'll probably add some global settings here..."
        },
        "$:/plugins/ebalster/formula/value.js": {
            "title": "$:/plugins/ebalster/formula/value.js",
            "created": "20171211195003728",
            "description": "",
            "modified": "20171211195014088",
            "module-type": "library",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n\"use strict\";\n\n\nexports.NumberFormatFunc = null;\n\nexports.DateFormat = \"0hh:0mm, DDth MMM YYYY\";\n\n\n// Base type for formula values\nexports.Value = function() {\n  this.name = \"unknown-value\";\n};\n\n// Get the value payload\nexports.Value.prototype.get = function()    {return undefined;};\n\n// Describe the value\nexports.Value.prototype.describe = function()    {return this.name + \" (\" + String(this.get()) + \")\";};\n\nexports.Value.prototype.toString = function()    {return \"[Value \" + this.describe() + \"]\";};\n\n// Get the value as a number (generic implementation)\nexports.Value.prototype.asNum = function() {\n  var v = this.get();\n  var n = Number(v);\n  if (isNaN(n)) throw \"Cannot convert \" + this.describe() + \" to a number!\";\n  return n;\n};\n\n// Get the value as a number, summing arrays (generic implementation)\nexports.Value.prototype.asSum = function() {\n  var v = this.get();\n  var n;\n  if (Array.isArray(v)) {n = 0; for (var i = 0; i < v.length; ++i) n += Number(v[i]);}\n  else                  n = Number(v);\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n};\n\n// More convertsions\nexports.Value.prototype.asString = function() {\n  return String(this.get());\n};\nexports.Value.prototype.asArray = function() {\n  var v = this.get();\n  if (Array.isArray(v)) return v;\n  else return [v];\n};\nexports.Value.prototype.asDate = function() {\n  throw \"Cannot convert \" + this.describe() + \" to a date!\";\n};\n\n\n// Undefined value.\nexports.V_Undefined = function() {\n  this.name = \"undefined\";\n};\nexports.V_Undefined.prototype = new exports.Value();\nexports.V_Undefined.prototype.get = function()    {return undefined;};\n\n\n// Array value.\nexports.V_Array = function(value) {\n  this.name = \"array\";\n\n  this.value = value;\n};\nexports.V_Array.prototype = new exports.Value();\nexports.V_Array.prototype.get   = function() {return this.value;};\nexports.V_Array.prototype.asNum = function() {throw \"Cannot convert \" + this.describe() + \" to number!\";};\nexports.V_Array.prototype.asSum = function() {\n  var n = 0;\n  for (var i = 0; i < this.value.length; ++i) n += this.value[i].asNum();\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n};\nexports.V_Array.prototype.asString     = function() {\n  var result = \"\";\n  for (var i = 0; i < this.value.length; ++i) {\n    var part = this.value[i].asString();\n    if (i && part.length) result += \" \";\n    if (part.indexOf(/\\s/g) >= 0) result += \"[[\" + part + \"]]\";\n    else result += part;\n  }\n  return result;\n};\n\n\n// String value.\nexports.V_Text = function(value) {\n  this.name = \"string\";\n\n  this.value = value;\n};\nexports.V_Text.prototype = new exports.Value();\nexports.V_Text.prototype.get    = function()    {return this.value;};\n//exports.V_Text.prototype.asDate = function() {return $tw.utils.parseDate();}\n\n\n// Date value.\nexports.V_Date = function(value) {\n  this.name = \"date\";\n\n  this.value = value;\n};\nexports.V_Date.prototype = new exports.Value();\nexports.V_Date.prototype.get      = function()    {return this.value;};\nexports.V_Date.prototype.asString = function()    {return $tw.utils.formatDateString(this.value, exports.DateFormat);};\nexports.V_Date.prototype.asNum    = function()    {throw \"Date-to-Number conversion usupported\";};\nexports.V_Date.prototype.asSum    = function()    {throw \"Date-to-Number conversion usupported\";};\nexports.V_Date.prototype.asDate   = function()    {return this.value;};\n\n\n// Boolean value.\nexports.V_Bool = function(value) {\n  this.name = \"boolean\";\n\n  this.value = value;\n};\nexports.V_Bool.prototype = new exports.Value();\nexports.V_Bool.prototype.get      = function()    {return this.value;};\nexports.V_Bool.prototype.asString = function()    {return this.value ? \"TRUE\" : \"FALSE\";};\nexports.V_Bool.prototype.asNum    = function()    {return this.value ? 1 : 0;};\nexports.V_Bool.prototype.asSum    = function()    {return this.value ? 1 : 0;};\n\n\n// Number value.\nexports.V_Num = function(value) {\n  this.name = \"number\";\n\n  this.value = value;\n};\nexports.V_Num.prototype = new exports.Value();\nexports.V_Num.prototype.get      = function()    {return this.value;};\nexports.V_Num.prototype.asString = function()    {return (exports.NumberFormatFunc || String)(this.value);};\nexports.V_Num.prototype.asNum    = function()    {return this.value;};\nexports.V_Num.prototype.asSum    = function()    {return this.value;};\n\n\n// Percentage value.\nexports.V_Percent = function(value) {\n  this.name = \"percentage\";\n\n  this.value = value;\n};\nexports.V_Percent.prototype = new exports.V_Num();\nexports.V_Percent.prototype.asString = function()\n{\n  return (exports.NumberFormatFunc || String)(100*this.value) + \"%\";\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/widgets/attributes/formula.js": {
            "title": "$:/plugins/ebalster/formula/widgets/attributes/formula.js",
            "created": "20171225035721011",
            "description": "Evaluates a formula as an attribute value string.",
            "modified": "20171225035808674",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Compute = require(\"$:/plugins/ebalster/formula/compute.js\");\nvar Nodes   = require(\"$:/plugins/ebalster/formula/nodes.js\");\n\nvar FormulaAttribute = function(widget, node) {\n\tthis.widget = widget;\n\tthis.formula = node.formula;\n\ttry {\n\t\tthis.compiledFormula = Compile.compileFormula(this.formula);\n\t}\n\tcatch (err) {\n\t\tthis.compiledFormula = new Nodes.ThrowError(err);\n\t}\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new Attribute();\n\nFormulaAttribute.prototype.compute = function() {\n\t// Compute options\n\tthis.formatOptions =\n\t{\n\t\tfixed:        (this.widget.getVariable(\"formulaFixed\")),\n\t\tprecision:    (this.widget.getVariable(\"formulaPrecision\")),\n\t\tnumberFormat: (this.widget.getVariable(\"formulaNumberFormat\")),\n\t\tdateFormat:   (this.widget.getVariable(\"formulaDateFormat\")),\n\t};\n\t// Execute the formula.\n\ttry {\n\t\treturn Compute.computeFormula(this.compiledFormula, this.widget, this.formatOptions);\n\t}\n\tcatch (err) {\n\t\treturn \"\";\n\t}\n};\n\nFormulaAttribute.prototype.refresh = function(changedTiddlers) {\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.formula = FormulaAttribute;\n\n})();\n\t"
        },
        "$:/plugins/ebalster/formula/widgets/formula-vars.js": {
            "title": "$:/plugins/ebalster/formula/widgets/formula-vars.js",
            "created": "20171216003055342",
            "description": "As the $vars widget, but each attribute is interpreted as a formula.",
            "modified": "20171222071557661",
            "module-type": "widget",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Compute = require(\"$:/plugins/ebalster/formula/compute.js\");\n\nvar FormulaVarsWidget = function(parseTreeNode,options) {\n\t// Call the constructor\n\tWidget.call(this);\n\t// Initialise\t\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaVarsWidget.prototype = Object.create(Widget.prototype);\n\n/*\nRender this widget into the DOM\n*/\nFormulaVarsWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\n\tif (this.formulaError) {\n\t\t// Show an error.\n\t\tvar parseTreeNodes = [{type: \"element\", tag: \"span\", attributes: {\n\t\t\t\"class\": {type: \"string\", value: \"tc-error\"}\n\t\t}, children: [\n\t\t\t{type: \"text\", text: this.formulaError}\n\t\t]}];\n\t\tthis.makeChildWidgets(parseTreeNodes);\n\t}\n\telse {\n\t\t// Construct and render the child widgets.\n\t\tthis.makeChildWidgets();\n\t}\n\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nRecompute formulas\n*/\nFormulaVarsWidget.prototype.formula_recompute = function() {\n\t// Parse variables\n\tvar self = this;\n\n\tthis.formatOptions =\n\t{\n\t\tfixed:        (this.getAttribute(\"$fixed\")        || this.parentWidget.getVariable(\"formulaFixed\")),\n\t\tprecision:    (this.getAttribute(\"$precision\")    || this.parentWidget.getVariable(\"formulaPrecision\")),\n\t\tnumberFormat: (this.getAttribute(\"$numberFormat\") || this.parentWidget.getVariable(\"formulaNumberFormat\")),\n\t\tdateFormat:   (this.getAttribute(\"$dateFormat\")   || this.parentWidget.getVariable(\"formulaDateFormat\")),\n\t};\n\n\t// Deprecation\n\tif (this.getAttribute(\"$toFixed\")) {this.formulaError = \"Change '$toFixed' to '$fixed'.\"; return;}\n\tif (this.getAttribute(\"$toPrecision\")) {this.formulaError = \"Change '$toPrecision' to '$precision'.\"; return;}\n\n\tif (!this.currentValues)\n\t{\n\t\t// Initial values\n\t\tthis.currentValues = {};\n\t\tthis.formulaSrc = {};\n\t\tthis.formulaComp = {};\n\t}\n\n\tthis.formulaError = null;\n\n\ttry {\n\t\tif (this.getAttribute(\"$noRefresh\")) throw \"Illegal $noRefresh attribute; use $noRebuild instead.\";\n\n\t\t$tw.utils.each(this.attributes,function(val,key) {\n\t\t\tif(key.charAt(0) !== \"$\") {\n\t\t\t\t// Recompile if necessary\n\t\t\t\tif (self.formulaSrc[key] != val) {\n\t\t\t\t\tself.formulaSrc[key] = val;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself.formulaComp[key] = Compile.compileFormula(self.formulaSrc[key]);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\tself.formulaSrc[key] = null;\n\t\t\t\t\t\tthrow \"Variable \" + key + \": \" + String(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Recompute the formula\n\t\t\t\tif (self.formulaComp[key]) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself.currentValues[key] = Compute.computeFormula(\n\t\t\t\t\t\t\tself.formulaComp[key], self, self.formatOptions);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\tthrow \"Variable \" + key + \": \" + String(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow \"Variable \" + key + \": Formula not assigned\";\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tcatch (err) {\n\t\tthis.formulaError = String(err);\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaVarsWidget.prototype.execute = function() {\n\t// Recompute formulas\n\tthis.formula_recompute();\n\n\tif (!this.formulaError) {\n\t\tfor (var key in this.currentValues) {\n\t\t\tthis.setVariable(key, this.currentValues[key]);\n\t\t}\n\t}\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nFormulaVarsWidget.prototype.refresh = function formulaVarsRefresh(changedTiddlers) {\n\tthis.computeAttributes();\n\tvar oldValues = Object.assign({}, this.currentValues || {}), oldError = this.formulaError;\n\tthis.formula_recompute();\n\n\t// Did any computed values change?\n\tvar changedValues = false;\n\tfor (var key in this.currentValues) {\n\t\tif (this.currentValues[key] !== oldValues[key]) {\n\t\t\tthis.setVariable(key, this.currentValues[key]);\n\t\t\tchangedValues = true;\n\t\t}\n\t}\n\n\t// Option to suppress full refreshing\n\tif (this.getAttribute(\"$noRebuild\") === \"true\") changedValues = false;\n\tif (this.formulaError !== oldError) changedValues = true;\n\n\tif(changedValues) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\nexports[\"formula-vars\"] = FormulaVarsWidget;\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/widgets/formula.js": {
            "title": "$:/plugins/ebalster/formula/widgets/formula.js",
            "created": "20171210232543292",
            "description": "Evaluates a formula.",
            "modified": "20171212194059701",
            "module-type": "widget",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Compute = require(\"$:/plugins/ebalster/formula/compute.js\");\n\nvar FormulaWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nFormulaWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.rerender(parent,nextSibling);\n};\n\nFormulaWidget.prototype.rerender = function(parent, nextSibling) {\n\n\tthis.removeChildDomNodes();\n\n\tvar parseTreeNodes;\n\n\tif (this.formulaError) {\n\t\t// Show an error as a tc-error span.\n\t\tparseTreeNodes = [{type: \"element\", tag: \"span\", attributes: {\n\t\t\t\"class\": {type: \"string\", value: \"tc-error\"}\n\t\t}, children: [\n\t\t\t{type: \"text\", text: this.formulaError}\n\t\t]}];\n\t}\n\telse {\n\t\t// Parse the value, or, failing this, produce a text node.\n\t\tvar parser = this.wiki.parseText(\n\t\t\tthis.wikifyType, this.currentValue,\n\t\t\t{parseAsInline: this.wikifyMode === \"inline\"});\n\t\tparseTreeNodes = (parser ? parser.tree : [{type: \"text\", text: this.currentValue}]);\n\t}\n\n\t// Construct and render the child widgets.\n\tthis.makeChildWidgets(parseTreeNodes);\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaWidget.prototype.execute = function() {\n\n\tvar oldFormula = this.formula;\n\n\t// Get parameters from our attributes\n\tthis.formula   = this.getAttribute(\"formula\");\n\tthis.debug     = this.getAttribute(\"debug\");\n\n\tthis.wikifyType = this.getAttribute(\"outputType\");\n\tthis.wikifyMode = this.getAttribute(\"outputMode\",\"inline\");\n\n\tthis.formatOptions =\n\t{\n\t\tfixed:        (this.getAttribute(\"fixed\")        || this.getVariable(\"formulaFixed\")),\n\t\tprecision:    (this.getAttribute(\"precision\")    || this.getVariable(\"formulaPrecision\")),\n\t\tnumberFormat: (this.getAttribute(\"numberFormat\") || this.getVariable(\"formulaNumberFormat\")),\n\t\tdateFormat:   (this.getAttribute(\"dateFormat\")   || this.getVariable(\"formulaDateFormat\")),\n\t};\n\n\t// Deprecation\n\tif (this.getAttribute(\"toFixed\")) {this.formulaError = \"Change 'toFixed' to 'fixed'.\"; return;}\n\tif (this.getAttribute(\"toPrecision\")) {this.formulaError = \"Change 'toPrecision' to 'precision'.\"; return;}\n\n\t// Compile the formula, if it has changed, yielding compiledFormula\n\tif(this.formula !== oldFormula) {\n\t\t// Clear the error flag\n\t\tthis.formulaError = null;\n\t\tthis.compiledFormula = null;\n\t\tif (this.formula) {\n\t\t\ttry {\n\t\t\t\tthis.compiledFormula = Compile.compileFormula(this.formula);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis.formulaError = String(err);\n\t\t\t\tthis.formula = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compute the formula, yielding currentValue\n\tif(this.compiledFormula) {\n\t\ttry {\n\t\t\tthis.currentValue = Compute.computeFormula(this.compiledFormula, this, this.formatOptions, Boolean(this.debug));\n\t\t}\n\t\tcatch (err) {\n\t\t\tthis.formulaError = String(err);\n\t\t}\n\t}\n\telse {\n\t\tthis.formulaError = \"Error: formula not assigned\";\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nFormulaWidget.prototype.refresh = function(changedTiddlers) {\n\t// Re-execute the filter to get the count\n\tthis.computeAttributes();\n\tvar oldValue = this.currentValue, oldError = this.formulaError;\n\tthis.execute();\n\tif(this.oldError !== this.formulaError || this.currentValue !== oldValue) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\t//   We DON'T call refreshSelf() because it call execute() again\n\t\tvar nextSibling = this.findNextSiblingDomNode();\n\t\tthis.rerender(this.parentDomNode,nextSibling);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\n};\n\nexports.formula = FormulaWidget;\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/wikiparser/attributes/formula.js": {
            "title": "$:/plugins/ebalster/formula/wikiparser/attributes/formula.js",
            "created": "20171224060415431",
            "description": "Tag attribute rule for formulas.  Ex. `(= 2+2 =)`",
            "modified": "20171225042523039",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\nexports.formula = function(source, pos, node) {\n\t// Is it a formula?\n\tvar reFormulaValue = /\\(=(([^=]+|=[^\\)])*)=\\)/g;\n\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reFormulaValue);\n\tif (!value) return null;\n\n\tnode.type = \"formula\";\n\tnode.formula = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();\n"
        },
        "$:/plugins/ebalster/formula/wikiparser/formula.js": {
            "title": "$:/plugins/ebalster/formula/wikiparser/formula.js",
            "created": "20171211033327565",
            "description": "Wiki text inline rule for formulas.  Ex. `((=2+2))`",
            "modified": "20171211181716654",
            "module-type": "wikirule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.name = \"formula\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\t// Regexp to match\n\tthis.matchRegExp = /\\(=/mg;\n\tthis.endMatchRegExp = /=\\)/mg;\n};\n\nexports.parse = function() {\n\t// Move past the match\n\tthis.parser.pos = this.matchRegExp.lastIndex;\n\t// Look for the end marker\n\tthis.endMatchRegExp.lastIndex = this.parser.pos;\n\tvar match = this.endMatchRegExp.exec(this.parser.source),\n\t\ttext;\n\t// Process the text\n\tif(match) {\n\t\ttext = this.parser.source.substring(this.parser.pos,match.index);\n\t\tthis.parser.pos = match.index + match[0].length;\n\t} else {\n\t\ttext = this.parser.source.substr(this.parser.pos);\n\t\tthis.parser.pos = this.parser.sourceLength;\n\t}\n\treturn [{\n\t\ttype: \"formula\",\n\t\tattributes: {\n\t\t\tformula: {type: \"string\", value: text},\n\t\t}\n\t}];\n};\n\n})();\n"
        }
    }
}