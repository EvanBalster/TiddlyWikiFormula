core-version: >=5.1.20
created: NaNNaNNaNNaNNaNNaNNaN
dependents: 
modified: NaNNaNNaNNaNNaNNaNNaN
plugin-type: plugin
revision: 0
tags: 
title: $:/plugins/ebalster/attribute-modules
type: application/json
version: 0.0.6

{
    "tiddlers": {
        "$:/core/modules/parsers/wikiparser/attributes/filtered.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/filtered.js",
            "created": "20171224215126050",
            "description": "Tag attribute rule for filtered values, eg. {{{[all[shadows]]}}}.",
            "modified": "20171224215155435",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/filtered.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for filtered values, eg. {{{[all[shadows]]}}}.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.filtered = function(source,pos,node) {\n\t// Is it a filtered value?\n\tvar reFilteredValue = /\\{\\{\\{(.+?)\\}\\}\\}/g;\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);\n\tif (!value) return null;\n\tnode.type = \"filtered\";\n\tnode.filter = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/parsers/wikiparser/attributes/indirect.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/indirect.js",
            "created": "20171224214929513",
            "description": "Tag attribute rule for transcluded values, eg. {{Layout!!height}}.",
            "modified": "20171224215110965",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/indirect.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for transcluded values, eg. {{Layout!!height}}.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.indirect = function(source,pos,node) {\n\t// Is it an indirect (transcluded) value?\n\tvar reIndirectValue = /\\{\\{([^\\{\\}]+)\\}\\}/g;\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);\n\tif (!value) return null;\n\tnode.type = \"indirect\";\n\tnode.textReference = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/parsers/wikiparser/attributes/macro.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/macro.js",
            "created": "20171224215158051",
            "description": "Tag attribute rule for macros and variables, eg. <<currentTiddler>>.",
            "modified": "20171224215427368",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/macro.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for macros and variables, eg. <<currentTiddler>>.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.macro = function(source,pos,node) {\n\t// Is it a macro invocation?\n\tvar macroInvocation = $tw.utils.parseMacroInvocation(source,pos);\n\tif (!macroInvocation) return null;\n\tnode.type = \"macro\";\n\tnode.value = macroInvocation;\n\tnode.end = macroInvocation.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/widgets/attributes/filtered.js": {
            "title": "$:/core/modules/widgets/attributes/filtered.js",
            "created": "20171225042329213",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042338300",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/filtered.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via filter expression.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar FilteredAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.filter = node.filter;\n\tthis.compiledFilter = this.widget.wiki.compileFilter(this.filter);\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nFilteredAttribute.prototype.compute = function() {\n\tthis.results = this.compiledFilter.call(this.widget.wiki,undefined,this.widget);\n\t// TODO why only one result?  Can we return a list??\n\treturn this.results[0] || \"\";\n};\n\nFilteredAttribute.prototype.refresh = function(changedTiddlers) {\n\t// TODO can filters be selectively refreshed in the future?\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.filtered = FilteredAttribute;\n\n})();\n\t"
        },
        "$:/core/modules/widgets/attributes/indirect.js": {
            "title": "$:/core/modules/widgets/attributes/indirect.js",
            "created": "20171225042213912",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042325491",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/indirect.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via filter expression.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar IndirectAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.textReference = $tw.utils.parseTextReference(node.textReference);\n\tif (!this.textReference.title) this.currentTiddler = this.widget.getVariable(\"currentTiddler\");\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nIndirectAttribute.prototype.compute = function() {\n\tvar tr = this.textReference,\n\t\ttitle = tr.title || this.currentTiddler,\n\t\twiki = this.widget.wiki;\n\tif(tr.field) {\n\t\tvar tiddler = wiki.getTiddler(title);\n\t\tif(tr.field === \"title\") { // Special case so we can return the title of a non-existent tiddler\n\t\t\treturn title;\n\t\t} else if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {\n\t\t\treturn tiddler.getFieldString(tr.field);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t} else if(tr.index) {\n\t\treturn wiki.extractTiddlerDataItem(title,tr.index,\"\");\n\t} else {\n\t\treturn wiki.getTiddlerText(title,\"\");\n\t}\n};\n\nIndirectAttribute.prototype.refresh = function(changedTiddlers) {\n\tif (this.textReference.title) {\n\t\t// Recompute if the title tiddler changed.\n\t\tif (changedTiddlers[this.textReference.title])\n\t\t\tthis.value = this.compute();\n\t}\n\telse {\n\t\t// Did currentTiddler change?\n\t\tvar newTiddler = this.widget.getVariable(\"currentTiddler\");\n\t\tif (newTiddler != this.currentTiddler) {\n\t\t\tthis.currentTiddler = newTiddler;\n\t\t\tthis.value = this.compute();\n\t\t}\n\t\telse if (changedTiddlers[this.currentTiddler]) {\n\t\t\t// Recompute if the tiddler changed.\n\t\t\tthis.value = this.compute();\n\t\t}\n\t}\n\t// Return the latest value.\n\treturn this.value;\n};\n\n\nexports.indirect = IndirectAttribute;\n\n})();\n\t"
        },
        "$:/core/modules/widgets/attributes/macro.js": {
            "title": "$:/core/modules/widgets/attributes/macro.js",
            "created": "20171225042340029",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042346461",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/macro.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via macro expansion.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar MacroAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.macro = node.value;\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nMacroAttribute.prototype.compute = function() {\n\tvar value = this.widget.getVariable(this.macro.name,{params: this.macro.params});\n\tif (value == null) value = \"\";\n\treturn value;\n};\n\nMacroAttribute.prototype.refresh = function(changedTiddlers) {\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.macro = MacroAttribute;\n\n})();\n\t"
        },
        "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js",
            "created": "20190629011900694",
            "modified": "20190630025250261",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\r\ntitle: $:/core/modules/utils/parseutils.js\r\ntype: application/javascript\r\nmodule-type: utils\n\nUtility functions concerned with parsing text into tokens.\n\nMost functions have the following pattern:\n\n* The parameters are:\r\n** `source`: the source string being parsed\r\n** `pos`: the current parse position within the string\r\n** Any further parameters are used to identify the token that is being parsed\r\n* The return value is:\r\n** null if the token was not found at the specified position\r\n** an object representing the token with the following standard fields:\r\n*** `type`: string indicating the type of the token\r\n*** `start`: start position of the token in the source string\r\n*** `end`: end position of the token in the source string\r\n*** Any further fields required to describe the token\n\nThe exception is `skipWhiteSpace`, which just returns the position after the whitespace.\n\n\\*/\r\n(function(){\n\n\t/*jslint node: true, browser: true */\r\n\t/*global $tw: false */\r\n\t\"use strict\";\r\n\t\r\n\t/*\r\n\tLook for a whitespace token. Returns null if not found, otherwise returns {type: \"whitespace\", start:, end:,}\r\n\t*/\r\n\texports.parseWhiteSpace = function(source,pos) {\r\n\t\tvar p = pos,c;\r\n\t\twhile(true) {\r\n\t\t\tc = source.charAt(p);\r\n\t\t\tif((c === \" \") || (c === \"\\f\") || (c === \"\\n\") || (c === \"\\r\") || (c === \"\\t\") || (c === \"\\v\") || (c === \"\\u00a0\")) { // Ignores some obscure unicode spaces\r\n\t\t\t\tp++;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(p === pos) {\r\n\t\t\treturn null;\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"whitespace\",\r\n\t\t\t\tstart: pos,\r\n\t\t\t\tend: p\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tConvenience wrapper for parseWhiteSpace. Returns the position after the whitespace\r\n\t*/\r\n\texports.skipWhiteSpace = function(source,pos) {\r\n\t\tvar c;\r\n\t\twhile(true) {\r\n\t\t\tc = source.charAt(pos);\r\n\t\t\tif((c === \" \") || (c === \"\\f\") || (c === \"\\n\") || (c === \"\\r\") || (c === \"\\t\") || (c === \"\\v\") || (c === \"\\u00a0\")) { // Ignores some obscure unicode spaces\r\n\t\t\t\tpos++;\r\n\t\t\t} else {\r\n\t\t\t\treturn pos;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for a given string token. Returns null if not found, otherwise returns {type: \"token\", value:, start:, end:,}\r\n\t*/\r\n\texports.parseTokenString = function(source,pos,token) {\r\n\t\tvar match = source.indexOf(token,pos) === pos;\r\n\t\tif(match) {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"token\",\r\n\t\t\t\tvalue: token,\r\n\t\t\t\tstart: pos,\r\n\t\t\t\tend: pos + token.length\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for a token matching a regex. Returns null if not found, otherwise returns {type: \"regexp\", match:, start:, end:,}\r\n\t*/\r\n\texports.parseTokenRegExp = function(source,pos,reToken) {\r\n\t\tvar node = {\r\n\t\t\ttype: \"regexp\",\r\n\t\t\tstart: pos\r\n\t\t};\r\n\t\treToken.lastIndex = pos;\r\n\t\tnode.match = reToken.exec(source);\r\n\t\tif(node.match && node.match.index === pos) {\r\n\t\t\tnode.end = pos + node.match[0].length;\r\n\t\t\treturn node;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for a string literal. Returns null if not found, otherwise returns {type: \"string\", value:, start:, end:,}\r\n\t*/\r\n\texports.parseStringLiteral = function(source,pos) {\r\n\t\tvar node = {\r\n\t\t\ttype: \"string\",\r\n\t\t\tstart: pos\r\n\t\t};\r\n\t\tvar reString = /(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\")|(?:'([^']*)')/g;\r\n\t\treString.lastIndex = pos;\r\n\t\tvar match = reString.exec(source);\r\n\t\tif(match && match.index === pos) {\r\n\t\t\tnode.value = match[1] !== undefined ? match[1] :(\r\n\t\t\t\tmatch[2] !== undefined ? match[2] : match[3] \r\n\t\t\t\t\t\t);\r\n\t\t\tnode.end = pos + match[0].length;\r\n\t\t\treturn node;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for a macro invocation parameter. Returns null if not found, or {type: \"macro-parameter\", name:, value:, start:, end:}\r\n\t*/\r\n\texports.parseMacroParameter = function(source,pos) {\r\n\t\tvar node = {\r\n\t\t\ttype: \"macro-parameter\",\r\n\t\t\tstart: pos\r\n\t\t};\r\n\t\t// Define our regexp\r\n\t\tvar reMacroParameter = /(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\\s>\"'=]+)))/g;\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Look for the parameter\r\n\t\tvar token = $tw.utils.parseTokenRegExp(source,pos,reMacroParameter);\r\n\t\tif(!token) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tpos = token.end;\r\n\t\t// Get the parameter details\r\n\t\tnode.value = token.match[2] !== undefined ? token.match[2] : (\r\n\t\t\t\t\t\ttoken.match[3] !== undefined ? token.match[3] : (\r\n\t\t\t\t\t\t\ttoken.match[4] !== undefined ? token.match[4] : (\r\n\t\t\t\t\t\t\t\ttoken.match[5] !== undefined ? token.match[5] : (\r\n\t\t\t\t\t\t\t\t\ttoken.match[6] !== undefined ? token.match[6] : (\r\n\t\t\t\t\t\t\t\t\t\t\"\"\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\tif(token.match[1]) {\r\n\t\t\tnode.name = token.match[1];\r\n\t\t}\r\n\t\t// Update the end position\r\n\t\tnode.end = pos;\r\n\t\treturn node;\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for a macro invocation. Returns null if not found, or {type: \"macrocall\", name:, parameters:, start:, end:}\r\n\t*/\r\n\texports.parseMacroInvocation = function(source,pos) {\r\n\t\tvar node = {\r\n\t\t\ttype: \"macrocall\",\r\n\t\t\tstart: pos,\r\n\t\t\tparams: []\r\n\t\t};\r\n\t\t// Define our regexps\r\n\t\tvar reMacroName = /([^\\s>\"'=]+)/g;\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Look for a double less than sign\r\n\t\tvar token = $tw.utils.parseTokenString(source,pos,\"<<\");\r\n\t\tif(!token) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tpos = token.end;\r\n\t\t// Get the macro name\r\n\t\tvar name = $tw.utils.parseTokenRegExp(source,pos,reMacroName);\r\n\t\tif(!name) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tnode.name = name.match[1];\r\n\t\tpos = name.end;\r\n\t\t// Process parameters\r\n\t\tvar parameter = $tw.utils.parseMacroParameter(source,pos);\r\n\t\twhile(parameter) {\r\n\t\t\tnode.params.push(parameter);\r\n\t\t\tpos = parameter.end;\r\n\t\t\t// Get the next parameter\r\n\t\t\tparameter = $tw.utils.parseMacroParameter(source,pos);\r\n\t\t}\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Look for a double greater than sign\r\n\t\ttoken = $tw.utils.parseTokenString(source,pos,\">>\");\r\n\t\tif(!token) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tpos = token.end;\r\n\t\t// Update the end position\r\n\t\tnode.end = pos;\r\n\t\treturn node;\r\n\t};\r\n\t\r\n\t/*\r\n\tLook for an HTML attribute definition. Returns null if not found, otherwise returns {type: \"attribute\", name:, valueType: \"string|indirect|macro\", value:, start:, end:,}\r\n\t*/\r\n\tvar AttributeRules = null;\r\n\t\r\n\texports.parseAttribute = function(source,pos) {\r\n\t\tvar node = {\r\n\t\t\tstart: pos\r\n\t\t};\r\n\t\t// Define our regexps\r\n\t\tvar reAttributeName = /([^\\/\\s>\"'=]+)/g,\r\n\t\t\treUnquotedAttribute = /([^\\/\\s<>\"'=]+)/g,\r\n\t\t\treFilteredValue = /\\{\\{\\{(.+?)\\}\\}\\}/g,\r\n\t\t\treIndirectValue = /\\{\\{([^\\}]+)\\}\\}/g;\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Get the attribute name\r\n\t\tvar name = $tw.utils.parseTokenRegExp(source,pos,reAttributeName);\r\n\t\tif(!name) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tnode.name = name.match[1];\r\n\t\tpos = name.end;\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Look for an equals sign\r\n\t\tvar token = $tw.utils.parseTokenString(source,pos,\"=\");\r\n\t\tif(token) {\r\n\t\t\tpos = token.end;\r\n\t\t\t// Skip whitespace\r\n\t\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t\t// Look for a string literal\r\n\t\t\tvar stringLiteral = $tw.utils.parseStringLiteral(source,pos);\r\n\t\t\tif(stringLiteral) {\r\n\t\t\t\t\t\t\t   \r\n\t\t\t\tnode.type = \"string\";\r\n\t\t\t\tnode.value = stringLiteral.value;\r\n\t\t\t\tnode.end = stringLiteral.end;\r\n\t\t\t\t\t\t\t\t   \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t\t// Load attribute rules if needed\r\n\t\t\tif (!AttributeRules) {\r\n\t\t\t\tAttributeRules = {};\r\n\t\t\t\t$tw.modules.applyMethods(\"attributerule\",AttributeRules);\r\n\t\t\t}\r\n\t\t\t// Look for an attribute rule\r\n\t\t\tvar match = null;\r\n\t\t\t$tw.utils.each(AttributeRules,function(rule) {\r\n\t\t\t\tmatch = rule(source,pos,node);\r\n\t\t\t\treturn !match;\r\n\t\t\t});\r\n\t\t\tif (match) return match;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\t\t\r\n\t\t\t// Look for a unquoted value\r\n\t\t\tvar unquotedValue = $tw.utils.parseTokenRegExp(source,pos,reUnquotedAttribute);\r\n\t\t\tif(unquotedValue) {\r\n\t\t\t\t\t\t\t\t  \r\n\t\t\t\tnode.type = \"string\";\r\n\t\t\t\tnode.value = unquotedValue.match[1];\r\n\t\t\t\tnode.end = unquotedValue.end;\r\n\t\t\t\t\t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t   \r\n\t\t\t\t\t\t\t\t\t \r\n\t\t\t\treturn node;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\tnode.type = \"string\";\r\n\t\t\t\tnode.value = \"true\";\r\n\t\t\t}\r\n\t\t  \r\n\t\t \r\n\t\t\r\n\t   \r\n\t\t} else {\r\n\t\t\tnode.type = \"string\";\r\n\t\t\tnode.value = \"true\";\r\n\t\t}\r\n\t\t// Update the end position\r\n\t\tnode.end = pos;\r\n\t\treturn node;\r\n\t};\r\n\t\r\n\t})();\r\n\t"
        },
        "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js",
            "created": "20190629011900694",
            "modified": "20190630025250261",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\r\ntitle: $:/core/modules/widgets/widget.js\r\ntype: application/javascript\r\nmodule-type: widget\n\nWidget base class\n\n\\*/\r\n(function(){\n\n\t/*jslint node: true, browser: true */\r\n\t/*global $tw: false */\r\n\t\"use strict\";\r\n\t\r\n\t/*\r\n\tCreate a widget object for a parse tree node\r\n\t\tparseTreeNode: reference to the parse tree node to be rendered\r\n\t\toptions: see below\r\n\tOptions include:\r\n\t\twiki: mandatory reference to wiki associated with this render tree\r\n\t\tparentWidget: optional reference to a parent renderer node for the context chain\r\n\t\tdocument: optional document object to use instead of global document\r\n\t*/\r\n\tvar Widget = function(parseTreeNode,options) {\r\n\t\t\tthis.initialise(parseTreeNode,options);\r\n\t};\r\n\t\r\n\t/*\r\n\tInitialise widget properties. These steps are pulled out of the constructor so that we can reuse them in subclasses\r\n\t*/\r\n\tWidget.prototype.initialise = function(parseTreeNode,options) {\r\n\t\t// Bail if parseTreeNode is undefined, meaning  that the widget constructor was called without any arguments so that it can be subclassed\r\n\t\tif(parseTreeNode === undefined) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\toptions = options || {};\r\n\t\t// Save widget info\r\n\t\tthis.parseTreeNode = parseTreeNode;\r\n\t\tthis.wiki = options.wiki;\r\n\t\tthis.parentWidget = options.parentWidget;\r\n\t\tthis.variablesConstructor = function() {};\r\n\t\tthis.variablesConstructor.prototype = this.parentWidget ? this.parentWidget.variables : {};\r\n\t\tthis.variables = new this.variablesConstructor();\r\n\t\tthis.document = options.document;\r\n\t\tthis.attributes = {};\r\n\t\tthis.children = [];\r\n\t\tthis.domNodes = [];\r\n\t\tthis.eventListeners = {};\r\n\t\t// Hashmap of the widget classes\r\n\t\tif(!this.widgetClasses) {\r\n\t\t\t// Get widget classes\r\n\t\t\tWidget.prototype.widgetClasses = $tw.modules.applyMethods(\"widget\");\r\n\t\t\t// Process any subclasses\r\n\t\t\t$tw.modules.forEachModuleOfType(\"widget-subclass\",function(title,module) {\r\n\t\t\t\tif(module.baseClass) {\r\n\t\t\t\t\tvar baseClass = Widget.prototype.widgetClasses[module.baseClass];\r\n\t\t\t\t\tif(!baseClass) {\r\n\t\t\t\t\t\tthrow \"Module '\" + title + \"' is attemping to extend a non-existent base class '\" + module.baseClass + \"'\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar subClass = module.constructor;\r\n\t\t\t\t\tsubClass.prototype = new baseClass();\r\n\t\t\t\t\t$tw.utils.extend(subClass.prototype,module.prototype);\r\n\t\t\t\t\tWidget.prototype.widgetClasses[module.name || module.baseClass] = subClass;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t// Hashmap of the attribute classes\r\n\t\tif(!this.attributeClasses) {\r\n\t\t\tWidget.prototype.attributeClasses = $tw.modules.applyMethods(\"attributevalue\");\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tRender this widget into the DOM\r\n\t*/\r\n\tWidget.prototype.render = function(parent,nextSibling) {\r\n\t\tthis.parentDomNode = parent;\r\n\t\tthis.execute();\r\n\t\tthis.renderChildren(parent,nextSibling);\r\n\t};\r\n\t\r\n\t/*\r\n\tCompute the internal state of the widget\r\n\t*/\r\n\tWidget.prototype.execute = function() {\r\n\t\tthis.makeChildWidgets();\r\n\t};\r\n\t\r\n\t/*\r\n\tSet the value of a context variable\r\n\tname: name of the variable\r\n\tvalue: value of the variable\r\n\tparams: array of {name:, default:} for each parameter\r\n\tisMacroDefinition: true if the variable is set via a \\define macro pragma (and hence should have variable substitution performed)\r\n\t*/\r\n\tWidget.prototype.setVariable = function(name,value,params,isMacroDefinition) {\r\n\t\tthis.variables[name] = {value: value, params: params, isMacroDefinition: !!isMacroDefinition};\r\n\t};\r\n\t\r\n\t/*\r\n\tGet the prevailing value of a context variable\r\n\tname: name of variable\r\n\toptions: see below\r\n\tOptions include\r\n\tparams: array of {name:, value:} for each parameter\r\n\tdefaultValue: default value if the variable is not defined\r\n\t\r\n\tReturns an object with the following fields:\r\n\t\r\n\tparams: array of {name:,value:} of parameters passed to wikitext variables\r\n\ttext: text of variable, with parameters properly substituted\r\n\t*/\r\n\tWidget.prototype.getVariableInfo = function(name,options) {\r\n\t\toptions = options || {};\r\n\t\tvar actualParams = options.params || [],\r\n\t\t\tparentWidget = this.parentWidget;\r\n\t\t// Check for the variable defined in the parent widget (or an ancestor in the prototype chain)\r\n\t\tif(parentWidget && name in parentWidget.variables) {\r\n\t\t\tvar variable = parentWidget.variables[name],\r\n\t\t\t\tvalue = variable.value,\r\n\t\t\t\tparams = this.resolveVariableParameters(variable.params,actualParams);\r\n\t\t\t// Substitute any parameters specified in the definition\r\n\t\t\t$tw.utils.each(params,function(param) {\r\n\t\t\t\tvalue = $tw.utils.replaceString(value,new RegExp(\"\\\\$\" + $tw.utils.escapeRegExp(param.name) + \"\\\\$\",\"mg\"),param.value);\r\n\t\t\t});\r\n\t\t\t// Only substitute variable references if this variable was defined with the \\define pragma\r\n\t\t\tif(variable.isMacroDefinition) {\r\n\t\t\t\tvalue = this.substituteVariableReferences(value);\t\t\t\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\ttext: value,\r\n\t\t\t\tparams: params\r\n\t\t\t};\r\n\t\t}\r\n\t\t// If the variable doesn't exist in the parent widget then look for a macro module\r\n\t\treturn {\r\n\t\t\ttext: this.evaluateMacroModule(name,actualParams,options.defaultValue)\r\n\t\t};\r\n\t};\r\n\t\r\n\t/*\r\n\tSimplified version of getVariableInfo() that just returns the text\r\n\t*/\r\n\tWidget.prototype.getVariable = function(name,options) {\r\n\t\treturn this.getVariableInfo(name,options).text;\r\n\t};\r\n\t\r\n\tWidget.prototype.resolveVariableParameters = function(formalParams,actualParams) {\r\n\t\tformalParams = formalParams || [];\r\n\t\tactualParams = actualParams || [];\r\n\t\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\r\n\t\t\tparamInfo, paramValue,\r\n\t\t\tresults = [];\r\n\t\t// Step through each of the parameters in the macro definition\r\n\t\tfor(var p=0; p<formalParams.length; p++) {\r\n\t\t\t// Check if we've got a macro call parameter with the same name\r\n\t\t\tparamInfo = formalParams[p];\r\n\t\t\tparamValue = undefined;\r\n\t\t\tfor(var m=0; m<actualParams.length; m++) {\r\n\t\t\t\tif(actualParams[m].name === paramInfo.name) {\r\n\t\t\t\t\tparamValue = actualParams[m].value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If not, use the next available anonymous macro call parameter\r\n\t\t\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\r\n\t\t\t\tnextAnonParameter++;\r\n\t\t\t}\r\n\t\t\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\r\n\t\t\t\tparamValue = actualParams[nextAnonParameter++].value;\r\n\t\t\t}\r\n\t\t\t// If we've still not got a value, use the default, if any\r\n\t\t\tparamValue = paramValue || paramInfo[\"default\"] || \"\";\r\n\t\t\t// Store the parameter name and value\r\n\t\t\tresults.push({name: paramInfo.name, value: paramValue});\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tWidget.prototype.substituteVariableReferences = function(text) {\r\n\t\tvar self = this;\r\n\t\treturn (text || \"\").replace(/\\$\\(([^\\)\\$]+)\\)\\$/g,function(match,p1,offset,string) {\r\n\t\t\treturn self.getVariable(p1,{defaultValue: \"\"});\r\n\t\t});\r\n\t};\r\n\t\r\n\tWidget.prototype.evaluateMacroModule = function(name,actualParams,defaultValue) {\r\n\t\tif($tw.utils.hop($tw.macros,name)) {\r\n\t\t\tvar macro = $tw.macros[name],\r\n\t\t\t\targs = [];\r\n\t\t\tif(macro.params.length > 0) {\r\n\t\t\t\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\r\n\t\t\t\t\tparamInfo, paramValue;\r\n\t\t\t\t// Step through each of the parameters in the macro definition\r\n\t\t\t\tfor(var p=0; p<macro.params.length; p++) {\r\n\t\t\t\t\t// Check if we've got a macro call parameter with the same name\r\n\t\t\t\t\tparamInfo = macro.params[p];\r\n\t\t\t\t\tparamValue = undefined;\r\n\t\t\t\t\tfor(var m=0; m<actualParams.length; m++) {\r\n\t\t\t\t\t\tif(actualParams[m].name === paramInfo.name) {\r\n\t\t\t\t\t\t\tparamValue = actualParams[m].value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// If not, use the next available anonymous macro call parameter\r\n\t\t\t\t\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\r\n\t\t\t\t\t\tnextAnonParameter++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\r\n\t\t\t\t\t\tparamValue = actualParams[nextAnonParameter++].value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// If we've still not got a value, use the default, if any\r\n\t\t\t\t\tparamValue = paramValue || paramInfo[\"default\"] || \"\";\r\n\t\t\t\t\t// Save the parameter\r\n\t\t\t\t\targs.push(paramValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse for(var i=0; i<actualParams.length; ++i) {\r\n\t\t\t\targs.push(actualParams[i].value);\r\n\t\t\t}\r\n\t\t\treturn (macro.run.apply(this,args) || \"\").toString();\r\n\t\t} else {\r\n\t\t\treturn defaultValue;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tCheck whether a given context variable value exists in the parent chain\r\n\t*/\r\n\tWidget.prototype.hasVariable = function(name,value) {\r\n\t\tvar node = this;\r\n\t\twhile(node) {\r\n\t\t\tif($tw.utils.hop(node.variables,name) && node.variables[name].value === value) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tnode = node.parentWidget;\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\t\r\n\t/*\r\n\tConstruct a qualifying string based on a hash of concatenating the values of a given variable in the parent chain\r\n\t*/\r\n\tWidget.prototype.getStateQualifier = function(name) {\r\n\t\tthis.qualifiers = this.qualifiers || Object.create(null);\r\n\t\tname = name || \"transclusion\";\r\n\t\tif(this.qualifiers[name]) {\r\n\t\t\treturn this.qualifiers[name];\r\n\t\t} else {\r\n\t\t\tvar output = [],\r\n\t\t\t\tnode = this;\r\n\t\t\twhile(node && node.parentWidget) {\r\n\t\t\t\tif($tw.utils.hop(node.parentWidget.variables,name)) {\r\n\t\t\t\t\toutput.push(node.getVariable(name));\r\n\t\t\t\t}\r\n\t\t\t\tnode = node.parentWidget;\r\n\t\t\t}\r\n\t\t\tvar value = $tw.utils.hashString(output.join(\"\"));\r\n\t\t\tthis.qualifiers[name] = value;\r\n\t\t\treturn value;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tCompute the current values of the attributes of the widget. Returns a hashmap of the names of the attributes that have changed\r\n\t*/\r\n\tWidget.prototype.computeAttributes = function() {\r\n\t\tvar changedAttributes = {},\r\n\t\t\tself = this,\r\n\t\t\tvalue;\r\n\t\tif (!this.attributeGizmos) {\r\n\t\t\t// First-time attribute preparation\r\n\t\t\tthis.attributeGizmos = {};\r\n\t\t\t$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {\r\n\t\t\t\t// Does the attribute type have a known module?\r\n\t\t\t\tvar AttributeClass = self.attributeClasses[attribute.type];\r\n\t\t\t\tif (AttributeClass) {\r\n\t\t\t\t\t// Instantiate an attribute object.\r\n\t\t\t\t\tself.attributeGizmos[name] = new AttributeClass(self,attribute);\r\n\t\t\t\t\tvalue = self.attributeGizmos[name].value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Unknown attribute types are treated as strings.\r\n\t\t\t\t\t// String attributes don't change after the first computeAttributes().\r\n\t\t\t\t\tvalue = attribute.value;\r\n\t\t\t\t}\r\n\t\t\t\t// Is the value changed?\r\n\t\t\t\tif (self.attributes[name] !== value) {\r\n\t\t\t\t\tself.attributes[name] = value;\r\n\t\t\t\t\tchangedAttributes[name] = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}else {\r\n\t\t\t// Fully recompute all dynamic attributes (no selectivity is available)\r\n\t\t\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\r\n\t\t\t\tvalue = gizmo.compute();\r\n\t\t\t\tif(self.attributes[name] !== value) {\r\n\t\t\t\t\tself.attributes[name] = value;\r\n\t\t\t\t\tchangedAttributes[name] = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn changedAttributes;\r\n\t};\r\n\t\r\n\t/*\r\n\tSelectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed\r\n\t*/\r\n\tWidget.prototype.refreshAttributes = function(changedTiddlers) {\r\n\t\tif (!this.attributeGizmos) return computeAttributes();\r\n\t\tvar changedAttributes = {},\r\n\t\t\tself = this,\r\n\t\t\tvalue;\r\n\t\t// Fully recompute all dynamic attributes (no selectivity is available)\r\n\t\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\r\n\t\t\tvalue = gizmo.refresh(changedTiddlers);\r\n\t\t\tif(self.attributes[name] !== value) {\r\n\t\t\t\tself.attributes[name] = value;\r\n\t\t\t\tchangedAttributes[name] = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn changedAttributes;\r\n\t};\r\n\t\r\n\t/*\r\n\tCheck for the presence of an attribute\r\n\t*/\r\n\tWidget.prototype.hasAttribute = function(name) {\r\n\t\treturn $tw.utils.hop(this.attributes,name);\r\n\t};\r\n\t\r\n\t/*\r\n\tGet the value of an attribute\r\n\t*/\r\n\tWidget.prototype.getAttribute = function(name,defaultText) {\r\n\t\tif($tw.utils.hop(this.attributes,name)) {\r\n\t\t\treturn this.attributes[name];\r\n\t\t} else {\r\n\t\t\treturn defaultText;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tAssign the computed attributes of the widget to a domNode\r\n\toptions include:\r\n\texcludeEventAttributes: ignores attributes whose name begins with \"on\"\r\n\t*/\r\n\tWidget.prototype.assignAttributes = function(domNode,options) {\r\n\t\toptions = options || {};\r\n\t\tvar self = this;\r\n\t\t$tw.utils.each(this.attributes,function(v,a) {\r\n\t\t\t// Check exclusions\r\n\t\t\tif(options.excludeEventAttributes && a.substr(0,2) === \"on\") {\r\n\t\t\t\tv = undefined;\r\n\t\t\t}\r\n\t\t\tif(v !== undefined) {\r\n\t\t\t\tvar b = a.split(\":\");\r\n\t\t\t\t// Setting certain attributes can cause a DOM error (eg xmlns on the svg element)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (b.length == 2 && b[0] == \"xlink\"){\r\n\t\t\t\t\t\tdomNode.setAttributeNS(\"http://www.w3.org/1999/xlink\",b[1],v);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdomNode.setAttributeNS(null,a,v);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t\r\n\t/*\r\n\tMake child widgets correspondng to specified parseTreeNodes\r\n\t*/\r\n\tWidget.prototype.makeChildWidgets = function(parseTreeNodes) {\r\n\t\tthis.children = [];\r\n\t\tvar self = this;\r\n\t\t$tw.utils.each(parseTreeNodes || (this.parseTreeNode && this.parseTreeNode.children),function(childNode) {\r\n\t\t\tself.children.push(self.makeChildWidget(childNode));\r\n\t\t});\r\n\t};\r\n\t\r\n\t/*\r\n\tConstruct the widget object for a parse tree node\r\n\t*/\r\n\tWidget.prototype.makeChildWidget = function(parseTreeNode) {\r\n\t\tvar WidgetClass = this.widgetClasses[parseTreeNode.type];\r\n\t\tif(!WidgetClass) {\r\n\t\t\tWidgetClass = this.widgetClasses.text;\r\n\t\t\tparseTreeNode = {type: \"text\", text: \"Undefined widget '\" + parseTreeNode.type + \"'\"};\r\n\t\t}\r\n\t\treturn new WidgetClass(parseTreeNode,{\r\n\t\t\twiki: this.wiki,\r\n\t\t\tvariables: {},\r\n\t\t\tparentWidget: this,\r\n\t\t\tdocument: this.document\r\n\t\t});\r\n\t};\r\n\t\r\n\t/*\r\n\tGet the next sibling of this widget\r\n\t*/\r\n\tWidget.prototype.nextSibling = function() {\r\n\t\tif(this.parentWidget) {\r\n\t\t\tvar index = this.parentWidget.children.indexOf(this);\r\n\t\t\tif(index !== -1 && index < this.parentWidget.children.length-1) {\r\n\t\t\t\treturn this.parentWidget.children[index+1];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\t\r\n\t/*\r\n\tGet the previous sibling of this widget\r\n\t*/\r\n\tWidget.prototype.previousSibling = function() {\r\n\t\tif(this.parentWidget) {\r\n\t\t\tvar index = this.parentWidget.children.indexOf(this);\r\n\t\t\tif(index !== -1 && index > 0) {\r\n\t\t\t\treturn this.parentWidget.children[index-1];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\t\r\n\t/*\r\n\tRender the children of this widget into the DOM\r\n\t*/\r\n\tWidget.prototype.renderChildren = function(parent,nextSibling) {\r\n\t\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\t\tchildWidget.render(parent,nextSibling);\r\n\t\t});\r\n\t};\r\n\t\r\n\t/*\r\n\tAdd a list of event listeners from an array [{type:,handler:},...]\r\n\t*/\r\n\tWidget.prototype.addEventListeners = function(listeners) {\r\n\t\tvar self = this;\r\n\t\t$tw.utils.each(listeners,function(listenerInfo) {\r\n\t\t\tself.addEventListener(listenerInfo.type,listenerInfo.handler);\r\n\t\t});\r\n\t};\r\n\t\r\n\t/*\r\n\tAdd an event listener\r\n\t*/\r\n\tWidget.prototype.addEventListener = function(type,handler) {\r\n\t\tvar self = this;\r\n\t\tif(typeof handler === \"string\") { // The handler is a method name on this widget\r\n\t\t\tthis.eventListeners[type] = function(event) {\r\n\t\t\t\treturn self[handler].call(self,event);\r\n\t\t\t};\r\n\t\t} else { // The handler is a function\r\n\t\t\tthis.eventListeners[type] = function(event) {\r\n\t\t\t\treturn handler.call(self,event);\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tDispatch an event to a widget. If the widget doesn't handle the event then it is also dispatched to the parent widget\r\n\t*/\r\n\tWidget.prototype.dispatchEvent = function(event) {\r\n\t\t// Dispatch the event if this widget handles it\r\n\t\tvar listener = this.eventListeners[event.type];\r\n\t\tif(listener) {\r\n\t\t\t// Don't propagate the event if the listener returned false\r\n\t\t\tif(!listener(event)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Dispatch the event to the parent widget\r\n\t\tif(this.parentWidget) {\r\n\t\t\treturn this.parentWidget.dispatchEvent(event);\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\t\r\n\t/*\r\n\tSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\r\n\t*/\r\n\tWidget.prototype.refresh = function(changedTiddlers) {\r\n\t\treturn this.refreshChildren(changedTiddlers);\r\n\t};\r\n\t\r\n\t/*\r\n\tRebuild a previously rendered widget\r\n\t*/\r\n\tWidget.prototype.refreshSelf = function() {\r\n\t\tvar nextSibling = this.findNextSiblingDomNode();\r\n\t\tthis.removeChildDomNodes();\r\n\t\tthis.render(this.parentDomNode,nextSibling);\r\n\t};\r\n\t\r\n\t/*\r\n\tRefresh all the children of a widget\r\n\t*/\r\n\tWidget.prototype.refreshChildren = function(changedTiddlers) {\r\n\t\tvar self = this,\r\n\t\t\trefreshed = false;\r\n\t\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\t\trefreshed = childWidget.refresh(changedTiddlers) || refreshed;\r\n\t\t});\r\n\t\treturn refreshed;\r\n\t};\r\n\t\r\n\t/*\r\n\tFind the next sibling in the DOM to this widget. This is done by scanning the widget tree through all next siblings and their descendents that share the same parent DOM node\r\n\t*/\r\n\tWidget.prototype.findNextSiblingDomNode = function(startIndex) {\r\n\t\t// Refer to this widget by its index within its parents children\r\n\t\tvar parent = this.parentWidget,\r\n\t\t\tindex = startIndex !== undefined ? startIndex : parent.children.indexOf(this);\r\n\tif(index === -1) {\r\n\t\tthrow \"node not found in parents children\";\r\n\t}\r\n\t\t// Look for a DOM node in the later siblings\r\n\t\twhile(++index < parent.children.length) {\r\n\t\t\tvar domNode = parent.children[index].findFirstDomNode();\r\n\t\t\tif(domNode) {\r\n\t\t\t\treturn domNode;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Go back and look for later siblings of our parent if it has the same parent dom node\r\n\t\tvar grandParent = parent.parentWidget;\r\n\t\tif(grandParent && parent.parentDomNode === this.parentDomNode) {\r\n\t\t\tindex = grandParent.children.indexOf(parent);\r\n\t\t\tif(index !== -1) {\r\n\t\t\t\treturn parent.findNextSiblingDomNode(index);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\t\r\n\t/*\r\n\tFind the first DOM node generated by a widget or its children\r\n\t*/\r\n\tWidget.prototype.findFirstDomNode = function() {\r\n\t\t// Return the first dom node of this widget, if we've got one\r\n\t\tif(this.domNodes.length > 0) {\r\n\t\t\treturn this.domNodes[0];\r\n\t\t}\r\n\t\t// Otherwise, recursively call our children\r\n\t\tfor(var t=0; t<this.children.length; t++) {\r\n\t\t\tvar domNode = this.children[t].findFirstDomNode();\r\n\t\t\tif(domNode) {\r\n\t\t\t\treturn domNode;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t};\r\n\t\r\n\t/*\r\n\tRemove any DOM nodes created by this widget or its children\r\n\t*/\r\n\tWidget.prototype.removeChildDomNodes = function() {\r\n\t\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\r\n\t\tif(this.domNodes.length > 0) {\r\n\t\t\t$tw.utils.each(this.domNodes,function(domNode) {\r\n\t\t\t\tdomNode.parentNode.removeChild(domNode);\r\n\t\t\t});\r\n\t\t\tthis.domNodes = [];\r\n\t\t} else {\r\n\t\t\t// Otherwise, ask the child widgets to delete their DOM nodes\r\n\t\t\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\t\t\tchildWidget.removeChildDomNodes();\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\tInvoke the action widgets that are descendents of the current widget.\r\n\t*/\r\n\tWidget.prototype.invokeActions = function(triggeringWidget,event) {\r\n\t\tvar handled = false;\r\n\t\t// For each child widget\r\n\t\tfor(var t=0; t<this.children.length; t++) {\r\n\t\t\tvar child = this.children[t];\r\n\t\t\t// Invoke the child if it is an action widget\r\n\t\t\tif(child.invokeAction) {\r\n\t\t\t\tchild.refreshSelf();\r\n\t\t\t\tif(child.invokeAction(triggeringWidget,event)) {\r\n\t\t\t\t\thandled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Propagate through through the child if it permits it\r\n\t\t\tif(child.allowActionPropagation() && child.invokeActions(triggeringWidget,event)) {\r\n\t\t\t\thandled = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn handled;\r\n\t};\r\n\t\r\n\t/*\r\n\tInvoke the action widgets defined in a string\r\n\t*/\r\n\tWidget.prototype.invokeActionString = function(actions,triggeringWidget,event,variables) {\r\n\t\tactions = actions || \"\";\r\n\t\tvar parser = this.wiki.parseText(\"text/vnd.tiddlywiki\",actions,{\r\n\t\t\t\tparentWidget: this,\r\n\t\t\t\tdocument: this.document\r\n\t\t\t}),\r\n\t\t\twidgetNode = this.wiki.makeWidget(parser,{\r\n\t\t\t\tparentWidget: this,\r\n\t\t\t\tdocument: this.document,\r\n\t\t\t\tvariables: variables\r\n\t\t\t});\r\n\t\tvar container = this.document.createElement(\"div\");\r\n\t\twidgetNode.render(container,null);\r\n\t\treturn widgetNode.invokeActions(this,event);\r\n\t};\r\n\t\r\n\tWidget.prototype.allowActionPropagation = function() {\r\n\t\treturn true;\r\n\t};\r\n\t\r\n\texports.widget = Widget;\r\n\t\r\n\t})();\r\n\t"
        },
        "$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js",
            "created": "20190810062647651",
            "modified": "20190810062647651",
            "modloader-source": "$:/core",
            "modloader-target": "$:/core/modules/utils/parseutils.js",
            "tags": "",
            "type": "text/x-patch",
            "text": "@@ -79,33 +79,35 @@\n dule-type: utils\n-%0A\n+%0D%0A%0D\n %0AUtility functio\n@@ -141,33 +141,35 @@\n ext into tokens.\n-%0A\n+%0D%0A%0D\n %0AMost functions \n@@ -187,33 +187,35 @@\n llowing pattern:\n-%0A\n+%0D%0A%0D\n %0A* The parameter\n@@ -771,33 +771,35 @@\n scribe the token\n-%0A\n+%0D%0A%0D\n %0AThe exception i\n@@ -863,33 +863,35 @@\n  the whitespace.\n-%0A\n+%0D%0A%0D\n %0A%5C*/%0A(function()\n@@ -883,34 +883,37 @@\n %5C*/%0A(function()%7B\n-%0A%0A\n+%0D%0A%0D%0A%09\n /*jslint node: t\n@@ -926,32 +926,33 @@\n rowser: true */%0A\n+%09\n /*global $tw: fa\n@@ -958,34 +958,38 @@\n alse */%0A\n+%09\n %22use strict%22;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -1082,35 +1082,37 @@\n  start:, end:,%7D%0A\n+%09\n */%0A\n+%09\n exports.parseWhi\n@@ -1144,32 +1144,34 @@\n ,pos) %7B%0A\n+%09\n %09var p = pos,c;%0A\n+%09\n %09while(t\n@@ -1171,32 +1171,33 @@\n while(true) %7B%0A%09%09\n+%09\n c = source.charA\n@@ -1194,32 +1194,33 @@\n urce.charAt(p);%0A\n+%09\n %09%09if((c === %22 %22)\n@@ -1365,49 +1365,55 @@\n aces%0A%09%09%09\n+%09\n p++;%0A\n+%09\n %09%09%7D else %7B%0A\n+%09\n %09%09%09break;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D%0A\n+%09\n %09if(p ==\n@@ -1423,50 +1423,54 @@\n os) %7B%0A%09%09\n+%09\n return null;%0A\n+%09\n %09%7D else %7B%0A%09%09\n+%09\n return %7B%0A\n+%09\n %09%09%09type:\n@@ -1487,52 +1487,60 @@\n ce%22,%0A%09%09%09\n+%09\n start: pos,%0A%09%09%09\n+%09\n end: p%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Convenie\n@@ -1606,35 +1606,37 @@\n  the whitespace%0A\n+%09\n */%0A\n+%09\n exports.skipWhit\n@@ -1667,24 +1667,26 @@\n ,pos) %7B%0A\n+%09\n %09var c;%0A\n+%09\n %09while(t\n@@ -1686,32 +1686,33 @@\n while(true) %7B%0A%09%09\n+%09\n c = source.charA\n@@ -1711,32 +1711,33 @@\n ce.charAt(pos);%0A\n+%09\n %09%09if((c === %22 %22)\n@@ -1882,34 +1882,37 @@\n aces%0A%09%09%09\n+%09\n pos++;%0A\n+%09\n %09%09%7D else %7B%0A\n+%09\n %09%09%09retur\n@@ -1920,28 +1920,34 @@\n  pos;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -2045,35 +2045,37 @@\n  start:, end:,%7D%0A\n+%09\n */%0A\n+%09\n exports.parseTok\n@@ -2106,32 +2106,33 @@\n ce,pos,token) %7B%0A\n+%09\n %09var match = sou\n@@ -2163,43 +2163,46 @@\n == pos;%0A\n+%09\n %09if(match) %7B%0A\n+%09\n %09%09return %7B%0A%09%09%09\n+%09\n type: %22t\n@@ -2211,30 +2211,32 @@\n en%22,%0A%09%09%09\n+%09\n value: token,%0A\n+%09\n %09%09%09start\n@@ -2237,32 +2237,33 @@\n %09start: pos,%0A%09%09%09\n+%09\n end: pos + token\n@@ -2270,45 +2270,52 @@\n .length%0A\n+%09\n %09%09%7D;%0A\n+%09\n %09%7D%0A\n+%09\n %09return null;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -2418,35 +2418,37 @@\n  start:, end:,%7D%0A\n+%09\n */%0A\n+%09\n exports.parseTok\n@@ -2489,32 +2489,34 @@\n oken) %7B%0A\n+%09\n %09var node = %7B%0A%09%09\n+%09\n type: %22r\n@@ -2517,47 +2517,50 @@\n pe: %22regexp%22,%0A%09%09\n+%09\n start: pos%0A\n+%09\n %09%7D;%0A\n+%09\n %09reToken.lastInd\n@@ -2561,32 +2561,33 @@\n astIndex = pos;%0A\n+%09\n %09node.match = re\n@@ -2598,32 +2598,33 @@\n n.exec(source);%0A\n+%09\n %09if(node.match &\n@@ -2647,32 +2647,33 @@\n ex === pos) %7B%0A%09%09\n+%09\n node.end = pos +\n@@ -2695,66 +2695,74 @@\n length;%0A\n+%09\n %09%09return node;%0A\n+%09\n %09%7D else %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -2857,35 +2857,37 @@\n  start:, end:,%7D%0A\n+%09\n */%0A\n+%09\n exports.parseStr\n@@ -2914,46 +2914,48 @@\n n(source,pos) %7B%0A\n+%09\n %09var node = %7B%0A\n+%09\n %09%09type: %22string%22\n@@ -2950,47 +2950,50 @@\n pe: %22string%22,%0A%09%09\n+%09\n start: pos%0A\n+%09\n %09%7D;%0A\n+%09\n %09var reString = \n@@ -3033,32 +3033,33 @@\n ?:'(%5B%5E'%5D*)')/g;%0A\n+%09\n %09reString.lastIn\n@@ -3061,32 +3061,33 @@\n astIndex = pos;%0A\n+%09\n %09var match = reS\n@@ -3098,32 +3098,33 @@\n g.exec(source);%0A\n+%09\n %09if(match && mat\n@@ -3135,32 +3135,33 @@\n ndex === pos) %7B%0A\n+%09\n %09%09node.value = m\n@@ -3188,32 +3188,33 @@\n d ? match%5B1%5D :(%0A\n+%09\n %09%09%09match%5B2%5D !== \n@@ -3243,35 +3243,37 @@\n  match%5B3%5D %0A%09%09%09%09%09\n+%09\n );%0A\n+%09\n %09%09node.end = pos\n@@ -3294,64 +3294,72 @@\n ngth;%0A%09%09\n+%09\n return node;%0A\n+%09\n %09%7D else %7B%0A%09%09\n+%09\n return null;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -3466,35 +3466,37 @@\n , start:, end:%7D%0A\n+%09\n */%0A\n+%09\n exports.parseMac\n@@ -3524,46 +3524,48 @@\n n(source,pos) %7B%0A\n+%09\n %09var node = %7B%0A\n+%09\n %09%09type: %22macro-p\n@@ -3569,47 +3569,50 @@\n o-parameter%22,%0A%09%09\n+%09\n start: pos%0A\n+%09\n %09%7D;%0A\n+%09\n %09// Define our r\n@@ -3609,32 +3609,33 @@\n fine our regexp%0A\n+%09\n %09var reMacroPara\n@@ -3742,32 +3742,33 @@\n %5E%5Cs%3E%22'=%5D+)))/g;%0A\n+%09\n %09// Skip whitesp\n@@ -3763,32 +3763,33 @@\n Skip whitespace%0A\n+%09\n %09pos = $tw.utils\n@@ -3809,32 +3809,33 @@\n ce(source,pos);%0A\n+%09\n %09// Look for the\n@@ -3837,32 +3837,33 @@\n r the parameter%0A\n+%09\n %09var token = $tw\n@@ -3916,48 +3916,52 @@\n meter);%0A\n+%09\n %09if(!token) %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %09pos = t\n@@ -3962,32 +3962,33 @@\n os = token.end;%0A\n+%09\n %09// Get the para\n@@ -3993,32 +3993,33 @@\n rameter details%0A\n+%09\n %09node.value = to\n@@ -4063,32 +4063,33 @@\n tch%5B2%5D : (%0A%09%09%09%09%09\n+%09\n token.match%5B3%5D !\n@@ -4114,32 +4114,33 @@\n en.match%5B3%5D : (%0A\n+%09\n %09%09%09%09%09%09token.matc\n@@ -4178,32 +4178,33 @@\n h%5B4%5D : (%0A%09%09%09%09%09%09%09\n+%09\n token.match%5B5%5D !\n@@ -4229,32 +4229,33 @@\n en.match%5B5%5D : (%0A\n+%09\n %09%09%09%09%09%09%09%09token.ma\n@@ -4288,32 +4288,33 @@\n en.match%5B6%5D : (%0A\n+%09\n %09%09%09%09%09%09%09%09%09%22%22%0A%09%09%09%09\n@@ -4317,49 +4317,55 @@\n %09%09%09%09%09%09%09%09\n+%09\n )%0A\n+%09\n %09%09%09%09%09%09%09)%0A%09%09%09%09%09%09\n+%09\n )%0A\n+%09\n %09%09%09%09%09)%0A%09%09%09%09\n+%09\n );%0A\n+%09\n %09if(toke\n@@ -4372,32 +4372,33 @@\n n.match%5B1%5D) %7B%0A%09%09\n+%09\n node.name = toke\n@@ -4401,35 +4401,37 @@\n token.match%5B1%5D;%0A\n+%09\n %09%7D%0A\n+%09\n %09// Update the e\n@@ -4434,32 +4434,33 @@\n he end position%0A\n+%09\n %09node.end = pos;\n@@ -4460,37 +4460,42 @@\n  = pos;%0A\n+%09\n %09return node;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -4591,35 +4591,37 @@\n , start:, end:%7D%0A\n+%09\n */%0A\n+%09\n exports.parseMac\n@@ -4650,46 +4650,48 @@\n n(source,pos) %7B%0A\n+%09\n %09var node = %7B%0A\n+%09\n %09%09type: %22macroca\n@@ -4695,47 +4695,51 @@\n ocall%22,%0A\n+%09\n %09%09start: pos,%0A%09%09\n+%09\n params: %5B%5D%0A\n+%09\n %09%7D;%0A\n+%09\n %09// Defi\n@@ -4745,32 +4745,33 @@\n ine our regexps%0A\n+%09\n %09var reMacroName\n@@ -4782,32 +4782,33 @@\n (%5B%5E%5Cs%3E%22'=%5D+)/g;%0A\n+%09\n %09// Skip whitesp\n@@ -4803,32 +4803,33 @@\n Skip whitespace%0A\n+%09\n %09pos = $tw.utils\n@@ -4849,32 +4849,33 @@\n ce(source,pos);%0A\n+%09\n %09// Look for a d\n@@ -4887,32 +4887,33 @@\n  less than sign%0A\n+%09\n %09var token = $tw\n@@ -4954,48 +4954,52 @@\n ,%22%3C%3C%22);%0A\n+%09\n %09if(!token) %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %09pos = t\n@@ -5000,32 +5000,33 @@\n os = token.end;%0A\n+%09\n %09// Get the macr\n@@ -5024,32 +5024,33 @@\n  the macro name%0A\n+%09\n %09var name = $tw.\n@@ -5097,47 +5097,51 @@\n oName);%0A\n+%09\n %09if(!name) %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %09node.na\n@@ -5152,32 +5152,33 @@\n  name.match%5B1%5D;%0A\n+%09\n %09pos = name.end;\n@@ -5170,32 +5170,33 @@\n pos = name.end;%0A\n+%09\n %09// Process para\n@@ -5194,32 +5194,33 @@\n cess parameters%0A\n+%09\n %09var parameter =\n@@ -5255,32 +5255,33 @@\n er(source,pos);%0A\n+%09\n %09while(parameter\n@@ -5278,32 +5278,33 @@\n (parameter) %7B%0A%09%09\n+%09\n node.params.push\n@@ -5308,32 +5308,33 @@\n ush(parameter);%0A\n+%09\n %09%09pos = paramete\n@@ -5334,32 +5334,33 @@\n arameter.end;%0A%09%09\n+%09\n // Get the next \n@@ -5361,32 +5361,33 @@\n  next parameter%0A\n+%09\n %09%09parameter = $t\n@@ -5419,35 +5419,37 @@\n er(source,pos);%0A\n+%09\n %09%7D%0A\n+%09\n %09// Skip whitesp\n@@ -5444,32 +5444,33 @@\n Skip whitespace%0A\n+%09\n %09pos = $tw.utils\n@@ -5490,32 +5490,33 @@\n ce(source,pos);%0A\n+%09\n %09// Look for a d\n@@ -5531,32 +5531,33 @@\n eater than sign%0A\n+%09\n %09token = $tw.uti\n@@ -5594,48 +5594,52 @@\n ,%22%3E%3E%22);%0A\n+%09\n %09if(!token) %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %09pos = t\n@@ -5640,32 +5640,33 @@\n os = token.end;%0A\n+%09\n %09// Update the e\n@@ -5669,32 +5669,33 @@\n he end position%0A\n+%09\n %09node.end = pos;\n@@ -5695,37 +5695,42 @@\n  = pos;%0A\n+%09\n %09return node;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Look for\n@@ -5883,35 +5883,67 @@\n  start:, end:,%7D%0A\n+%09\n */%0A\n+%09var AttributeRules = null;%0A%09%0A%09\n exports.parseAtt\n@@ -5974,47 +5974,51 @@\n ,pos) %7B%0A\n+%09\n %09var node = %7B%0A%09%09\n+%09\n start: pos%0A\n+%09\n %09%7D;%0A\n+%09\n %09// Defi\n@@ -6024,32 +6024,33 @@\n ine our regexps%0A\n+%09\n %09var reAttribute\n@@ -6067,32 +6067,33 @@\n %5E%5C/%5Cs%3E%22'=%5D+)/g,%0A\n+%09\n %09%09reUnquotedAttr\n@@ -6114,32 +6114,33 @@\n %5Cs%3C%3E%22'=%5D+)/g,%0A%09%09\n+%09\n reFilteredValue \n@@ -6157,32 +6157,33 @@\n .+?)%5C%7D%5C%7D%5C%7D/g,%0A%09%09\n+%09\n reIndirectValue \n@@ -6197,32 +6197,33 @@\n (%5B%5E%5C%7D%5D+)%5C%7D%5C%7D/g;%0A\n+%09\n %09// Skip whitesp\n@@ -6218,32 +6218,33 @@\n Skip whitespace%0A\n+%09\n %09pos = $tw.utils\n@@ -6264,32 +6264,33 @@\n ce(source,pos);%0A\n+%09\n %09// Get the attr\n@@ -6292,32 +6292,33 @@\n  attribute name%0A\n+%09\n %09var name = $tw.\n@@ -6369,47 +6369,51 @@\n eName);%0A\n+%09\n %09if(!name) %7B%0A\n+%09\n %09%09return null;%0A\n+%09\n %09%7D%0A\n+%09\n %09node.na\n@@ -6424,32 +6424,33 @@\n  name.match%5B1%5D;%0A\n+%09\n %09pos = name.end;\n@@ -6442,32 +6442,33 @@\n pos = name.end;%0A\n+%09\n %09// Skip whitesp\n@@ -6463,32 +6463,33 @@\n Skip whitespace%0A\n+%09\n %09pos = $tw.utils\n@@ -6509,32 +6509,33 @@\n ce(source,pos);%0A\n+%09\n %09// Look for an \n@@ -6538,32 +6538,33 @@\n  an equals sign%0A\n+%09\n %09var token = $tw\n@@ -6604,29 +6604,31 @@\n s,%22=%22);%0A\n+%09\n %09if(token) %7B%0A\n+%09\n %09%09pos = \n@@ -6632,32 +6632,33 @@\n  = token.end;%0A%09%09\n+%09\n // Skip whitespa\n@@ -6652,32 +6652,33 @@\n Skip whitespace%0A\n+%09\n %09%09pos = $tw.util\n@@ -6701,32 +6701,33 @@\n (source,pos);%0A%09%09\n+%09\n // Look for a st\n@@ -6731,32 +6731,33 @@\n  string literal%0A\n+%09\n %09%09var stringLite\n@@ -6798,32 +6798,33 @@\n (source,pos);%0A%09%09\n+%09\n if(stringLiteral\n@@ -6830,41 +6830,25 @@\n l) %7B%0A%09%09%09\n-pos = stringLiteral.end;%0A\n+%09%09%09%09   %0A%09\n %09%09%09node.\n@@ -6856,32 +6856,33 @@\n ype = %22string%22;%0A\n+%09\n %09%09%09node.value = \n@@ -6904,271 +6904,293 @@\n alue;%0A%09%09\n-%7D else %7B%0A%09%09%09// Look for a filtered value%0A%09%09%09var filteredValue = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);%0A%09%09%09if(filteredValue) %7B%0A%09%09%09%09pos = filteredValue.end;%0A%09%09%09%09node.type = %22filtered%22;%0A%09%09%09%09node.filter = filteredValue.match%5B1%5D;%0A%09%09%09%7D else %7B%0A%09\n+%09%09node.end = stringLiteral.end;%0A%09%09%09%09%09%09%09%09   %0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09  %0A%09%09%09%09%09%09  %0A%09%09%09%09%09%09%09%09%0A%09%09%09%09return node;%0A%09%09%09%7D%0A%09%09%09// Load attribute rules if needed%0A%09%09%09if (!AttributeRules) %7B%0A%09%09%09%09AttributeRules = %7B%7D;%0A%09%09%09%09$tw.modules.applyMethods(%22attributerule%22,AttributeRules);%0A%09%09%09%7D%0A\n %09%09%09// Lo\n@@ -7199,261 +7199,213 @@\n  for an \n-indirect valu\n+attribute rul\n e%0A\n-%09\n %09%09%09var \n-indirectValue = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);%0A%09%09%09%09if(indirectValue) %7B%0A%09%09%09%09%09pos = indirectValue.end;%0A%09%09%09%09%09node.type = %22indirect%22;%0A%09%09%09%09%09node.textReference = indirectValue.\n+match = null;%0A%09%09%09$tw.utils.each(AttributeRules,function(rule) %7B%0A%09%09%09%09match = rule(source,pos,node);%0A%09%09%09%09return !match;%0A%09%09%09%7D);%0A%09%09%09if (match) return \n match\n-%5B1%5D\n ;%0A%09%09%09%09\n-%7D else %7B\n+%09%09%09%09%09%09%09%09%09 \n %0A%09%09%09%09\n+%0A%09%09\n %09// Look\n@@ -7418,34 +7418,32 @@\n  unquoted value%0A\n-%09%09\n %09%09%09var unquotedV\n@@ -7504,34 +7504,32 @@\n dAttribute);%0A%09%09%09\n-%09%09\n if(unquotedValue\n@@ -7538,43 +7538,21 @@\n %7B%0A%09%09%09%09%09%09\n-pos = unquotedValue.end;%0A%09%09\n+%09%09  %0A\n %09%09%09%09node\n@@ -7561,34 +7561,32 @@\n ype = %22string%22;%0A\n-%09%09\n %09%09%09%09node.value =\n@@ -7614,290 +7614,171 @@\n 1%5D;%0A%09%09%09%09\n-%09%7D else %7B%0A%09%09%09%09%09%09// Look for a macro invocation value%0A%09%09%09%09%09%09var macroInvocation = $tw.utils.parseMacroInvocation(source,pos);%0A%09%09%09%09%09%09if(macroInvocation) %7B%0A%09%09%09%09%09%09%09pos = macroInvocation.end;%0A%09%09%09%09%09%09%09node.type = %22macro%22;%0A%09%09%09%09%09%09%09node.value = macroInvocation;%0A%09%09%09\n+node.end = unquotedValue.end;%0A%09%09%09%09%09%09%09%09%09%09%09  %0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09  %0A%09%09%09%09%09%09%09   %0A%09%09%09%09%09%09%09%09%09 %0A%09%09%09%09return node;%0A%09%09%09%09%09%09%09%09%09%09%0A\n %09%09%09%7D else %7B%0A%09%09%09%09\n-%09%09%09\n node.typ\n@@ -7787,35 +7787,32 @@\n = %22string%22;%0A%09%09%09%09\n-%09%09\n-%09\n node.value = %22tr\n@@ -7816,56 +7816,50 @@\n %22true%22;%0A\n-%09%09%09\n %09%09%09%7D%0A%09%09\n-%09%09%09%7D%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D%0A\n+  %0A%09%09 %0A%09%09%0A%09   %0A%09\n %09%7D else %7B%0A\n+%09\n %09%09node.t\n@@ -7868,32 +7868,33 @@\n e = %22string%22;%0A%09%09\n+%09\n node.value = %22tr\n@@ -7890,35 +7890,37 @@\n value = %22true%22;%0A\n+%09\n %09%7D%0A\n+%09\n %09// Update the e\n@@ -7923,32 +7923,33 @@\n he end position%0A\n+%09\n %09node.end = pos;\n@@ -7949,32 +7949,37 @@\n  = pos;%0A\n+%09\n %09return node;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n %7D)();%0A\n+%09\n"
        },
        "$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js",
            "created": "20190810062712336",
            "modified": "20190810062712336",
            "modloader-source": "$:/core",
            "modloader-target": "$:/core/modules/widgets/widget.js",
            "tags": "",
            "type": "text/x-patch",
            "text": "@@ -78,33 +78,35 @@\n ule-type: widget\n-%0A\n+%0D%0A%0D\n %0AWidget base cla\n@@ -99,33 +99,35 @@\n idget base class\n-%0A\n+%0D%0A%0D\n %0A%5C*/%0A(function()\n@@ -119,34 +119,37 @@\n %5C*/%0A(function()%7B\n-%0A%0A\n+%0D%0A%0D%0A%09\n /*jslint node: t\n@@ -162,32 +162,33 @@\n rowser: true */%0A\n+%09\n /*global $tw: fa\n@@ -194,34 +194,38 @@\n alse */%0A\n+%09\n %22use strict%22;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Create a\n@@ -253,32 +253,33 @@\n parse tree node%0A\n+%09\n %09parseTreeNode: \n@@ -318,32 +318,33 @@\n  to be rendered%0A\n+%09\n %09options: see be\n@@ -339,32 +339,33 @@\n ions: see below%0A\n+%09\n Options include:\n@@ -357,32 +357,33 @@\n ptions include:%0A\n+%09\n %09wiki: mandatory\n@@ -426,32 +426,33 @@\n his render tree%0A\n+%09\n %09parentWidget: o\n@@ -509,32 +509,33 @@\n e context chain%0A\n+%09\n %09document: optio\n@@ -580,35 +580,37 @@\n global document%0A\n+%09\n */%0A\n+%09\n var Widget = fun\n@@ -632,32 +632,34 @@\n Node,options) %7B%0A\n+%09%09\n %09this.initialise\n@@ -675,39 +675,43 @@\n eNode,options);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Initialise widge\n@@ -802,35 +802,37 @@\n m in subclasses%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -871,32 +871,33 @@\n Node,options) %7B%0A\n+%09\n %09// Bail if pars\n@@ -1011,32 +1011,33 @@\n n be subclassed%0A\n+%09\n %09if(parseTreeNod\n@@ -1057,27 +1057,30 @@\n ed) %7B%0A%09%09\n+%09\n return;%0A\n+%09\n %09%7D%0A\n+%09\n %09options\n@@ -1089,32 +1089,33 @@\n  options %7C%7C %7B%7D;%0A\n+%09\n %09// Save widget \n@@ -1111,32 +1111,33 @@\n ave widget info%0A\n+%09\n %09this.parseTreeN\n@@ -1149,32 +1149,33 @@\n  parseTreeNode;%0A\n+%09\n %09this.wiki = opt\n@@ -1177,32 +1177,33 @@\n = options.wiki;%0A\n+%09\n %09this.parentWidg\n@@ -1221,32 +1221,33 @@\n s.parentWidget;%0A\n+%09\n %09this.variablesC\n@@ -1266,32 +1266,33 @@\n  function() %7B%7D;%0A\n+%09\n %09this.variablesC\n@@ -1360,32 +1360,33 @@\n variables : %7B%7D;%0A\n+%09\n %09this.variables \n@@ -1412,32 +1412,33 @@\n sConstructor();%0A\n+%09\n %09this.document =\n@@ -1448,32 +1448,33 @@\n tions.document;%0A\n+%09\n %09this.attributes\n@@ -1472,32 +1472,33 @@\n ttributes = %7B%7D;%0A\n+%09\n %09this.children =\n@@ -1494,32 +1494,33 @@\n .children = %5B%5D;%0A\n+%09\n %09this.domNodes =\n@@ -1516,32 +1516,33 @@\n .domNodes = %5B%5D;%0A\n+%09\n %09this.eventListe\n@@ -1544,32 +1544,33 @@\n Listeners = %7B%7D;%0A\n+%09\n %09// Hashmap of t\n@@ -1579,32 +1579,33 @@\n  widget classes%0A\n+%09\n %09if(!this.widget\n@@ -1609,32 +1609,33 @@\n getClasses) %7B%0A%09%09\n+%09\n // Get widget cl\n@@ -1632,32 +1632,33 @@\n  widget classes%0A\n+%09\n %09%09Widget.prototy\n@@ -1706,32 +1706,33 @@\n ds(%22widget%22);%0A%09%09\n+%09\n // Process any s\n@@ -1733,32 +1733,33 @@\n  any subclasses%0A\n+%09\n %09%09$tw.modules.fo\n@@ -1814,32 +1814,33 @@\n le,module) %7B%0A%09%09%09\n+%09\n if(module.baseCl\n@@ -1838,32 +1838,33 @@\n le.baseClass) %7B%0A\n+%09\n %09%09%09%09var baseClas\n@@ -1913,32 +1913,33 @@\n baseClass%5D;%0A%09%09%09%09\n+%09\n if(!baseClass) %7B\n@@ -1931,32 +1931,33 @@\n f(!baseClass) %7B%0A\n+%09\n %09%09%09%09%09throw %22Modu\n@@ -2049,34 +2049,36 @@\n lass + %22'%22;%0A%09%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%09%09var subClass\n@@ -2092,32 +2092,33 @@\n le.constructor;%0A\n+%09\n %09%09%09%09subClass.pro\n@@ -2139,32 +2139,33 @@\n aseClass();%0A%09%09%09%09\n+%09\n $tw.utils.extend\n@@ -2195,32 +2195,33 @@\n ule.prototype);%0A\n+%09\n %09%09%09%09Widget.proto\n@@ -2287,34 +2287,197 @@\n ass;%0A%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%7D);%0A\n+%09\n %09%7D%0A\n-%7D;%0A%0A\n+%09%09// Hashmap of the attribute classes%0A%09%09if(!this.attributeClasses) %7B%0A%09%09%09Widget.prototype.attributeClasses = $tw.modules.applyMethods(%22attributevalue%22);%0A%09%09%7D%0A%09%7D;%0A%09%0A%09\n /*%0A\n+%09\n Render t\n@@ -2492,35 +2492,37 @@\n et into the DOM%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -2554,32 +2554,33 @@\n ,nextSibling) %7B%0A\n+%09\n %09this.parentDomN\n@@ -2585,32 +2585,33 @@\n mNode = parent;%0A\n+%09\n %09this.execute();\n@@ -2603,32 +2603,33 @@\n this.execute();%0A\n+%09\n %09this.renderChil\n@@ -2646,39 +2646,43 @@\n t,nextSibling);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Compute the inte\n@@ -2698,35 +2698,37 @@\n e of the widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -2743,32 +2743,33 @@\n  = function() %7B%0A\n+%09\n %09this.makeChildW\n@@ -2770,39 +2770,43 @@\n ChildWidgets();%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Set the value of\n@@ -2817,32 +2817,33 @@\n ontext variable%0A\n+%09\n name: name of th\n@@ -2845,32 +2845,33 @@\n of the variable%0A\n+%09\n value: value of \n@@ -2875,32 +2875,33 @@\n of the variable%0A\n+%09\n params: array of\n@@ -2930,32 +2930,33 @@\n  each parameter%0A\n+%09\n isMacroDefinitio\n@@ -3061,35 +3061,37 @@\n tion performed)%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -3145,32 +3145,33 @@\n roDefinition) %7B%0A\n+%09\n %09this.variables%5B\n@@ -3242,39 +3242,43 @@\n croDefinition%7D;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Get the prevaili\n@@ -3300,32 +3300,33 @@\n ontext variable%0A\n+%09\n name: name of va\n@@ -3324,32 +3324,33 @@\n ame of variable%0A\n+%09\n options: see bel\n@@ -3352,32 +3352,34 @@\n e below%0A\n+%09\n Options include%0A\n+%09\n params: \n@@ -3414,32 +3414,33 @@\n  each parameter%0A\n+%09\n defaultValue: de\n@@ -3474,33 +3474,35 @@\n  is not defined%0A\n-%0A\n+%09%0A%09\n Returns an objec\n@@ -3522,33 +3522,35 @@\n llowing fields:%0A\n-%0A\n+%09%0A%09\n params: array of\n@@ -3600,32 +3600,33 @@\n itext variables%0A\n+%09\n text: text of va\n@@ -3662,35 +3662,37 @@\n rly substituted%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -3727,32 +3727,33 @@\n name,options) %7B%0A\n+%09\n %09options = optio\n@@ -3754,32 +3754,33 @@\n  options %7C%7C %7B%7D;%0A\n+%09\n %09var actualParam\n@@ -3799,32 +3799,33 @@\n params %7C%7C %5B%5D,%0A%09%09\n+%09\n parentWidget = t\n@@ -3834,32 +3834,33 @@\n s.parentWidget;%0A\n+%09\n %09// Check for th\n@@ -3931,32 +3931,33 @@\n rototype chain)%0A\n+%09\n %09if(parentWidget\n@@ -3986,32 +3986,33 @@\n et.variables) %7B%0A\n+%09\n %09%09var variable =\n@@ -4037,32 +4037,33 @@\n ables%5Bname%5D,%0A%09%09%09\n+%09\n value = variable\n@@ -4062,32 +4062,33 @@\n variable.value,%0A\n+%09\n %09%09%09params = this\n@@ -4139,32 +4139,33 @@\n ctualParams);%0A%09%09\n+%09\n // Substitute an\n@@ -4197,32 +4197,33 @@\n  the definition%0A\n+%09\n %09%09$tw.utils.each\n@@ -4243,32 +4243,33 @@\n ion(param) %7B%0A%09%09%09\n+%09\n value = $tw.util\n@@ -4366,36 +4366,38 @@\n param.value);%0A%09%09\n+%09\n %7D);%0A\n+%09\n %09%09// Only substi\n@@ -4468,32 +4468,33 @@\n define pragma%0A%09%09\n+%09\n if(variable.isMa\n@@ -4502,32 +4502,33 @@\n roDefinition) %7B%0A\n+%09\n %09%09%09value = this.\n@@ -4569,45 +4569,49 @@\n );%09%09%09%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09return %7B%0A%09%09%09\n+%09\n text: value,%0A\n+%09\n %09%09%09param\n@@ -4614,38 +4614,41 @@\n arams: params%0A%09%09\n+%09\n %7D;%0A\n+%09\n %09%7D%0A\n+%09\n %09// If the varia\n@@ -4707,42 +4707,44 @@\n  a macro module%0A\n+%09\n %09return %7B%0A\n+%09\n %09%09text: this.eva\n@@ -4792,43 +4792,48 @@\n s.defaultValue)%0A\n+%09\n %09%7D;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Simplified versi\n@@ -4875,35 +4875,37 @@\n eturns the text%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -4936,32 +4936,33 @@\n name,options) %7B%0A\n+%09\n %09return this.get\n@@ -4986,36 +4986,39 @@\n ,options).text;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n Widget.prototype\n@@ -5076,32 +5076,33 @@\n actualParams) %7B%0A\n+%09\n %09formalParams = \n@@ -5113,32 +5113,33 @@\n alParams %7C%7C %5B%5D;%0A\n+%09\n %09actualParams = \n@@ -5150,32 +5150,33 @@\n alParams %7C%7C %5B%5D;%0A\n+%09\n %09var nextAnonPar\n@@ -5233,32 +5233,33 @@\n in macro call%0A%09%09\n+%09\n paramInfo, param\n@@ -5267,30 +5267,32 @@\n alue,%0A%09%09\n+%09\n results = %5B%5D;%0A\n+%09\n %09// Step\n@@ -5339,32 +5339,33 @@\n acro definition%0A\n+%09\n %09for(var p=0; p%3C\n@@ -5384,32 +5384,33 @@\n .length; p++) %7B%0A\n+%09\n %09%09// Check if we\n@@ -5453,32 +5453,33 @@\n the same name%0A%09%09\n+%09\n paramInfo = form\n@@ -5483,32 +5483,33 @@\n ormalParams%5Bp%5D;%0A\n+%09\n %09%09paramValue = u\n@@ -5512,32 +5512,33 @@\n  = undefined;%0A%09%09\n+%09\n for(var m=0; m%3Ca\n@@ -5556,32 +5556,33 @@\n .length; m++) %7B%0A\n+%09\n %09%09%09if(actualPara\n@@ -5610,32 +5610,33 @@\n nfo.name) %7B%0A%09%09%09%09\n+%09\n paramValue = act\n@@ -5650,38 +5650,41 @@\n ms%5Bm%5D.value;%0A%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%09// If not, use\n@@ -5726,32 +5726,33 @@\n  call parameter%0A\n+%09\n %09%09while(nextAnon\n@@ -5821,32 +5821,33 @@\n ter%5D.name) %7B%0A%09%09%09\n+%09\n nextAnonParamete\n@@ -5845,34 +5845,36 @@\n nParameter++;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09if(paramValue \n@@ -5925,32 +5925,33 @@\n arams.length) %7B%0A\n+%09\n %09%09%09paramValue = \n@@ -5985,34 +5985,36 @@\n ter++%5D.value;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09// If we've st\n@@ -6050,32 +6050,33 @@\n default, if any%0A\n+%09\n %09%09paramValue = p\n@@ -6110,32 +6110,33 @@\n ault%22%5D %7C%7C %22%22;%0A%09%09\n+%09\n // Store the par\n@@ -6149,32 +6149,33 @@\n  name and value%0A\n+%09\n %09%09results.push(%7B\n@@ -6209,35 +6209,37 @@\n : paramValue%7D);%0A\n+%09\n %09%7D%0A\n+%09\n %09return results;\n@@ -6231,36 +6231,39 @@\n return results;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n Widget.prototype\n@@ -6303,32 +6303,33 @@\n unction(text) %7B%0A\n+%09\n %09var self = this\n@@ -6322,32 +6322,33 @@\n ar self = this;%0A\n+%09\n %09return (text %7C%7C\n@@ -6411,32 +6411,33 @@\n set,string) %7B%0A%09%09\n+%09\n return self.getV\n@@ -6460,41 +6460,45 @@\n ultValue: %22%22%7D);%0A\n+%09\n %09%7D);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n Widget.prototype\n@@ -6555,32 +6555,33 @@\n defaultValue) %7B%0A\n+%09\n %09if($tw.utils.ho\n@@ -6596,32 +6596,33 @@\n cros,name)) %7B%0A%09%09\n+%09\n var macro = $tw.\n@@ -6635,32 +6635,34 @@\n %5Bname%5D,%0A\n+%09\n %09%09%09args = %5B%5D;%0A%09%09\n+%09\n if(macro\n@@ -6675,32 +6675,33 @@\n s.length %3E 0) %7B%0A\n+%09\n %09%09%09var nextAnonP\n@@ -6758,32 +6758,33 @@\n r in macro call%0A\n+%09\n %09%09%09%09paramInfo, p\n@@ -6789,32 +6789,33 @@\n  paramValue;%0A%09%09%09\n+%09\n // Step through \n@@ -6853,32 +6853,33 @@\n acro definition%0A\n+%09\n %09%09%09for(var p=0; \n@@ -6904,32 +6904,33 @@\n gth; p++) %7B%0A%09%09%09%09\n+%09\n // Check if we'v\n@@ -6969,32 +6969,33 @@\n h the same name%0A\n+%09\n %09%09%09%09paramInfo = \n@@ -7007,32 +7007,33 @@\n .params%5Bp%5D;%0A%09%09%09%09\n+%09\n paramValue = und\n@@ -7032,32 +7032,33 @@\n ue = undefined;%0A\n+%09\n %09%09%09%09for(var m=0;\n@@ -7080,32 +7080,33 @@\n .length; m++) %7B%0A\n+%09\n %09%09%09%09%09if(actualPa\n@@ -7138,32 +7138,33 @@\n o.name) %7B%0A%09%09%09%09%09%09\n+%09\n paramValue = act\n@@ -7183,29 +7183,32 @@\n .value;%0A\n+%09\n %09%09%09%09%09%7D%0A%09%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%09%09// I\n@@ -7260,32 +7260,33 @@\n  call parameter%0A\n+%09\n %09%09%09%09while(nextAn\n@@ -7354,32 +7354,33 @@\n ameter%5D.name) %7B%0A\n+%09\n %09%09%09%09%09nextAnonPar\n@@ -7385,34 +7385,36 @@\n arameter++;%0A%09%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%09%09if(paramValu\n@@ -7472,32 +7472,33 @@\n .length) %7B%0A%09%09%09%09%09\n+%09\n paramValue = act\n@@ -7531,34 +7531,36 @@\n r++%5D.value;%0A%09%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%09%09// If we've \n@@ -7602,32 +7602,33 @@\n ult, if any%0A%09%09%09%09\n+%09\n paramValue = par\n@@ -7662,32 +7662,33 @@\n lt%22%5D %7C%7C %22%22;%0A%09%09%09%09\n+%09\n // Save the para\n@@ -7685,32 +7685,33 @@\n e the parameter%0A\n+%09\n %09%09%09%09args.push(pa\n@@ -7713,41 +7713,44 @@\n sh(paramValue);%0A\n+%09\n %09%09%09%7D%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09else for(var i\n@@ -7778,32 +7778,33 @@\n ngth; ++i) %7B%0A%09%09%09\n+%09\n args.push(actual\n@@ -7815,34 +7815,36 @@\n ms%5Bi%5D.value);%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09return (macro.\n@@ -7875,42 +7875,44 @@\n %22%22).toString();%0A\n+%09\n %09%7D else %7B%0A\n+%09\n %09%09return default\n@@ -7910,42 +7910,47 @@\n n defaultValue;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Check whether a \n@@ -7997,35 +7997,37 @@\n he parent chain%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -8056,32 +8056,33 @@\n n(name,value) %7B%0A\n+%09\n %09var node = this\n@@ -8083,31 +8083,33 @@\n = this;%0A\n+%09\n %09while(node) %7B%0A\n+%09\n %09%09if($tw\n@@ -8175,32 +8175,33 @@\n ue === value) %7B%0A\n+%09\n %09%09%09return true;%0A\n@@ -8194,34 +8194,36 @@\n %09return true;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09node = node.pa\n@@ -8234,41 +8234,47 @@\n Widget;%0A\n+%09\n %09%7D%0A\n+%09\n %09return false;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Construc\n@@ -8371,35 +8371,37 @@\n he parent chain%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -8430,32 +8430,33 @@\n unction(name) %7B%0A\n+%09\n %09this.qualifiers\n@@ -8490,32 +8490,33 @@\n t.create(null);%0A\n+%09\n %09name = name %7C%7C \n@@ -8523,32 +8523,33 @@\n %22transclusion%22;%0A\n+%09\n %09if(this.qualifi\n@@ -8553,32 +8553,33 @@\n ifiers%5Bname%5D) %7B%0A\n+%09\n %09%09return this.qu\n@@ -8586,42 +8586,44 @@\n alifiers%5Bname%5D;%0A\n+%09\n %09%7D else %7B%0A\n+%09\n %09%09var output = %5B\n@@ -8620,45 +8620,47 @@\n output = %5B%5D,%0A%09%09%09\n+%09\n node = this;%0A\n+%09\n %09%09while(node && \n@@ -8675,32 +8675,33 @@\n entWidget) %7B%0A%09%09%09\n+%09\n if($tw.utils.hop\n@@ -8734,32 +8734,33 @@\n es,name)) %7B%0A%09%09%09%09\n+%09\n output.push(node\n@@ -8772,40 +8772,42 @@\n ariable(name));%0A\n+%09\n %09%09%09%7D%0A%09%09%09\n+%09\n node = node.pare\n@@ -8808,38 +8808,40 @@\n e.parentWidget;%0A\n+%09\n %09%09%7D%0A%09%09\n+%09\n var value = $tw.\n@@ -8869,32 +8869,33 @@\n ut.join(%22%22));%0A%09%09\n+%09\n this.qualifiers%5B\n@@ -8911,40 +8911,46 @@\n alue;%0A%09%09\n+%09\n return value;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Compute \n@@ -9060,35 +9060,37 @@\n at have changed%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -9115,32 +9115,33 @@\n  = function() %7B%0A\n+%09\n %09var changedAttr\n@@ -9155,38 +9155,142 @@\n = %7B%7D,%0A%09%09\n+%09\n self = this,%0A\n+%09\n %09%09value;%0A\n+%09%09if (!this.attributeGizmos) %7B%0A%09%09%09// First-time attribute preparation%0A%09%09%09this.attributeGizmos = %7B%7D;%0A%09%09\n %09$tw.uti\n@@ -9356,502 +9356,1505 @@\n me) %7B%0A%09%09\n-if(\n+%09%09// Does the \n attribute\n-.\n+ \n type \n-=== %22filtered%22) %7B%0A%09%09%09value = self.wiki.filterTiddlers(attribute.filter,self)%5B0%5D %7C%7C %22%22;%0A%09%09%7D else if(attribute.type === %22indirect%22) %7B\n+have a known module?%0A%09%09%09%09var AttributeClass = self.attributeClasses%5Battribute.type%5D;%0A%09%09%09%09if (AttributeClass) %7B%0A%09%09%09%09%09// Instantiate an attribute object.%0A%09%09%09%09%09self.attributeGizmos%5Bname%5D = new AttributeClass(self,attribute);\n %0A%09%09%09\n+%09%09\n value = self.\n-wiki.getTextReference(attribute.textReference,%22%22,self.getVariable(%22currentTiddler%22)\n+attributeGizmos%5Bname%5D.value;%0A%09%09%09%09%7D%0A%09%09%09%09else %7B%0A%09%09%09%09%09// Unknown attribute types are treated as strings.%0A%09%09%09%09%09// String attributes don't change after the first computeAttributes().%0A%09%09%09%09%09value = attribute.value;%0A%09%09%09%09%7D%0A%09%09%09%09// Is the value changed?%0A%09%09%09%09if (self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%09%7D%0A%09%09%09%09return true;%0A%09%09%09%7D\n );%0A%09%09%7D\n- \n else \n-if(attribute.type === %22macro%22\n+%7B%0A%09%09%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09%09%09$tw.utils.each(this.attributeGizmos,function(gizmo,name\n ) %7B%0A\n+%09\n %09%09%09value = \n-self.getVariable(attribute.value.name,%7Bparams: attribute.value.params%7D);%0A%09%09%7D else %7B // String a\n+gizmo.compute();%0A%09%09%09%09if(self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%09%7D%0A%09%09%09%7D);%0A%09%09%7D%0A%09%09return changedAttributes;%0A%09%7D;%0A%09%0A%09/*%0A%09Selectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed%0A%09*/%0A%09Widget.prototype.refreshAttributes = function(changedTiddlers) %7B%0A%09%09if (!this.attributeGizmos) return computeA\n ttribute\n+s();\n %0A%09%09\n-%09\n va\n-lue = attribute.value;%0A%09%09%7D%0A%09%09// Check whether the attribute has changed%0A\n+r changedAttributes = %7B%7D,%0A%09%09%09self = this,%0A%09%09%09value;%0A%09%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09%09$tw.utils.each(this.attributeGizmos,function(gizmo,name) %7B%0A%09%09%09value = gizmo.refresh(changedTiddlers);%0A%09\n %09%09if(sel\n@@ -10880,32 +10880,33 @@\n !== value) %7B%0A%09%09%09\n+%09\n self.attributes%5B\n@@ -10912,32 +10912,33 @@\n %5Bname%5D = value;%0A\n+%09\n %09%09%09changedAttrib\n@@ -10950,39 +10950,42 @@\n name%5D = true;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D);%0A\n+%09\n %09return changedA\n@@ -10987,39 +10987,43 @@\n ngedAttributes;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Check for the pr\n@@ -11037,35 +11037,37 @@\n of an attribute%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -11091,32 +11091,33 @@\n unction(name) %7B%0A\n+%09\n %09return $tw.util\n@@ -11137,39 +11137,43 @@\n tributes,name);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Get the value of\n@@ -11178,35 +11178,37 @@\n of an attribute%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -11244,32 +11244,33 @@\n ,defaultText) %7B%0A\n+%09\n %09if($tw.utils.ho\n@@ -11290,32 +11290,33 @@\n utes,name)) %7B%0A%09%09\n+%09\n return this.attr\n@@ -11321,42 +11321,44 @@\n tributes%5Bname%5D;%0A\n+%09\n %09%7D else %7B%0A\n+%09\n %09%09return default\n@@ -11355,42 +11355,47 @@\n rn defaultText;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Assign the compu\n@@ -11428,32 +11428,33 @@\n et to a domNode%0A\n+%09\n options include:\n@@ -11446,32 +11446,33 @@\n ptions include:%0A\n+%09\n excludeEventAttr\n@@ -11518,35 +11518,37 @@\n egins with %22on%22%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -11587,32 +11587,33 @@\n Node,options) %7B%0A\n+%09\n %09options = optio\n@@ -11614,32 +11614,33 @@\n  options %7C%7C %7B%7D;%0A\n+%09\n %09var self = this\n@@ -11633,32 +11633,33 @@\n ar self = this;%0A\n+%09\n %09$tw.utils.each(\n@@ -11684,32 +11684,33 @@\n nction(v,a) %7B%0A%09%09\n+%09\n // Check exclusi\n@@ -11705,32 +11705,33 @@\n heck exclusions%0A\n+%09\n %09%09if(options.exc\n@@ -11774,32 +11774,33 @@\n  === %22on%22) %7B%0A%09%09%09\n+%09\n v = undefined;%0A%09\n@@ -11792,34 +11792,36 @@\n  = undefined;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09if(v !== undef\n@@ -11820,32 +11820,33 @@\n == undefined) %7B%0A\n+%09\n %09%09%09var b = a.spl\n@@ -11849,32 +11849,33 @@\n .split(%22:%22);%0A%09%09%09\n+%09\n // Setting certa\n@@ -11943,22 +11943,24 @@\n ent)%0A%09%09%09\n+%09\n try %7B%0A\n+%09\n %09%09%09%09if (\n@@ -11991,32 +11991,33 @@\n  %22xlink%22)%7B%0A%09%09%09%09%09\n+%09\n domNode.setAttri\n@@ -12055,32 +12055,33 @@\n xlink%22,b%5B1%5D,v);%0A\n+%09\n %09%09%09%09%7D else %7B%0A%09%09%09\n@@ -12074,32 +12074,33 @@\n %09%09%7D else %7B%0A%09%09%09%09%09\n+%09\n domNode.setAttri\n@@ -12121,55 +12121,64 @@\n v);%0A%09%09%09%09\n+%09\n %7D%0A\n+%09\n %09%09%09%7D catch(e) %7B%0A\n+%09\n %09%09%09%7D%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Make chi\n@@ -12221,35 +12221,37 @@\n  parseTreeNodes%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -12289,32 +12289,33 @@\n rseTreeNodes) %7B%0A\n+%09\n %09this.children =\n@@ -12311,32 +12311,33 @@\n .children = %5B%5D;%0A\n+%09\n %09var self = this\n@@ -12330,32 +12330,33 @@\n ar self = this;%0A\n+%09\n %09$tw.utils.each(\n@@ -12441,32 +12441,33 @@\n (childNode) %7B%0A%09%09\n+%09\n self.children.pu\n@@ -12495,44 +12495,49 @@\n et(childNode));%0A\n+%09\n %09%7D);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Construct the wi\n@@ -12562,35 +12562,37 @@\n parse tree node%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -12628,32 +12628,33 @@\n arseTreeNode) %7B%0A\n+%09\n %09var WidgetClass\n@@ -12688,32 +12688,33 @@\n TreeNode.type%5D;%0A\n+%09\n %09if(!WidgetClass\n@@ -12711,32 +12711,33 @@\n idgetClass) %7B%0A%09%09\n+%09\n WidgetClass = th\n@@ -12751,32 +12751,33 @@\n etClasses.text;%0A\n+%09\n %09%09parseTreeNode \n@@ -12841,35 +12841,37 @@\n de.type + %22'%22%7D;%0A\n+%09\n %09%7D%0A\n+%09\n %09return new Widg\n@@ -12888,32 +12888,33 @@\n rseTreeNode,%7B%0A%09%09\n+%09\n wiki: this.wiki,\n@@ -12906,32 +12906,33 @@\n iki: this.wiki,%0A\n+%09\n %09%09variables: %7B%7D,\n@@ -12926,32 +12926,33 @@\n ariables: %7B%7D,%0A%09%09\n+%09\n parentWidget: th\n@@ -12947,32 +12947,33 @@\n ntWidget: this,%0A\n+%09\n %09%09document: this\n@@ -12974,44 +12974,49 @@\n : this.document%0A\n+%09\n %09%7D);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Get the next sib\n@@ -13027,35 +13027,37 @@\n  of this widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -13076,32 +13076,33 @@\n  = function() %7B%0A\n+%09\n %09if(this.parentW\n@@ -13102,32 +13102,33 @@\n parentWidget) %7B%0A\n+%09\n %09%09var index = th\n@@ -13159,32 +13159,33 @@\n .indexOf(this);%0A\n+%09\n %09%09if(index !== -\n@@ -13231,32 +13231,33 @@\n .length-1) %7B%0A%09%09%09\n+%09\n return this.pare\n@@ -13284,44 +13284,51 @@\n dex+1%5D;%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%7D%0A\n+%09\n %09return null;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Get the \n@@ -13351,35 +13351,37 @@\n  of this widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -13404,32 +13404,33 @@\n  = function() %7B%0A\n+%09\n %09if(this.parentW\n@@ -13432,32 +13432,33 @@\n rentWidget) %7B%0A%09%09\n+%09\n var index = this\n@@ -13487,32 +13487,33 @@\n .indexOf(this);%0A\n+%09\n %09%09if(index !== -\n@@ -13525,32 +13525,33 @@\n index %3E 0) %7B%0A%09%09%09\n+%09\n return this.pare\n@@ -13578,44 +13578,51 @@\n dex-1%5D;%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%7D%0A\n+%09\n %09return null;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Render t\n@@ -13653,35 +13653,37 @@\n et into the DOM%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -13732,103 +13732,84 @@\n ing) %7B%0A%09\n-var children = this.children;%0A%09for(var i = 0; i %3C children.length; i++\n+%09$tw.utils.each(this.children,function(childWidget\n ) %7B%0A\n+%09\n %09%09child\n-ren%5Bi%5D\n+Widget\n .render(\n@@ -13830,26 +13830,32 @@\n ling);%0A%09\n-%7D\n+%09%7D)\n ;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Add a li\n@@ -13905,35 +13905,37 @@\n ,handler:%7D,...%5D%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -13969,32 +13969,33 @@\n on(listeners) %7B%0A\n+%09\n %09var self = this\n@@ -13988,32 +13988,33 @@\n ar self = this;%0A\n+%09\n %09$tw.utils.each(\n@@ -14040,32 +14040,33 @@\n listenerInfo) %7B%0A\n+%09\n %09%09self.addEventL\n@@ -14114,28 +14114,33 @@\n ndler);%0A\n+%09\n %09%7D);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Add an e\n@@ -14145,35 +14145,37 @@\n  event listener%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -14211,32 +14211,33 @@\n type,handler) %7B%0A\n+%09\n %09var self = this\n@@ -14230,32 +14230,33 @@\n ar self = this;%0A\n+%09\n %09if(typeof handl\n@@ -14315,32 +14315,33 @@\n n this widget%0A%09%09\n+%09\n this.eventListen\n@@ -14362,32 +14362,33 @@\n nction(event) %7B%0A\n+%09\n %09%09%09return self%5Bh\n@@ -14407,35 +14407,37 @@\n (self,event);%0A%09%09\n+%09\n %7D;%0A\n+%09\n %09%7D else %7B // The\n@@ -14451,32 +14451,33 @@\n r is a function%0A\n+%09\n %09%09this.eventList\n@@ -14503,32 +14503,33 @@\n ion(event) %7B%0A%09%09%09\n+%09\n return handler.c\n@@ -14545,31 +14545,37 @@\n event);%0A\n+%09\n %09%09%7D;%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Dispatch\n@@ -14676,35 +14676,37 @@\n e parent widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -14732,32 +14732,33 @@\n nction(event) %7B%0A\n+%09\n %09// Dispatch the\n@@ -14782,32 +14782,33 @@\n dget handles it%0A\n+%09\n %09var listener = \n@@ -14840,32 +14840,34 @@\n .type%5D;%0A\n+%09\n %09if(listener) %7B%0A\n+%09\n %09%09// Don\n@@ -14914,32 +14914,33 @@\n eturned false%0A%09%09\n+%09\n if(!listener(eve\n@@ -14938,32 +14938,33 @@\n tener(event)) %7B%0A\n+%09\n %09%09%09return false;\n@@ -14958,37 +14958,40 @@\n return false;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D%0A\n+%09\n %09// Dispatch the\n@@ -15010,32 +15010,33 @@\n e parent widget%0A\n+%09\n %09if(this.parentW\n@@ -15036,32 +15036,33 @@\n parentWidget) %7B%0A\n+%09\n %09%09return this.pa\n@@ -15094,40 +15094,46 @@\n event);%0A\n+%09\n %09%7D%0A\n+%09\n %09return true;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Selectiv\n@@ -15230,35 +15230,37 @@\n ed re-rendering%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -15290,32 +15290,33 @@\n ngedTiddlers) %7B%0A\n+%09\n %09return this.ref\n@@ -15338,39 +15338,43 @@\n angedTiddlers);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Rebuild a previo\n@@ -15386,35 +15386,37 @@\n rendered widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -15435,32 +15435,33 @@\n  = function() %7B%0A\n+%09\n %09var nextSibling\n@@ -15486,32 +15486,33 @@\n blingDomNode();%0A\n+%09\n %09this.removeChil\n@@ -15516,32 +15516,33 @@\n hildDomNodes();%0A\n+%09\n %09this.render(thi\n@@ -15563,39 +15563,43 @@\n e,nextSibling);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Refresh all the \n@@ -15611,35 +15611,37 @@\n ren of a widget%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -15687,47 +15687,36 @@\n lers) %7B%0A\n+%09\n %09var \n-children = this.children\n+self = this\n ,%0A\n+%09\n %09%09refres\n@@ -15729,60 +15729,71 @@\n false;%0A%09\n-for (var i = 0; i %3C children.length; i++\n+%09$tw.utils.each(this.children,function(childWidget\n ) %7B%0A\n+%09\n %09%09refres\n@@ -15803,22 +15803,22 @@\n  = child\n-ren%5Bi%5D\n+Widget\n .refresh\n@@ -15842,34 +15842,38 @@\n  %7C%7C refreshed;%0A%09\n-%7D\n+%09%7D);\n %0A\n+%09\n %09return refreshe\n@@ -15867,39 +15867,43 @@\n turn refreshed;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Find the next si\n@@ -16052,35 +16052,37 @@\n parent DOM node%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -16122,32 +16122,33 @@\n n(startIndex) %7B%0A\n+%09\n %09// Refer to thi\n@@ -16189,32 +16189,33 @@\n arents children%0A\n+%09\n %09var parent = th\n@@ -16225,32 +16225,33 @@\n parentWidget,%0A%09%09\n+%09\n index = startInd\n@@ -16305,32 +16305,33 @@\n .indexOf(this);%0A\n+%09\n if(index === -1)\n@@ -16325,32 +16325,33 @@\n index === -1) %7B%0A\n+%09\n %09throw %22node not\n@@ -16371,34 +16371,36 @@\n ents children%22;%0A\n+%09\n %7D%0A\n+%09\n %09// Look for a D\n@@ -16421,32 +16421,33 @@\n  later siblings%0A\n+%09\n %09while(++index %3C\n@@ -16465,32 +16465,33 @@\n ldren.length) %7B%0A\n+%09\n %09%09var domNode = \n@@ -16527,46 +16527,48 @@\n rstDomNode();%0A%09%09\n+%09\n if(domNode) %7B%0A\n+%09\n %09%09%09return domNod\n@@ -16564,37 +16564,40 @@\n turn domNode;%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%7D%0A\n+%09\n %09// Go back and \n@@ -16661,32 +16661,33 @@\n parent dom node%0A\n+%09\n %09var grandParent\n@@ -16702,32 +16702,33 @@\n t.parentWidget;%0A\n+%09\n %09if(grandParent \n@@ -16771,32 +16771,33 @@\n entDomNode) %7B%0A%09%09\n+%09\n index = grandPar\n@@ -16818,32 +16818,33 @@\n ndexOf(parent);%0A\n+%09\n %09%09if(index !== -\n@@ -16843,32 +16843,33 @@\n ex !== -1) %7B%0A%09%09%09\n+%09\n return parent.fi\n@@ -16897,44 +16897,51 @@\n index);%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%7D%0A\n+%09\n %09return null;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Find the\n@@ -16986,35 +16986,37 @@\n or its children%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -17040,32 +17040,33 @@\n  = function() %7B%0A\n+%09\n %09// Return the f\n@@ -17104,32 +17104,33 @@\n f we've got one%0A\n+%09\n %09if(this.domNode\n@@ -17139,32 +17139,33 @@\n length %3E 0) %7B%0A%09%09\n+%09\n return this.domN\n@@ -17165,35 +17165,37 @@\n is.domNodes%5B0%5D;%0A\n+%09\n %09%7D%0A\n+%09\n %09// Otherwise, r\n@@ -17215,32 +17215,33 @@\n ll our children%0A\n+%09\n %09for(var t=0; t%3C\n@@ -17263,32 +17263,33 @@\n ength; t++) %7B%0A%09%09\n+%09\n var domNode = th\n@@ -17317,46 +17317,48 @@\n rstDomNode();%0A%09%09\n+%09\n if(domNode) %7B%0A\n+%09\n %09%09%09return domNod\n@@ -17360,44 +17360,51 @@\n omNode;%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%7D%0A\n+%09\n %09return null;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Remove a\n@@ -17447,35 +17447,37 @@\n or its children%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -17504,32 +17504,33 @@\n  = function() %7B%0A\n+%09\n %09// If this widg\n@@ -17691,32 +17691,33 @@\n lly be the case%0A\n+%09\n %09if(this.domNode\n@@ -17724,32 +17724,33 @@\n s.length %3E 0) %7B%0A\n+%09\n %09%09$tw.utils.each\n@@ -17776,32 +17776,33 @@\n tion(domNode) %7B%0A\n+%09\n %09%09%09domNode.paren\n@@ -17823,36 +17823,38 @@\n ild(domNode);%0A%09%09\n+%09\n %7D);%0A\n+%09\n %09%09this.domNodes \n@@ -17851,42 +17851,44 @@\n .domNodes = %5B%5D;%0A\n+%09\n %09%7D else %7B%0A\n+%09\n %09%09// Otherwise, \n@@ -17929,32 +17929,33 @@\n eir DOM nodes%0A%09%09\n+%09\n $tw.utils.each(t\n@@ -17983,32 +17983,33 @@\n (childWidget) %7B%0A\n+%09\n %09%09%09childWidget.r\n@@ -18032,30 +18032,36 @@\n es();%0A%09%09\n+%09\n %7D);%0A\n+%09\n %09%7D%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Invoke t\n@@ -18114,35 +18114,37 @@\n current widget.%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -18187,32 +18187,33 @@\n Widget,event) %7B%0A\n+%09\n %09var handled = f\n@@ -18210,32 +18210,33 @@\n andled = false;%0A\n+%09\n %09// For each chi\n@@ -18237,32 +18237,33 @@\n ch child widget%0A\n+%09\n %09for(var t=0; t%3C\n@@ -18283,32 +18283,33 @@\n .length; t++) %7B%0A\n+%09\n %09%09var child = th\n@@ -18318,32 +18318,33 @@\n .children%5Bt%5D;%0A%09%09\n+%09\n // Invoke the ch\n@@ -18365,32 +18365,33 @@\n n action widget%0A\n+%09\n %09%09if(child.invok\n@@ -18396,32 +18396,33 @@\n okeAction) %7B%0A%09%09%09\n+%09\n child.refreshSel\n@@ -18418,32 +18418,33 @@\n .refreshSelf();%0A\n+%09\n %09%09%09if(child.invo\n@@ -18483,41 +18483,45 @@\n ) %7B%0A%09%09%09%09\n+%09\n handled = true;%0A\n+%09\n %09%09%09%7D%0A%09%09\n+%09\n %7D%0A\n+%09\n %09%09// Pro\n@@ -18562,32 +18562,33 @@\n f it permits it%0A\n+%09\n %09%09if(child.allow\n@@ -18660,39 +18660,43 @@\n )) %7B%0A%09%09%09\n+%09\n handled = true;%0A\n+%09\n %09%09%7D%0A\n+%09\n %09%7D%0A\n+%09\n %09return \n@@ -18704,23 +18704,27 @@\n andled;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n /*%0A\n+%09\n Invoke t\n@@ -18753,35 +18753,37 @@\n ned in a string%0A\n+%09\n */%0A\n+%09\n Widget.prototype\n@@ -18849,32 +18849,33 @@\n nt,variables) %7B%0A\n+%09\n %09actions = actio\n@@ -18876,32 +18876,33 @@\n  actions %7C%7C %22%22;%0A\n+%09\n %09var parser = th\n@@ -18946,32 +18946,33 @@\n i%22,actions,%7B%0A%09%09%09\n+%09\n parentWidget: th\n@@ -18967,32 +18967,33 @@\n ntWidget: this,%0A\n+%09\n %09%09%09document: thi\n@@ -19003,24 +19003,26 @@\n ocument%0A\n+%09\n %09%09%7D),%0A%09%09\n+%09\n widgetNo\n@@ -19051,32 +19051,33 @@\n get(parser,%7B%0A%09%09%09\n+%09\n parentWidget: th\n@@ -19072,32 +19072,33 @@\n ntWidget: this,%0A\n+%09\n %09%09%09document: thi\n@@ -19104,32 +19104,33 @@\n is.document,%0A%09%09%09\n+%09\n variables: varia\n@@ -19126,38 +19126,40 @@\n bles: variables%0A\n+%09\n %09%09%7D);%0A\n+%09\n %09var container =\n@@ -19187,32 +19187,33 @@\n Element(%22div%22);%0A\n+%09\n %09widgetNode.rend\n@@ -19224,32 +19224,33 @@\n ontainer,null);%0A\n+%09\n %09return widgetNo\n@@ -19271,36 +19271,39 @@\n ns(this,event);%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n Widget.prototype\n@@ -19341,34 +19341,38 @@\n ion() %7B%0A\n+%09\n %09return true;%0A\n+%09\n %7D;%0A\n-%0A\n+%09%0A%09\n exports.\n@@ -19388,15 +19388,18 @@\n Widget;%0A\n-%0A\n+%09%0A%09\n %7D)();%0A\n+%09\n"
        }
    }
}