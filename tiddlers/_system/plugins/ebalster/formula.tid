created: 20171209233132315
description: Spreadsheet-like formulas in TiddlyWiki.
modified: 20171213050502378
name: TiddlyFormula
plugin-type: plugin
tags: 
title: $:/plugins/ebalster/formula
type: application/json
version: 0.0.2

{
    "tiddlers": {
        "$:/plugins/ebalster/formula/compile.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Values    = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Operands  = require(\"$:/plugins/ebalster/formula/operands.js\");\nvar Operators = require(\"$:/plugins/ebalster/formula/operators.js\");\n\nvar rxDatumIsFormula      = /^\\s*\\(=.*=\\)\\s*$/;\nvar rxDatumIsDecimal      = /^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/;\n\nvar rxSkipWhitespace    = /\\s*/g;\nvar rxOperandFilter     = /\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]/g;\nvar rxOperandTransclusion =     /\\{\\{[^\\{\\}]+\\}\\}/g;\nvar rxDatumIsTransclusion = /^\\s*\\{\\{[^\\{\\}]+\\}\\}\\s*$/;\nvar rxOperandVariable     =     /<<[^<>]+>>/g;\nvar rxDatumIsVariable     = /^\\s*<<[^<>]+>>\\s*$/;\nvar rxIdentifier          = /[_a-zA-Z][_a-zA-Z0-9]*/g;\n\nvar rxUnsignedDecimal =      /((\\d+(\\.\\d*)?)|(\\.\\d+))/g\nvar rxDecimal         = /[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))/g\n\nvar rxString          = /(\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*')/g\n\nvar formulaFunctions   = null;\nvar operatorsUnaryPre  = null;\nvar operatorsUnaryPost = null;\nvar operatorsBinary    = null;\nvar operatorsTernary   = null;\n\nfunction Parser(src)\n{\n  this.src = src;\n  this.pos = 0;\n  this.end = src.length;\n}\nParser.prototype.getChar = function()\n{\n  return this.src.charAt(this.pos);\n}\nParser.prototype.remaining = function()\n{\n  return this.src.substring(this.pos, this.end);\n}\nParser.prototype.match_here = function(regex)\n{\n  // TODO this is doing much more work than is necessary\n  regex.lastIndex = this.pos;\n  var result = regex.exec(this.src);\n  if (!result || result.index != this.pos) return null;\n  this.pos = regex.lastIndex;\n  return result;\n}\nParser.prototype.skipWhitespace = function()\n{\n  rxSkipWhitespace.lastIndex = this.pos;\n  rxSkipWhitespace.test(this.src);\n  this.pos = rxSkipWhitespace.lastIndex;\n}\n\nvar initialize = function() {\n  formulaFunctions = {};\n  var operators = {}\n  $tw.modules.applyMethods(\"formula-function\", formulaFunctions);\n  $tw.modules.applyMethods(\"formula-operator\", operators);\n\n  operatorsUnaryPre = {};\n  operatorsUnaryPost = {};\n  operatorsBinary = {}; //{}; //{plus: {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"}};\n  operatorsTernary = {};\n  for (var opName in operators)\n  {\n    var op = operators[opName];\n\n    // Bind the associated function.  \n    var func = formulaFunctions[op.function];\n    if (!func) continue;\n    op.func_bind = func;\n\n    // Sort the op by arity and position.\n    switch (op.arity)\n    {\n    case 2:           operatorsBinary  [opName] = op; break;\n    case 3:           operatorsTernary [opName] = op; break;\n    case 1:\n      switch (op.position)\n      {\n        case \"pre\":  operatorsUnaryPre [opName] = op; break;\n        case \"post\": operatorsUnaryPost[opName] = op; break;\n      }\n      break;\n    }\n  }\n}\n\n\nexports.compileExpression = function(expression) {\n\n  // Create a parser and process the formula as an expression.\n  var parser = new Parser(expression);\n\n  var operand = buildExpression(parser);\n\n  return operand;\n};\n\nexports.compileDatum = function(datum) {\n\n  // Could be a number?\n  if (rxDatumIsDecimal.test(datum)) {\n    // Treat as a number constant\n    return new Operands.Number_Constant(Number(datum));\n  }\n\n  // Could be a formula?\n  if (rxDatumIsFormula.test(datum)) {\n    // Parse contents as a formula\n    var parser = new Parser(datum);\n    parser.pos = datum.indexOf(\"=\")+1;\n    parser.end = datum.lastIndexOf(\"=\");\n    return buildExpression(parser);\n  }\n\n  // Could be a transclusion or variable?\n  if (rxDatumIsTransclusion.test(datum) ||\n      rxDatumIsVariable.test(datum)) {\n    // Defer to the operand parser...\n    var parser = new Parser(datum);\n    return buildOperand(parser);\n  }\n\n  // Otherwise, treat as a string constant\n  return new Operands.String_Constant(datum);\n};\n\nexports.compileFormula = function(formulaString)\n{\n  // Process the formula string into a root operand\n  try\n  {\n    return exports.compileExpression(formulaString);\n  }\n  catch (err)    {return new Operands.String_Constant(\"`FormulaError: \" + err + \"`\");}\n}\n\nexports.computeFormula = function(compiledFormula, widget, numberFormat=null, debug=false) {\n  \n  var value;\n\n  Values.NumberFormatFunc = numberFormat;\n\n  // Compute a value from the root operand of the compiled formula.\n  try\n  {\n    value = compiledFormula.compute(widget, 0);\n  }\n  catch (err)    {return \"`ComputeError: \" + String(err) + \"\\noperand: \" + String(compiledFormula) + \"`\";}\n\n  // Format the root operand as a string.\n  try\n  {\n    if (debug) return value.asString() + \"\\n - Val:\" + String(value) + \", Op:\" + compiledFormula.name;\n    else       return value.asString();\n  }\n  catch (err)    {return \"`ValueError: \" + String(err) + \"\\nvalue: \" + String(value) + \"`\";}\n};\n\nexports.evalFormula = function(formulaString, widget, numberFormat=null, debug=false) {\n  \n  var compiledFormula;\n\n  // Compile the formula\n  try\n  {\n    var compiledFormula = exports.compileExpression(formulaString);\n  }\n  catch (err)    {return \"`FormulaError: \" + String(err) + \"`\";}\n\n  // Compute the formula\n  return exports.computeFormula(compiledFormula, widget, numberFormat, debug);\n};\n\n\n\n// Compile an operator\nfunction parseOperator(parser, operatorGroup) {\n\n  // Skip more whitespace\n  parser.skipWhitespace();\n\n  var result = null;\n\n  // Find the longest operator matching the current text.\n  for (var opName in operatorGroup)\n  {\n    var op = operatorGroup[opName];\n    if (parser.src.substr(parser.pos, op.operator.length) == op.operator)\n    {\n      if (!result || result.operator.length < op.operator.length) result = op;\n    }\n  }\n\n  if (result) parser.pos += result.operator.length;\n\n  return result;\n}\n\n// Parse a formula.\nfunction buildExpression(parser, nested = false) {\n  \n  // Make sure math functions are initialized\n  if (!formulaFunctions) initialize();\n\n  parser.skipWhitespace();\n\n  var operands = [];\n  var operators = [];\n  var precedences = [];\n\n  while (true)\n  {\n    var unaries = [];\n\n    // Prefix operators\n    while (true)\n    {\n      var prefix = parseOperator(parser, operatorsUnaryPre);\n      if (prefix) unaries.unshift(prefix);\n      else break;\n    }\n\n    // Grab the operand\n    var operand = buildOperand(parser);\n\n    // Missing operand is an error\n    if (operand === null)\n    {\n      if (operands.length) throw \"missing operand after \\:\" + operators[operators.length-1].operator + \"\\\"\";\n      else                 throw \"empty expression\";\n    }\n\n    // Postfix operators\n    while (true)\n    {\n      var postfix = parseOperator(parser, operatorsUnaryPost);\n      if (postfix) unaries.push(postfix);\n      else break;\n    }\n\n    unaries.forEach(function(unary) {\n      operand = new Operators.CallOperator(unary.func_bind, [operand]);\n    });\n\n    operands.push(operand);\n\n    // Infix operators\n    var operator = parseOperator(parser, operatorsBinary);\n\n    // Missing operator ends the expression\n    if (operator === null) break;\n\n    // Add the operator and its precedence level.\n    operators.push(operator);\n    var precedence = operator.precedence;\n    if (precedences.indexOf(precedence || 0) == -1) precedences.push(precedence);\n  }\n\n  // Sanity check\n  if (operands.length != operators.length+1)\n    throw \"internal error: operator/operand parsing inconsistency\";\n\n  // Resolve operators by precedence\n  precedences.sort(function(a,b) {return (a>b)?-1:1;});\n\n  for (var j = 0; j < precedences.length; ++j)\n  {\n    var prec = precedences[j];\n    for (var i = 0; i < operators.length; )\n    {\n      // Process only operators at the current precedence level.\n      var op = operators[i];\n      if (op.precedence != prec) {++i; continue;}\n\n      // Collapse the previous and next operands with this operator.\n      operands[i] = new Operators.CallOperator(op.func_bind, [operands[i], operands[i+1]]);\n      operators.splice(i, 1);\n      operands.splice(i+1, 1);\n    }\n  }\n\n  // Sanity check\n  if (operators.length != 0 || operands.length != 1)\n    throw \"internal error: resoving failed; \" + operands.length + \" operands and \" + operators.length + \" operators remain\";\n\n  // For non-nested expressions, throw if any tokens remain.\n  if (!nested)\n  {\n    parser.skipWhitespace();\n\n    if (parser.pos < parser.end)\n    {\n      throw \"expected an operator: \\\"\" + parser.remaining() + \"\\\"\";\n    }\n  }\n\n  return operands[0];\n};\n\n// Compile a function argument list.  Error if the next \nfunction buildArguments(parser) {\n\n  // Skip whitespace\n  parser.skipWhitespace();\n\n  if (parser.getChar() != \"(\") throw \"Expect '(' after function name\";\n  ++parser.pos;\n  \n  var results = [];\n\n  while (true)\n  {\n    // Compile an expression.\n    results.push(buildExpression(parser, true));\n\n    // Skip more whitespace\n    parser.skipWhitespace();\n\n    // Expect ) or , after argument.\n    var char = parser.getChar();\n    ++parser.pos;\n    if (char == \")\") break;\n    if (char != \",\") throw \"Expect ',' or ')' after function argument\";\n  }\n\n  return results;\n};\n\n// Compile an operand into a function returning the operand value.  Filter operands return an array.\nfunction buildOperand(parser) {\n\n  var term;\n  \n  // Skip whitespace\n  parser.skipWhitespace();\n\n  if (parser.pos == parser.end) return null;\n\n  var char = parser.getChar();\n\n  if (char.match(/[0-9\\.+=]/i))\n  {\n    // Number constant\n    term = parser.match_here(rxDecimal);\n    if (term) return new Operands.Number_Constant(Number(term[0]));\n    throw \"Invalid number: \" + parser.remaining();\n  }\n  else if (char.match(/[a-z]/i))\n  {\n    // Function call\n    term = parser.match_here(rxIdentifier);\n\n    if (term)\n    {\n      term = term[0].toLowerCase();\n      var func = formulaFunctions[term];\n\n      if (!func) throw \"unknown function: \" + term;\n\n      var args = buildArguments(parser);\n\n      if (args.length > func.length) throw \"too many arguments for \" + term;\n      if (args.length < func.length) throw \"too few arguments for \" + term;\n\n      return new Operators.CallOperator(func, args);\n    }\n  }\n  else switch (char)\n  {\n  case \"(\": // Parenthesized expression\n    ++parser.pos;\n    var parentheses = buildExpression(parser, true);\n    parser.skipWhitespace();\n    if (parser.getChar() != \")\")\n    {\n      if (parser.pos == parser.end) throw \"missing ')' at end of formula\";\n      else                          throw \"expected ')' here: \\\"\" + parser.remaining() + \"\\\"\";\n    }\n    ++parser.pos;\n    return parentheses;\n    break;\n\n  case \"'\":\n  case \"\\\"\": // String constant\n    term = parser.match_here(rxString);\n    if (term) return new Operands.String_Constant(term[0].substr(1, term[0].length-2));\n    throw \"Invalid string: \" + parser.remaining();\n    break;\n\n  case \"[\": // Filter operand\n    term = parser.match_here(rxOperandFilter);\n    if (term) return new Operands.Filter(term[0]);\n    break;\n\n  case \"{\": // Transclude operand\n    term = parser.match_here(rxOperandTransclusion);\n    if (term) return new Operands.Transclude(term[0].substring(2, term[0].length-2));\n    break;\n\n  case \"<\": // Variable operand\n    term = parser.match_here(rxOperandVariable);\n    if (term) return new Operands.Variable(term[0].substring(2, term[0].length-2));\n    break;\n  }\n\n  // Otherwise, constant operand\n  throw \"unrecognized operand: '\" + parser.remaining() + \"'\";\n  //return new Operands.Constant(\"K: \" + expr + \" (#\"+String(parser.pos)+\")\");\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/compile.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211181652443",
            "description": "",
            "created": "20171210195223539"
        },
        "$:/plugins/ebalster/formula/functions/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Ops = require(\"$:/plugins/ebalster/formula/operands.js\");\n\n\n// Unary sign operators\nexports.uplus  = function(a)    {return new Val.Value_Number(+a.asNumber_sum());};\nexports.uminus = function(a)    {return new Val.Value_Number(-a.asNumber_sum());};\n\n// Sum\nexports.sum = function(a)       {return new Val.Value_Number(a.asNumber_sum());};\n\n// Add\nexports.add = function(a, b)    {return new Val.Value_Number(a.asNumber_sum() + b.asNumber_sum());};\nexports.sub = function(a, b)    {return new Val.Value_Number(a.asNumber_sum() - b.asNumber_sum());};\n\n// Multiply\nexports.mul = function(a, b)    {return new Val.Value_Number(a.asNumber() * b.asNumber());};\nexports.div = function(a, b)    {return new Val.Value_Number(a.asNumber() / b.asNumber());};\n\n// Exponential\nexports.pow = function(a, b)    {return new Val.Value_Number(Math.pow(a.asNumber(), b.asNumber()));};\n\n// Percent -- TODO make this a different value-type\nexports.percent = function(a, b)    {return new Val.Value_Number(a.asNumber() * 100);};\n\n\n// Aliases\nexports.subtract = exports.sub;\nexports.multiply = exports.mul;\nexports.divide   = exports.div;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/arithmetic.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171212223526867",
            "created": "20171211192843088"
        },
        "$:/plugins/ebalster/formula/functions/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Ops = require(\"$:/plugins/ebalster/formula/operands.js\");\n\n\n// Concatenate\nexports.cat = function(a, b)    {return new Val.Value_String(a.asString() + b.asString());};\n\n\n// Aliases\nexports.concatenate = exports.cat;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/strings.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171213003237206",
            "created": "20171213003135495"
        },
        "$:/plugins/ebalster/formula/macros/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\n  Information about this macro\n*/\n\nexports.name = \"formula\";\nexports.params = [{\"name\": \"formula\"}];\n\n/*\nRun the macro\n*/\nexports.run = function(formula) {\n\n  var formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n  return formulas.evalFormula(formula, this);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/macros/formula.js",
            "tags": "",
            "module-type": "macro",
            "modified": "20171212194124031",
            "created": "20171210215758530"
        },
        "$:/plugins/ebalster/formula/operands.js": {
            "text": "/*\\\ntitle: $:/core/modules/macros/csvtiddlers.js\ntype: application/javascript\nmodule-type: macro\n\nLibrary defining formula operands.\nOperands represent some value within the formula: an expression, datum, operator, constant or query...\nOperands may be constant, allowing the formula compiler to optimize them away.\n\n\\*/\n(function(){\n\n\"use strict\";\n\nvar Values   = require(\"$:/plugins/ebalster/formula/value.js\");\n\nexports.Operand = function() {\n}\nexports.Operand.prototype.is_constant = false;\nexports.Operand.prototype.name = \"unknown-operand\";\n\n// Operand::compute -- produce\nexports.Operand.prototype.compute = (function(widget, recur) {return new Values.Value_Undefined();});\n\n\n// String constant operand.\nexports.String_Constant = function(value) {\n  this.value = value;\n}\nexports.String_Constant.prototype = new exports.Operand();\nexports.String_Constant.prototype.name = \"string\";\nexports.String_Constant.prototype.is_constant = true;\n\nexports.String_Constant.prototype.compute = function(widget, recur)\n{\n  // Returns a string value\n  return new Values.Value_String(this.value);\n}\n\n\n// Number constant operand.\nexports.Number_Constant = function(value) {\n  this.value = value;\n}\nexports.Number_Constant.prototype = new exports.Operand();\nexports.Number_Constant.prototype.name = \"number\";\nexports.Number_Constant.prototype.is_constant = true;\n\nexports.Number_Constant.prototype.compute = function(widget, recur)\n{\n  // Returns a number value\n  return new Values.Value_Number(this.value);\n}\n\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n\n// Transcluded operand.\nexports.Transclude = function(textReference) {\n  this.textReference = textReference;\n  this.datum = null;\n  this.op = null;\n}\nexports.Transclude.prototype = new exports.Operand();\nexports.Transclude.prototype.name = \"transclude\";\n\nexports.Transclude.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.wiki.getTextReference(this.textReference, \"\", widget.getVariable(\"currentTiddler\"));\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    this.op = Compile.compileDatum(newDatum);\n  }\n\n  return this.op.compute(widget, recur+1);\n}\n\n\n// Variable operand.\nexports.Variable = function(variable) {\n  this.variable = variable;\n  this.datum = null;\n  this.op = null;\n}\nexports.Variable.prototype = new exports.Operand();\nexports.Variable.prototype.name = \"variable\";\n\nexports.Variable.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.getVariable(this.variable) || \"\";\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    this.op = Compile.compileDatum(newDatum);\n  }\n\n  return this.op.compute(widget, recur+1);\n}\n\n\n// Filter operand.\nexports.Filter = function(filter) {\n  this.filter = filter;\n  this.elements = {};\n}\nexports.Filter.prototype = new exports.Operand();\nexports.Filter.prototype.name = \"filter\";\n\nexports.Filter.prototype.compute = function(widget, recur) {\n  // Apply the filter and compile each result\n  var exprs = widget.wiki.filterTiddlers(this.filter, widget);\n\n  // Mark all existing elements for removal\n  for (var expr in this.elements) this.elements[expr].count = 0;\n\n  // Selectively re-compile any filter results that have changed\n  for (var i = 0; i < exprs.length; ++i)\n  {\n    var expr = exprs[i];\n    var found = this.elements[expr];\n    if (found) ++found.count;\n    else this.elements[expr] = {count: 1, op: Compile.compileDatum(expr)};\n  }\n\n  // Delete any elements with no copies left\n  for (var expr in this.elements) if (this.elements[expr].count == 0) delete this.elements[expr];\n\n  // Return value computes an array of datum values.\n  var results = [];\n  for (var expr in this.elements) {\n    var elem = this.elements[expr];\n    results.push(elem.op.compute(widget, recur+1));\n  }\n  return new Values.Value_Array(results);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operands.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183031273",
            "description": "",
            "created": "20171211183000431"
        },
        "$:/plugins/ebalster/formula/operators.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Values   = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\n\nexports.Operator = function Operator() {\n}\nexports.Operator.prototype.name = \"unknown-operator\";\nexports.Operator.prototype = new Operands.Operand();\n\n/*\nexports.UnaryOperator = function UnaryOperator() {\n  this.first = null;\n}\nexports.UnaryOperator.prototype = new exports.Operator();\nexports.UnaryOperator.prototype.name = \"unknown-unary-operator\";\n\n\nexports.BinaryOperator = function BinaryOperator() {\n  this.first = null;\n  this.second = null;\n}\nexports.BinaryOperator.prototype = new exports.Operator();\nexports.BinaryOperator.prototype.name = \"unknown-binary-operator\";\n*/\n\nexports.CallOperator = function CallOperator(func, args) {\n  this.func = func;\n  this.args = args;\n}\nexports.CallOperator.prototype = new exports.Operator();\nexports.CallOperator.prototype.name = \"function-call\";\nexports.CallOperator.prototype.compute = (function(widget, recur) {\n  var vals = [];\n  this.args.forEach(function(arg) {vals.push(arg.compute(widget, recur));});\n  return this.func.apply(null, vals);\n});\n\n/*\nexports.BinaryMathOperator = function BinaryMathOperator() {\n}\nexports.BinaryMathOperator.prototype = new exports.BinaryOperator();\nexports.BinaryMathOperator.prototype.name = \"unknown-binary-math-operator\";\nexports.BinaryMathOperator.prototype.compute = (function(widget, recur) {\n  return mathOp(this.first.compute(widget, recur).asNumber(), this.first.compute(widget, recur).asNumber());\n});\n\n\n// Identity operator (used for unary plus)\nexports.Operator_UnaryPlus = function Operator_UnaryPlus(first) {this.first = first;}\nexports.Operator_UnaryPlus.prototype = new exports.UnaryOperator();\nexports.Operator_UnaryPlus.prototype.name = \"unary-plus\";\nexports.Operator_UnaryPlus.prototype.compute = function(widget, recur) {return +this.first.compute(widget, recur).asNumber_sum();}\n\n// Negation operator (used for unary minus)\nexports.Operator_UnaryMinus = function Operator_UnaryMinus(first) {this.first = first;}\nexports.Operator_UnaryMinus.prototype = new exports.UnaryOperator();\nexports.Operator_UnaryMinus.prototype.name = \"unary-minus\";\nexports.Operator_UnaryMinus.prototype.compute = function(widget, recur) {return -this.first.compute(widget, recur).asNumber_sum();}\n\n\n// Addition operator\nexports.Operator_Plus = function Operator_Plus(first, second) {this.first = first; this.second = second;}\nexports.Operator_Plus.prototype = new exports.BinaryMathOperator();\nexports.Operator_Plus.prototype.name = \"plus\";\nexports.Operator_Plus.prototype.mathOp = function(a, b) {return a+b;}\n\n// Subtraction operator\nexports.Operator_Minus = function Operator_Minus(first, second) {this.first = first; this.second = second;}\nexports.Operator_Minus.prototype = new exports.BinaryMathOperator();\nexports.Operator_Minus.prototype.name = \"minus\";\nexports.Operator_Minus.prototype.mathOp = function(a, b) {return a-b;}\n\n// Multiplication operator\nexports.Operator_Multiply = function Operator_Multiply(first, second) {this.first = first; this.second = second;}\nexports.Operator_Multiply.prototype = new exports.BinaryMathOperator();\nexports.Operator_Multiply.prototype.name = \"multiply\";\nexports.Operator_Multiply.prototype.mathOp = function(a, b) {return a*b;}\n\n// Division operator\nexports.Operator_Divide = function Operator_Divide(first, second) {this.first = first; this.second = second;}\nexports.Operator_Divide.prototype = new exports.BinaryMathOperator();\nexports.Operator_Divide.prototype.name = \"divide\";\nexports.Operator_Divide.prototype.mathOp = function(a, b) {return a/b;}\n\n// Division operator\nexports.Operator_Exponent = function Operator_Exponent(first, second) {this.first = first; this.second = second;}\nexports.Operator_Exponent.prototype = new exports.BinaryMathOperator();\nexports.Operator_Exponent.prototype.name = \"exponent\";\nexports.Operator_Exponent.prototype.mathOp = function(a, b) {return Math.pow(a, b);}\n*/\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183054390",
            "description": "",
            "created": "20171211183047843"
        },
        "$:/plugins/ebalster/formula/operators/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Unary sign operators\nexports.uplus    = {arity: 1, position: \"pre\",  operator: \"+\", function: \"uplus\"};\nexports.uminus   = {arity: 1, position: \"pre\",  operator: \"-\", function: \"uminus\"};\n\n// Add\nexports.plus     = {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"};\nexports.minus    = {arity: 2, precedence: 10,   operator: \"-\", function: \"sub\"};\n\n// Multiply\nexports.multiply = {arity: 2, precedence: 20,   operator: \"*\", function: \"mul\"};\nexports.divide   = {arity: 2, precedence: 20,   operator: \"/\", function: \"div\"};\n\n// Exponential\nexports.pow      = {arity: 2, precedence: 30,   operator: \"^\", function: \"pow\", associativity: \"right\"};\n\n// Percentage\nexports.percent  = {arity: 1, position: \"post\", operator: \"%\", function: \"percent\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/arithmetic.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171212223539769",
            "created": "20171212223503019"
        },
        "$:/plugins/ebalster/formula/operators/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Concatenate\nexports.concatenate = {arity: 2, precedence: 4, operator: \"&\", function: \"cat\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/strings.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171213003346943",
            "created": "20171213003246267"
        },
        "$:/plugins/ebalster/formula/value.js": {
            "text": "(function(){\n\n\"use strict\";\n\n\nexports.NumberFormatFunc = null;\n\n\n// Base type for formula values\nexports.Value = function() {\n  this.name = \"unknown-value\";\n}\n\n// Get the value payload\nexports.Value.prototype.get = function()    {return undefined;};\n\n// Describe the value\nexports.Value.prototype.describe = function()    {return this.name + \" (\" + String(this.get()) + \")\";}\n\nexports.Value.prototype.toString = function()    {return \"[Value \" + this.describe() + \"]\";}\n\n// Get the value as a number (generic implementation)\nexports.Value.prototype.asNumber = function() {\n  var v = this.get();\n  var n = Number(v);\n  if (isNaN(n)) throw \"Cannot convert \" + this.describe() + \" to a number!\";\n  return n;\n}\n\n// Get the value as a number, summing arrays (generic implementation)\nexports.Value.prototype.asNumber_sum = function() {\n  var v = this.get();\n  var n;\n  if (Array.isArray(v)) {n = 0; for (var i = 0; i < v.length; ++i) n += Number(v[i]);}\n  else                  n = Number(v);\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n}\n\n// Get the value as a string\nexports.Value.prototype.asString = function() {\n  return String(this.get());\n}\n\n// Get the value as an array\nexports.Value.prototype.asArray = function() {\n  var v = this.get();\n  if (Array.isArray(v)) return v;\n  else return [v];\n}\n\n\n// Undefined value.\nexports.Value_Undefined = function() {\n  this.name = \"undefined\";\n}\nexports.Value_Undefined.prototype = new exports.Value();\nexports.Value_Undefined.prototype.get = function()    {throw \"undefined value\";}\n\n\n// String value.\nexports.Value_String = function(value) {\n  this.name = \"string\";\n\n  this.value = value;\n}\nexports.Value_String.prototype = new exports.Value();\nexports.Value_String.prototype.get = function()    {return this.value;}\n\n\n// Array value.\nexports.Value_Array = function(value) {\n  this.name = \"array\";\n\n  this.value = value;\n}\nexports.Value_Array.prototype = new exports.Value();\nexports.Value_Array.prototype.get          = function()                {return this.value;}\nexports.Value_Array.prototype.asNumber     = function()                {throw \"Cannot convert \" + this.describe() + \" to number!\";}\nexports.Value_Array.prototype.asNumber_sum = function() {\n  var n = 0;\n  for (var i = 0; i < this.value.length; ++i) n += this.value[i].asNumber();\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n}\nexports.Value_Array.prototype.asString     = function() {\n  var result = \"[\";\n  if (this.value.length) result += this.value[0].asString();\n  for (var i = 1; i < this.value.length; ++i) result += \",\" + this.value[i].asString();\n  return result + \"]\";\n}\n\n\n// Number value.\nexports.Value_Number = function(value) {\n  this.name = \"number\";\n\n  this.value = value;\n}\nexports.Value_Number.prototype = new exports.Value();\nexports.Value_Number.prototype.get          = function()    {return this.value;}\nexports.Value_Number.prototype.asString     = function()    {return (exports.NumberFormatFunc || String)(this.value);}\nexports.Value_Number.prototype.asNumber     = function()    {return this.value;}\nexports.Value_Number.prototype.asNumber_sum = function()    {return this.value;}\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/value.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211195014088",
            "description": "",
            "created": "20171211195003728"
        },
        "$:/plugins/ebalster/formula/widgets/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\n\nvar FormulaWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nFormulaWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar textNode = this.document.createTextNode(this.currentValue);\n\tparent.insertBefore(textNode,nextSibling);\n\tthis.domNodes.push(textNode);\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaWidget.prototype.execute = function() {\n\n\tvar oldFormula = this.formula;\n\n\t// Get parameters from our attributes\n\tthis.formula   = this.getAttribute(\"formula\");\n\tthis.debug     = this.getAttribute(\"debug\");\n\tvar vPrecision = this.getAttribute(\"toPrecision\") || this.getVariable(\"formulaPrecision\");\n\tvar vFixed     = this.getAttribute(\"toFixed\")     || this.getVariable(\"formulaFixed\");\n\n\t// Compile the formula, if it has changed, yielding compiledFormula\n\tif(this.formula !== oldFormula) {\n\t\tif (this.formula) {\n\t\t\tthis.compiledFormula = Formulas.compileFormula(this.formula);\n\t\t}\n\t\telse {\n\t\t\tthis.compiledFormula = null;\n\t\t}\n\t}\n\n\t// Compute the formula, yielding currentValue\n\tif(this.compiledFormula) {\n\t\tvar numberFormat = null;\n\t\tif      (vFixed    ) numberFormat = function(num) {return num.toFixed    (vFixed);};\n\t\telse if (vPrecision) numberFormat = function(num) {return num.toPrecision(vPrecision);};\n\t\tthis.currentValue = Formulas.computeFormula(this.compiledFormula, this, numberFormat, Boolean(this.debug));\n\t} else {\n\t\tthis.currentValue = \"`Error: formula not assigned`\";\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nFormulaWidget.prototype.refresh = function(changedTiddlers) {\n\t// Re-execute the filter to get the count\n\tthis.computeAttributes();\n\tvar oldValue = this.currentValue;\n\tthis.execute();\n\tif(this.currentValue !== oldValue) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\n};\n\nexports.formula = FormulaWidget;\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/widgets/formula.js",
            "tags": "",
            "module-type": "widget",
            "modified": "20171212194059701",
            "description": "Evaluates a formula.",
            "created": "20171210232543292"
        },
        "$:/plugins/ebalster/formula/wikiparser/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.name = \"formula\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\t// Regexp to match\n\tthis.matchRegExp = /\\(=/mg;\n\tthis.endMatchRegExp = /=\\)/mg;\n};\n\nexports.parse = function() {\n\t// Move past the match\n\tthis.parser.pos = this.matchRegExp.lastIndex;\n\t// Look for the end marker\n\tthis.endMatchRegExp.lastIndex = this.parser.pos;\n\tvar match = this.endMatchRegExp.exec(this.parser.source),\n\t\ttext;\n\t// Process the text\n\tif(match) {\n\t\ttext = this.parser.source.substring(this.parser.pos,match.index);\n\t\tthis.parser.pos = match.index + match[0].length;\n\t} else {\n\t\ttext = this.parser.source.substr(this.parser.pos);\n\t\tthis.parser.pos = this.parser.sourceLength;\n\t}\n\treturn [{\n\t\ttype: \"formula\",\n\t\tattributes: {\n\t\t\tformula: {type: \"string\", value: text},\n\t\t}\n\t}];\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/wikiparser/formula.js",
            "tags": "",
            "module-type": "wikirule",
            "modified": "20171211181716654",
            "description": "Wiki text inline rule for formulas.  Ex. `((=2+2))`",
            "created": "20171211033327565"
        }
    }
}