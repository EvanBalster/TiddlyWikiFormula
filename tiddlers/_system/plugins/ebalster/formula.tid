created: 20171209233132315
description: Spreadsheet-like formulas in TiddlyWiki.
list: readme settings license
modified: 20171229234918315
name: TiddlyFormula
plugin-type: plugin
tags: 
title: $:/plugins/ebalster/formula
type: application/json
version: 0.1.7

{
    "tiddlers": {
        "$:/plugins/ebalster/formula/compile.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Values    = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Operands  = require(\"$:/plugins/ebalster/formula/operands.js\");\nvar Operators = require(\"$:/plugins/ebalster/formula/operators.js\");\n\nvar rxDatumIsFormula      = /^\\s*\\(=.*=\\)\\s*$/;\nvar rxDatumIsTrue         = /^s*TRUE\\s*$/i;\nvar rxDatumIsFalse        = /^s*FALSE\\s*$/i;\n\nvar rxSkipWhitespace    = /\\s*/g;\nvar rxNotWhitespace     = /[^\\s]+/g;\nvar rxOperandFilter     = /\\[(([^\\[\\]]|\\[[^\\[\\]]*\\])+(\\](\\s*[+-])?\\s*\\[)?)+\\]/g;\nvar rxOperandTransclusion =     /\\{\\{[^\\{\\}]+\\}\\}/g;\nvar rxDatumIsTransclusion = /^\\s*\\{\\{[^\\{\\}]+\\}\\}\\s*$/;\nvar rxOperandVariable     =     /<<[^<>]+>>/g;\nvar rxDatumIsVariable     = /^\\s*<<[^<>]+>>\\s*$/;\nvar rxCellName            = /[a-zA-Z]{1,2}[0-9]+/g;\nvar rxIdentifier          = /[_a-zA-Z][_a-zA-Z0-9]*/g;\n\nvar rxUnsignedDecimal =          /((\\d+(\\.\\d*)?)|(\\.\\d+))/g;\nvar rxDecimal         =     /[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))/g;\nvar rxDatumIsDecimal  = /^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/;\n\nvar rxDate            =     /\\d{2,4}-\\d{2}-\\d{2}(\\s*\\d{1,2}:\\d{2}(:\\d{2}(.\\d+)?)?)?/g;\nvar rxDatumIsDate     = /^\\s*\\d{2,4}-\\d{2}-\\d{2}(\\s*\\d{1,2}:\\d{2}(:\\d{2}(.\\d{3})?)?)?\\s*$/;\nvar rxDateFragment    = /\\d+/g;\n\nvar rxString          = /(\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*')/g;\nvar rxEscapeSequence  = /\\\\([a-tv-z0\"'\\\\]|u[a-fA-F0-9]{0,4}|$)/g;\n\nvar formulaFunctions   = null;\nvar operatorsUnaryPre  = null;\nvar operatorsUnaryPost = null;\nvar operatorsBinary    = null;\nvar operatorsTernary   = null;\n\nfunction Parser(src)\n{\n  this.src = src;\n  this.pos = 0;\n  this.end = src.length;\n}\nParser.prototype.getChar = function()\n{\n  return this.src.charAt(this.pos);\n};\nParser.prototype.remaining = function()\n{\n  return this.src.substring(this.pos, this.end);\n};\nParser.prototype.nextToken = function()\n{\n  rxNotWhitespace.lastIndex = this.pos;\n  rxNotWhitespace.test(this.src);\n  return this.src.substring(this.pos, rxNotWhitespace.lastIndex);\n};\nParser.prototype.match_here = function(regex)\n{\n  // TODO this is doing much more work than is necessary\n  regex.lastIndex = this.pos;\n  var result = regex.exec(this.src);\n  if (!result || result.index != this.pos || result.index+result[0].length > this.end) return null;\n  this.pos = regex.lastIndex;\n  return result;\n};\nParser.prototype.skipWhitespace = function()\n{\n  rxSkipWhitespace.lastIndex = this.pos;\n  rxSkipWhitespace.test(this.src);\n  this.pos = Math.min(rxSkipWhitespace.lastIndex, this.end);\n};\n\nvar initialize = function() {\n  formulaFunctions = {};\n  var operators = {};\n  $tw.modules.applyMethods(\"formula-function\", formulaFunctions);\n  $tw.modules.applyMethods(\"formula-operator\", operators);\n\n  operatorsUnaryPre = {};\n  operatorsUnaryPost = {};\n  operatorsBinary = {}; //{}; //{plus: {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"}};\n  operatorsTernary = {};\n  for (var opName in operators)\n  {\n    var op = operators[opName];\n\n    // Bind the associated function.  \n    var func = formulaFunctions[op.function];\n    if (!func) continue;\n    op.func_bind = func;\n\n    // Sort the op by arity and position.\n    switch (op.arity)\n    {\n    case 2:           operatorsBinary  [opName] = op; break;\n    case 3:           operatorsTernary [opName] = op; break;\n    case 1:\n      switch (op.position)\n      {\n        case \"pre\":  operatorsUnaryPre [opName] = op; break;\n        case \"post\": operatorsUnaryPost[opName] = op; break;\n      }\n      break;\n    }\n  }\n};\n\n\nexports.compileExpression = function(expression) {\n\n  // Create a parser and process the formula as an expression.\n  var parser = new Parser(expression);\n\n  var operand = buildExpression(parser);\n\n  return operand;\n};\n\nexports.compileDatum = function(datum) {\n  \n  var parser;\n\n  // Short-hand formula\n  if (datum.charAt(0) == \"=\") {\n  \tparser = new Parser(datum);\n    parser.pos = 1;\n    return buildExpression(parser);\n  }\n\n  // Could be a number?\n  if (rxDatumIsDecimal.test(datum)) {\n    // Treat as a number constant\n    return new Operands.Opd_Number(Number(datum));\n  }\n\n  // Could be a formula?\n  if (rxDatumIsFormula.test(datum)) {\n    // Parse contents as a formula\n    parser = new Parser(datum);\n    parser.pos = datum.indexOf(\"=\")+1;\n    parser.end = datum.lastIndexOf(\"=\");\n    return buildExpression(parser);\n  }\n\n  // Could be a transclusion or variable?\n  if (rxDatumIsTransclusion.test(datum) ||\n      rxDatumIsVariable.test(datum)) {\n    // Defer to the operand parser...\n    parser = new Parser(datum);\n    return buildOperand(parser);\n  }\n\n  // Booleans?\n  if (rxDatumIsFalse.test(datum)) return new Operands.Opd_Bool(false);\n  if (rxDatumIsTrue .test(datum)) return new Operands.Opd_Bool(true);\n\n  // Date?\n  if (rxDatumIsDate.test(datum))\n  {\n    rxDateFragment.lastIndex = 0;\n    var parts = [];\n    while (true)\n    {\n      var res = rxDateFragment.exec(datum);\n      if (!res) break;\n      parts.push(parseInt(res[0]));\n    }\n    if (parts.length)\n    {\n      return new Operands.Opd_Date(new Date(\n        parts[0], (parts[1] || 1)-1, parts[2] || 1,\n        parts[3] || 0, parts[4] || 0, parts[5] || 0, parts[6] || 0));\n    }\n  }\n\n  // Otherwise, treat as a string constant\n  return new Operands.Opd_Text(datum);\n};\n\nexports.compileFormula = function(formulaString)\n{\n  // Process the formula string into a root operand\n  try\n  {\n    return exports.compileExpression(formulaString);\n  }\n  catch (err)    {return new Operands.Opd_Text(\"`FormulaError: \" + err + \"`\");}\n};\n\nvar numberFormatFixed     = function(vFixed)     {return function(num) {return num.toFixed    (vFixed);};};\nvar numberFormatPrecision = function(vPrecision) {return function(num) {return num.toPrecision(vPrecision);};};\nvar numberFormatSelect    = function(settings)\n{\n  if (!isNaN(settings.fixed))     return numberFormatFixed    (settings.fixed);\n  if (!isNaN(settings.precision)) return numberFormatPrecision(settings.precision);\n  return String;\n};\n\nexports.computeFormula = function(compiledFormula, widget, formatOptions, debug) {\n  \n  var value;\n  \n  formatOptions = formatOptions || {};\n\n  Values.NumberFormatFunc = numberFormatSelect(formatOptions);\n  Values.DateFormat = formatOptions.dateFormat || \"0hh:0mm, DDth MMM YYYY\";\n\n  // Compute a value from the root operand of the compiled formula.\n  try\n  {\n    value = compiledFormula.compute(widget, 0);\n  }\n  catch (err)    {return \"`ComputeError: \" + String(err) + \"\\noperand: \" + String(compiledFormula) + \"`\";}\n\n  // Format the root operand as a string.\n  try\n  {\n    if (debug) return value.asString() + \"\\n - Val:\" + String(value) + \", Op:\" + compiledFormula.name;\n    else       return value.asString();\n  }\n  catch (err)    {return \"`ValueError: \" + String(err) + \"\\nvalue: \" + String(value) + \"`\";}\n};\n\nexports.evalFormula = function(formulaString, widget, formatOptions, debug) {\n  \n  var compiledFormula;\n\n  // Compile the formula\n  try\n  {\n    compiledFormula = exports.compileExpression(formulaString);\n  }\n  catch (err)    {return \"`FormulaError: \" + String(err) + \"`\";}\n\n  // Compute the formula\n  return exports.computeFormula(compiledFormula, widget, formatOptions, debug);\n};\n\n\n\n// Compile an operator\nfunction parseOperator(parser, operatorGroup) {\n\n  // Skip more whitespace\n  parser.skipWhitespace();\n\n  var result = null;\n\n  // Find the longest operator matching the current text.\n  for (var opName in operatorGroup)\n  {\n    var op = operatorGroup[opName];\n    if (parser.src.substr(parser.pos, op.operator.length) == op.operator\n      && parser.pos+op.operator.length <= parser.end)\n    {\n      if (!result || result.operator.length < op.operator.length) result = op;\n    }\n  }\n\n  if (result) parser.pos += result.operator.length;\n\n  return result;\n}\n\n// Parse a formula.\nfunction buildExpression(parser, nested) {\n  \n  // Make sure math functions are initialized\n  if (!formulaFunctions) initialize();\n\n  parser.skipWhitespace();\n\n  var operands = [];\n  var operators = [];\n  var precedences = [];\n  var operand = null;\n  \n  var applyUnary = function(unary) {\n    operand = new Operators.CallOperator(unary.func_bind, [operand]);\n  };\n\n  while (true)\n  {\n    var unaries = [];\n\n    // Prefix operators\n    while (true)\n    {\n      var prefix = parseOperator(parser, operatorsUnaryPre);\n      if (prefix) unaries.unshift(prefix);\n      else break;\n    }\n\n    // Grab the operand\n    operand = buildOperand(parser);\n\n    // Missing operand is an error\n    if (operand === null)\n    {\n      var token = parser.nextToken();\n      if (token && token[0] != \")\" && token[0] != \",\")\n        throw \"invalid operand\\\"\" + token + \"\\\"\";\n      else if (operators.length)\n        throw \"missing operand after \\\"\" + operators[operators.length-1].operator + \"\\\"\";\n      else throw \"empty expression\";\n    }\n\n    // Postfix operators\n    while (true)\n    {\n      var postfix = parseOperator(parser, operatorsUnaryPost);\n      if (postfix) unaries.push(postfix);\n      else break;\n    }\n\n    unaries.forEach(applyUnary);\n\n    operands.push(operand);\n\n    // Infix operators\n    var operator = parseOperator(parser, operatorsBinary);\n\n    // Missing operator ends the expression\n    if (operator === null) break;\n\n    // Add the operator and its precedence level.\n    operators.push(operator);\n    var precedence = operator.precedence;\n    if (precedences.indexOf(precedence || 0) == -1) precedences.push(precedence);\n  }\n\n  // Sanity check\n  if (operands.length != operators.length+1)\n    throw \"internal error: operator/operand parsing inconsistency\";\n\n  // Resolve operators by precedence\n  precedences.sort(function(a,b) {return (a>b)?-1:1;});\n\n  for (var j = 0; j < precedences.length; ++j)\n  {\n    var prec = precedences[j];\n    for (var i = 0; i < operators.length; )\n    {\n      // Process only operators at the current precedence level.\n      var op = operators[i];\n      if (op.precedence != prec) {++i; continue;}\n\n      // Collapse the previous and next operands with this operator.\n      operands[i] = new Operators.CallOperator(op.func_bind, [operands[i], operands[i+1]]);\n      operators.splice(i, 1);\n      operands.splice(i+1, 1);\n    }\n  }\n\n  // Sanity check\n  if (operators.length !== 0 || operands.length != 1)\n    throw \"internal error: resoving failed; \" + operands.length + \" operands and \" + operators.length + \" operators remain\";\n\n  // For non-nested expressions, throw if any tokens remain.\n  if (!nested)\n  {\n    parser.skipWhitespace();\n\n    if (parser.pos < parser.end)\n    {\n      throw \"expected operator, got \\\"\" + parser.nextToken() + \"\\\"\";\n    }\n  }\n\n  return operands[0];\n}\n\n// Compile a function argument list.  Error if the next \nfunction buildArguments(parser) {\n\n  // Skip whitespace\n  parser.skipWhitespace();\n\n  // Argument list present?\n  if (parser.getChar() != \"(\") return null;\n  ++parser.pos;\n\n  // Zero arguments?\n  parser.skipWhitespace();\n  if (parser.getChar() == \")\") {++parser.pos; return [];}\n  \n  var results = [];\n\n  while (true)\n  {\n    // Compile an expression.\n    results.push(buildExpression(parser, true));\n\n    // Skip more whitespace\n    parser.skipWhitespace();\n\n    // Expect ) or , after argument.\n    var char = parser.getChar();\n    ++parser.pos;\n    if (char == \")\") break;\n    if (char != \",\") throw \"Expect ',' or ')' after function argument\";\n  }\n\n  return results;\n}\n\n// Compile an operand into a function returning the operand value.\nfunction buildOperand(parser) {\n\n  var term;\n  \n  // Skip whitespace\n  parser.skipWhitespace();\n\n  if (parser.pos == parser.end) return null;\n\n  var char = parser.getChar();\n\n  if (char.match(/[0-9\\.+=]/i))\n  {\n    // Number constant\n    term = parser.match_here(rxDecimal);\n    if (term) return new Operands.Opd_Number(Number(term[0]));\n    throw \"Invalid number: \" + parser.nextToken();\n  }\n  else if (char.match(/[a-z]/i))\n  {\n    // Cell name?\n    term = parser.match_here(rxCellName);\n    if (term) return new Operands.Opd_Transclude(\"##\" + term[0]);\n\n    // Function call?\n    term = parser.match_here(rxIdentifier);\n\n    if (term)\n    {\n      var func = formulaFunctions[term[0].toLowerCase()];\n\n      if (!func) throw \"unknown function: \" + term[0];\n\n      var args = buildArguments(parser);\n\n      // Omitting arguments is only OK for constant functions\n      if (args === null)\n      {\n        if (!func.isConstant) throw \"Expected '(' after \" + term[0];\n        args = [];\n      }\n\n      if (func instanceof Function) {\n        // Check parameter count\n        if (args.length > func.length && !func.variadic)\n          throw \"too many arguments for \" + term[0] + \" (requires \" + func.length + \")\";\n        if (args.length < func.length)\n          throw \"too few arguments for \" + term[0] + (func.variadic?\" (min \":\" (requires \") + func.length + \")\";\n      }\n      else if (func.select || func.construct) {\n        // Check argument range\n        if (func.max_args && args.length > func.max_args)\n          throw \"too many arguments for \" + term[0] + \" (max \" + func.max_args + \")\";\n        if (func.min_args && args.length < func.min_args)\n          throw \"too few arguments for \" + term[0] + \" (min \" + func.min_args + \")\";\n        \n        // If a construct function is present, use it to generate an operand.\n        if (func.construct) return func.construct(args);\n\n        // If a select function is present, prepare to bind it with a CallOperator.\n        func = func.select(args);\n      }\n      else {\n        throw \"Function \" + term[0] + \" seems to be unusable.\";\n      }\n\n      return new Operators.CallOperator(func, args);\n    }\n  }\n  else switch (char)\n  {\n  case \"(\": // Parenthesized expression\n    ++parser.pos;\n    var parentheses = buildExpression(parser, true);\n    parser.skipWhitespace();\n    if (parser.getChar() != \")\")\n    {\n      if (parser.pos == parser.end) throw \"missing ')' at end of formula\";\n      else                          throw \"expected ')', got \\\"\" + parser.nextToken() + \"\\\"\";\n    }\n    ++parser.pos;\n    return parentheses;\n\n  case \"'\":\n  case \"\\\"\": // String constant\n    term = parser.match_here(rxString);\n    if (!term) throw \"Invalid string: \" + parser.nextToken();\n    term = term[0].substr(1, term[0].length-2);\n    term = term.replace(rxEscapeSequence, function(esc) {\n      switch (esc.charAt(1)) {\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n        case 'n': return '\\n';\n        case 'r': return '\\r';\n        case 'b': return '\\b';\n        case 'f': return '\\f';\n        case 't': return '\\t';\n        case 'v': return '\\v';\n        case '0': return '\\0';\n        case 'u':\n          if (esc.length < 6) throw \"Invalid escape sequence: \" + esc;\n          return String.fromCharCode(parseInt(esc.substr(2), 16));\n        default: throw \"Invalid escape sequence: \" + esc;\n      }\n    });\n    return new Operands.Opd_Text(term);\n\n  case \"[\": // Filter operand\n    term = parser.match_here(rxOperandFilter);\n    if (term) return new Operands.Opd_Filter(term[0]);\n    break;\n\n  case \"{\": // Transclusion operand\n    term = parser.match_here(rxOperandTransclusion);\n    if (term) return new Operands.Opd_Transclude(term[0].substring(2, term[0].length-2));\n    break;\n\n  case \"<\": // Variable operand\n    term = parser.match_here(rxOperandVariable);\n    if (term) return new Operands.Opd_Variable(term[0].substring(2, term[0].length-2));\n    break;\n  }\n\n  // Didn't recognize the operand\n  return null;\n}\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/compile.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211181652443",
            "description": "",
            "created": "20171210195223539"
        },
        "$:/plugins/ebalster/formula/filters/range.js": {
            "text": "/*\\\ntitle: $:/plugins/ebalster/formula/filters/range.js\ntype: application/javascript\nmodule-type: filteroperator\n\nFilter operator for generating a numeric range.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\nExport our filter function\n*/\nexports.range = function(source,operator,options) {\n\tvar results = [];\n\n\t// Split the operand into numbers delimited by these symbols\n\tvar parts = operator.operand.split(/[,:;]/g), beg, end, inc, i, fixed = 0;\n\n\tfor (i = 0; i < parts.length; ++i) {\n\t\t// Validate real number\n\t\tif (!/^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/.test(parts[i]))\n\t\t\treturn [\"range: bad number \\\"\"+parts[i]+\"\\\"\"];\n\n\t\t// Count digits; the most precise number determines decimal places in output.\n\t\tvar frac = /\\.\\d+/.exec(parts[i]);\n\t\tif (frac) fixed = Math.max(fixed, frac[0].length-1);\n\t\t\n\t\tparts[i] = parseFloat(parts[i]);\n\t}\n\n\tswitch (parts.length) {\n\t\tcase 1:\n\t\t\tbeg = 0;\n\t\t\tend = parts[0];\n\t\t\tinc = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbeg = parts[0];\n\t\t\tend = parts[1];\n\t\t\tinc = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbeg = parts[0];\n\t\t\tend = parts[1];\n\t\t\tinc = Math.abs(parts[2]);\n\t\t\tbreak;\n\t}\n\n\tif (inc === 0) return [\"range: increment 0 causes infinite loop\"];\n\n\t// May need to count backwards\n\tvar direction = ((end<beg) ? -1 : 1);\n\tinc *= direction;\n\n\t// Estimate number of resulting elements\n\tif ((end-beg)/inc > 10000) return [\"range: too many steps (over 10K)\"];\n\n\t// Avoid rounding error on last step\n\tend += direction * 0.5 * Math.pow(0.1, fixed);\n\n\tvar safety = 10010;\n\n\t// Enumerate the range\n\tif (end<beg) {for (i = beg; i > end; i += inc) {results.push(i.toFixed(fixed)); if (--safety<0) break;}}\n\telse         {for (i = beg; i < end; i += inc) {results.push(i.toFixed(fixed)); if (--safety<0) break;}}\n\n\tif (safety<0) return [\"range: unexpectedly large output\"];\n\n\t// Reverse?\n\tif (operator.prefix === \"!\") results.reverse();\n\n\treturn results;\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/filters/range.js",
            "tags": "",
            "module-type": "filteroperator",
            "modified": "20171221181907646",
            "created": "20171221181646560"
        },
        "$:/plugins/ebalster/formula/functions/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Unary sign operators\nexports.uplus  = function(a)    {return a;};\nexports.uminus = function(a)    {return new Val.V_Num(-a.asNum());};\n\n// Add\nexports.add = function(a, b)    {return new Val.V_Num(a.asSum() + b.asSum());};\nexports.sub = function(a, b)    {return new Val.V_Num(a.asSum() - b.asSum());};\n\n// Multiply\nexports.mul = function(a, b)    {return new Val.V_Num(a.asNum() * b.asNum());};\nexports.div = function(a, b)    {return new Val.V_Num(a.asNum() / b.asNum());};\n\n// Percent -- TODO make this a different value-type\nexports.percent = function(a, b)    {return new Val.V_Percent(a.asNum() / 100);};\n\n\n// Aliases\nexports.subtract = exports.sub;\nexports.minus    = exports.sub;\nexports.multiply = exports.mul;\nexports.divide   = exports.div;\nexports.quotient = exports.div;\nexports.power    = exports.pow;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/arithmetic.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171212223526867",
            "created": "20171211192843088"
        },
        "$:/plugins/ebalster/formula/functions/arrays.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Array = Val.V_Array;\nvar V_Num   = Val.V_Num;\n\n\nexports.nth = function(a, i) {\n    if (! (a instanceof V_Array)) throw \"NTH(a,i) function requires a is array!\";\n    a = a.get();\n    i = Math.floor(i.asNum());\n    if (i < 1 || i > a.length) return new Val.V_Undefined();\n    return a[i-1];\n};\n\nexports.first = function(a) {\n    if (! (a instanceof V_Array)) throw \"FIRST(a) function requires a is array!\";\n    a = a.get();\n    if (a.length) return a[0];\n    return new Val.V_Undefined();\n};\n\nexports.last = function(a) {\n    if (! (a instanceof V_Array)) throw \"LAST(a) function requires a is array!\";\n    a = a.get();\n    if (a.length) return a[a.length-1];\n    return new Val.V_Undefined();\n};\n\n// COUNT function, currently counts everything\nexports.count =\n{\n    min_args : 1,\n    select : function(operands)\n    {\n        switch (operands)\n        {\n        case 1: return function(a) {\n                if (a instanceof V_Array) return new V_Num(a.get().length);\n                return 1;\n            };\n        default: return function() {\n                var count = 0;\n                for (var i = 0; i < arguments.length; ++i)\n                {\n                    var a = arguments[i];\n                    count += ((a instanceof V_Array) ? a.get().length : 1);\n                }\n                return new V_Num(count);\n            };\n        }\n    }\n};\n\n// COUNTA function, currently counts everything\nexports.counta = exports.count;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/arrays.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171219014910148",
            "created": "20171219014903147"
        },
        "$:/plugins/ebalster/formula/functions/compare.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Equality\nexports.eq  = function(a, b)    {return new Val.V_Bool(a.get() == b.get());};\nexports.ne  = function(a, b)    {return new Val.V_Bool(a.get() != b.get());};\n\n// Inequality\nexports.gt  = function(a, b)    {return new Val.V_Bool(a.get() >  b.get());};\nexports.gte = function(a, b)    {return new Val.V_Bool(a.get() >= b.get());};\nexports.lt  = function(a, b)    {return new Val.V_Bool(a.get() <  b.get());};\nexports.lte = function(a, b)    {return new Val.V_Bool(a.get() <= b.get());};\n\n\n// Aliases\nexports.equal            = exports.eq;\nexports.not_equal        = exports.ne;\nexports.greater          = exports.gt;\nexports.greater_or_equal = exports.gte;\nexports.less             = exports.lt;\nexports.less_or_equal    = exports.lte;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/compare.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214050803365",
            "created": "20171214050022626"
        },
        "$:/plugins/ebalster/formula/functions/datetime.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Bool = Val.V_Bool;\nvar V_Date = Val.V_Date;\nvar V_Num  = Val.V_Num;\nvar V_Text = Val.V_Text;\n\n\nvar MS_PER_DAY = 86400000;\nvar MS_PER_HOUR = 3600000;\nvar MS_PER_MINUTE = 60000;\nvar MS_PER_SECOND =  1000;\n\nvar UNIX_EPOCH_JULIAN_DAY = 2440587;\n\n\n/*!\n * isoWeekNum from pikaday <https://github.com/actano/Pikaday>\n */\nfunction isoWeekOfYear(date, dayInFirstWeek) {\n    dayInFirstWeek = dayInFirstWeek || 4;\n    date = date instanceof Date ? date : new Date();\n    date.setHours(0, 0, 0, 0);\n    var yearDay        = date.getDate(),\n        weekDay        = date.getDay(),\n        dayShift       = dayInFirstWeek - 1, // counting starts at 0\n        prevWeekDay    = function(day) { return (day + 7 - 1) % 7; };\n    date.setDate(yearDay + dayShift - prevWeekDay(weekDay));\n    var jan4th      = new Date(date.getFullYear(), 0, dayInFirstWeek),\n        daysBetween = (date.getTime() - jan4th.getTime()) / MS_PER_DAY,\n        weekNum     = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / 7);\n    return weekNum;\n}\nfunction isLeapYear(year) {\n    return year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0);\n}\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\nfunction daysInMonth(year, monthIndex) {\n    switch (monthIndex) {\n    case  0: case  2: case  4: case  6: case  7: case  9: case 11:return 31;\n    case  3: case  5: case  8: case 10: return 30;\n    case  1: return (isLeapYear(year) ? 29 : 28);\n    default: throw \"days_in_month: invalid monthIndex: \" + monthIndex;\n    }\n}\n\n// Utility: Add some months or years to a date\nfunction dateAddMonths(date, monthDiff, yearDiff) {\n    yearDiff = yearDiff || 0;\n    var newMonth = date.getMonth() + Math.round(monthDiff);\n    var newYear = date.getFullYear() + Math.round(yearDiff);\n\n    var yearShift = ((newMonth < 0) ? -Math.floor(-(newMonth-11)/12) : Math.floor(newMonth/12));\n    newYear  += yearShift;\n    newMonth -= 12*yearShift;\n\n    return new Date(newYear, newMonth,\n        Math.min(date.getDate(), daysInMonth(newYear, newMonth)),\n        date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\n\n// Utility: Get date difference in whole years and months\nfunction dateDelta(date1, date2) {\n    if (date2.getTime() < date1.getTime())\n    {\n        var d = dateDelta(date2, date1);\n        return {years: -d.years, months: -d.months};\n    }\n    var dMonths = 12*(date2.getYear()-date1.getYear()) + (date2.getMonth()-date1.getMonth());\n    if (date2.getDate() < date1.getDate()) dMonths -= 1;\n    var dYears = Math.floor(dMonths/12);\n    //dMonths -= dYears*12;\n    /*var dDays = (new Date(\n        date1.getFullYear()+dYears, date1.getMonth()+dMonths, date2.getDate(),\n        date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()\n        ).getTime() - date1.getTime()) / MS_PER_DAY;*/\n    return {years: dYears, months: dMonths};\n}\n\n\n// Get the current time\nexports.now         = function()     {return new V_Date(new Date(Date.now()));};\n\n// Decompose dates\nexports.year        = function(d)    {return new V_Num(d.asDate().getFullYear());};\nexports.month       = function(d)    {return new V_Num(d.asDate().getMonth()+1);};\nexports.day         = function(d)    {return new V_Num(d.asDate().getDate());};\nexports.hour        = function(d)    {return new V_Num(d.asDate().getHours());};\nexports.minute      = function(d)    {return new V_Num(d.asDate().getMinutes());};\nexports.second      = function(d)    {return new V_Num(d.asDate().getSeconds());};\nexports.millisecond = function(d)    {return new V_Num(d.asDate().getMilliseconds());};\n\n// Week functions\nexports.weekday     = function(d)    {return new V_Num(d.asDate().getDay()+1);};\nexports.weeknum     = function(d)    {return new V_Num(isoWeekOfYear(d.asDate(), 1));};\nexports.isoweekday  = function(d)    {return new V_Num((d.asDate().getDay()+6) % 7 + 1);};\nexports.isoweeknum  = function(d)    {return new V_Num(isoWeekOfYear(d.asDate()));};\n\n\n/*\n    Date math\n*/\nfunction makeTimeDiffFunction(milliseconds) {\n    return function(a, b) {return new V_Num((b.asDate().getTime() - a.asDate().getTime()) / milliseconds);};\n}\nfunction makeTimeAddFunction(milliseconds) {\n    return function(a, b) {return new V_Date(new Date(a.asDate().getTime() + b.asNum() * milliseconds));};\n}\n\nexports.years  = function(a, b) {return new V_Num(dateDelta(a.asDate(), b.asDate()).years);};\nexports.months = function(a, b) {return new V_Num(dateDelta(a.asDate(), b.asDate()).months);};\nexports.days            = makeTimeDiffFunction(MS_PER_DAY);\nexports.hours           = makeTimeDiffFunction(MS_PER_HOUR);\nexports.minutes         = makeTimeDiffFunction(MS_PER_MINUTE);\nexports.seconds         = makeTimeDiffFunction(MS_PER_SECOND);\nexports.milliseconds    = makeTimeDiffFunction(1);\n\nexports.add_years  = function(a, b) {return new V_Date(dateAddMonths(a.asDate(), 0, b.asNum()));};\nexports.add_months = function(a, b) {return new V_Date(dateAddMonths(a.asDate(), b.asNum()));};\nexports.add_days         = makeTimeAddFunction(MS_PER_DAY);\nexports.add_hours        = makeTimeAddFunction(MS_PER_HOUR);\nexports.add_minutes      = makeTimeAddFunction(MS_PER_MINUTE);\nexports.add_seconds      = makeTimeAddFunction(MS_PER_SECOND);\nexports.add_milliseconds = makeTimeAddFunction(1);\n\nexports.is_leap_year  = function(year)       {return new V_Bool(isLeapYear(year.asNum()));};\nexports.days_in_year  = function(year)       {return new V_Num(daysInYear(year.asNum()));};\nexports.days_in_month = function(yr, mon)    {return new V_Num(daysInMonth(yr.asNum(), mon.asNum()-1));};\n\n/*exports.datedif = function(a, b, c) {\n    a = a.asDate();\n    b = b.asDate();\n    switch (c.asString().toUpperCase())\n    {\n    case \"D\": return new V_Num((b.getTime() - a.getTime()) / MS_PER_DAY);\n    case \"M\": {var d=dateDelta(a, b); return d.months+12*d.years;}\n    case \"Y\": return dateDelta(a, b).years;\n    case \"YM\": return dateDelta(a, b).months;\n    case \"MD\": return dateDelta(a, b).days;\n    }\n};*/\n\n\n// Parse TiddlyWiki date\nexports.tw_date = function(timestamp) {\n    var date = $tw.utils.parseDate(timestamp.asString());\n    if (!date) throw \"Bad timestamp: \\\"\" + date + \"\\\"\";\n    return new V_Date(date);\n};\n\n// Stringify as TiddlyWiki date\nexports.to_tw_date = function(date) {\n    return new V_Text($tw.utils.stringifyDate(date.asDate()));\n};\n\n// Create ISO date\nexports.make_date = function(year, month, day) {\n    return new V_Date(new Date(year.asNum(), month.asNum()-1, day.asNum()));\n};\n\n// Create ISO time\nexports.make_time = function(hour, minute, second) {\n    return new V_Date(new Date(0, 0, 0, hour.asNum(), minute.asNum(), second.asNum()));\n};\n\n// Create from julian\nexports.julian = function(julian) {\n    return new V_Date(new Date((julian.asNum() - UNIX_EPOCH_JULIAN_DAY) * MS_PER_DAY));\n};\n\n// Convert to julian\nexports.to_julian = function(date) {\n    return new V_Num(UNIX_EPOCH_JULIAN_DAY + (date.asDate().getTime() / MS_PER_DAY));\n};\n\nexports.time = exports.make_time;\n\n\n// Cast the incoming value into a date.\nfunction interpret_date(a) {\n    if (a instanceof V_Date) return a;\n    return exports.tw_date(a);\n}\n\n\n// Consruct a date from a TiddlyWiki timestamp or a set of parts\nexports.date = {\n    min_args: 1, max_args: 3,\n    select: function(operands) {\n        switch (operands.length) {\n        case 1: return interpret_date;\n        case 3: return exports.make_date;\n        default: throw \"Bad arguments to DATE. Should be (timestamp) or (year, month, day).\";\n        }\n    }\n};\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/datetime.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171217192149101",
            "created": "20171217192129179"
        },
        "$:/plugins/ebalster/formula/functions/logic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Operator = require(\"$:/plugins/ebalster/formula/operators.js\").Operator;\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Constants\nexports.true  = function()    {return new Val.V_Bool(true);};\nexports.false = function()    {return new Val.V_Bool(false);};\n\nexports.true.isConstant = true;\nexports.false.isConstant = true;\n\n// Logical operators\nexports.not = function(a)       {return new Val.V_Bool(!a.get());};\nexports.and = function(a, b)    {return new Val.V_Bool(a.get() && b.get());};\nexports.or  = function(a, b)    {return new Val.V_Bool(a.get() || b.get());};\nexports.xor = function(a, b)    {return new Val.V_Bool(a.get() ? !b.get() : !!b.get());};\n\n// Ternary\nfunction IfOp(pred, tval, fval) {\n  this.pred = pred;\n  this.tval = tval;\n  this.fval = fval;\n}\nIfOp.prototype = new Operator();\nIfOp.prototype.name = \"if\";\nIfOp.prototype.compute = (function(widget, recur) {\n  return (this.pred.compute(widget, recur).get() ? this.tval.compute(widget, recur) : this.fval.compute(widget, recur));\n});\nexports.if = {\n  min_args: 3, max_args: 3,\n  construct: function(operands) {\n    return new IfOp(operands[0], operands[1], operands[2]);\n  }\n};\n\n\n// IFERROR\n/*exports.iferror = {\n  min_args = 2, max_args = 2,\n  func = function(a, b) {\n  select: function(operands) {\n    try {return a.compute();}\n    catch (err) {return b.compute();}\n  }\n  };*/\n\n\n// SWITCH (variadic)\nexports.switch =\n{\n  min_args: 3,\n  select: function(operands)\n  {\n    switch (operands.length % 2)\n    {\n    default:\n    case 0: return function(a) // Switch with default\n      {\n        var value = a.get();\n        for (var i = 1; i+1 < arguments.length; i += 2)\n          {if (arguments[i].get() == value) return arguments[i+1];}\n        return arguments[arguments.length-1];\n      };\n    case 1: return function(a) // Switch, no default\n      {\n        var value = a.get();\n        for (var i = 1; i+1 < arguments.length; i += 2)\n          {if (arguments[i].get() == value) return arguments[i+1];}\n        return new Val.V_Undefined();\n      };\n    }\n  }\n};\n\n// CHOOSE (variadic)\nexports.choose = function(a, b)\n{\n  var index = Math.floor(a.asNum());\n  var result = arguments[index];\n  if (index < 1 || !result) return new Val.V_Undefined();\n  return result;\n};\nexports.choose.variadic = true;\n\n// IFS function (variadic)\nexports.ifs =\n{\n  min_args : 2,\n  select : function(operands)\n  {\n    if (operands.length % 2 !== 0)\n      throw \"Odd number of arguments to IFS\";\n\n    return function()\n    {\n      for (var i = 0; i < arguments.length; i += 2)\n        {if (arguments[i].get()) return arguments[i+1];}\n      return new Val.V_Undefined();\n    };\n  }\n};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/logic.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214060456114",
            "created": "20171214054240274"
        },
        "$:/plugins/ebalster/formula/functions/math.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Num = Val.V_Num;\nvar V_Array = Val.V_Array;\n\n\n// Constants\nexports.pi = function()    {return new V_Num(Math.PI);};\nexports._e = function()    {return new V_Num(Math.E);};\n\nexports.pi.isConstant = true;\nexports._e.isConstant = true;\n\n\n// Random\nexports.rand        = function()        {return new V_Num(Math.random());};\nexports.randbetween = function(a, b)    {a=a.asNum(); b=b.asNum(); return new V_Num(a+(b-a)*Math.random());};\nexports.random = exports.rand;\n\n\n// Sign and absolute value\nexports.abs  = function(a)    {return new V_Num(Math.abs(a.asNum()));};\nexports.sign = function(a)    {var x = a.asNum(); return new V_Num(((x > 0) - (x < 0)) || +x);};\n\n// Min/max\nexports.min = function(a)\n{\n    var min = a.asNum();\n    for (var i = 1; i < arguments.length; ++i) min = Math.min(min, arguments[i].asNum());\n    return new V_Num(min);\n};\nexports.min.variadic = true;\n\nexports.max = function(a)\n{\n    var max = a.asNum();\n    for (var i = 1; i < arguments.length; ++i) max = Math.max(max, arguments[i].asNum());\n    return new V_Num(max);\n};\nexports.max.variadic = true;\n\nexports.clamp = function(a, min, max) {\n    return new V_Num(Math.min(Math.max(a.asNum(), min.asNum()), max.asNum()));\n};\n\n\n/*\n    Series arithmetic\n*/\nexports.sum =\n{\n    min_args : 1,\n    select : function(operands)\n    {\n        switch (operands)\n        {\n        case 1: return function(a) {return new V_Num(a.asSum());};\n        default: return function()\n            {\n                var sum = 0;\n                for (var i = 0; i < arguments.length; ++i) sum += arguments[i].asSum();\n                return new V_Num(sum);\n            };\n        }\n    }\n};\nexports.average =\n{\n    min_args : 1,\n    select : function(operands)\n    {\n        switch (operands)\n        {\n        case 1: return function(a) {\n                if (a instanceof V_Array) return new V_Num(a.asSum()/a.get().length);\n                return a.asNum();\n            };\n        default: return function() {\n                var sum = 0, count = 0;\n                for (var i = 0; i < arguments.length; ++i)\n                {\n                    var a = arguments[i];\n                    sum += a.asSum();\n                    count += ((a instanceof V_Array) ? a.get().length : 1);\n                }\n                return new V_Num(sum/count);\n            };\n        }\n    }\n};\nexports.product = function()\n{\n    var product = 1;\n    for (var i = 0; i < arguments.length; ++i) product *= arguments[i].asNum();\n    return new V_Num(product);\n};\nexports.product.variadic = true;\n\n\n/*\n    Exponential\n*/\n\n// Exponentiation and logarithm\nexports.pow   = function(a, b)    {return new V_Num(Math.pow(a.asNum(), b.asNum()));};\nexports.exp   = function(a)       {return new V_Num(Math.exp(a.asNum()));};\nexports.log   = function(a, b)    {return new V_Num(Math.log(a.asNum()) / Math.log(b.asNum()));};\nexports.ln    = function(a)       {return new V_Num(Math.log(a.asNum()));};\nexports.log2  = function(a)       {return new V_Num(Math.log2(a.asNum()));};\nexports.log10 = function(a)       {return new V_Num(Math.log10(a.asNum()));};\n\nexports.power = exports.pow;\n\n// Precise exponentiation and logarithm\nexports.expm1 = function(a)       {return new V_Num(Math.expm1(a.asNum()));};\nexports.log1p = function(a)       {return new V_Num(Math.log1p(a.asNum()));};\n\n// Roots\nexports.sqrt = function(a)    {return new V_Num(Math.sqrt(a.asNum()));};\nexports.cbrt = function(a)    {return new V_Num(Math.cbrt(a.asNum()));};\n\n\n/*\n    Trigonometry\n*/\n\n// Conversion\nexports.radians = function(a)    {return new V_Num(Math.PI*a.asNum()/180);};\nexports.degrees = function(a)    {return new V_Num(180*a.asNum()/Math.PI);};\n\n// Trigonometry\nexports.sin = function(a)    {return new V_Num(  Math.sin(a.asNum()));};\nexports.cos = function(a)    {return new V_Num(  Math.cos(a.asNum()));};\nexports.tan = function(a)    {return new V_Num(  Math.tan(a.asNum()));};\nexports.csc = function(a)    {return new V_Num(1/Math.sin(a.asNum()));};\nexports.sec = function(a)    {return new V_Num(1/Math.cos(a.asNum()));};\nexports.cot = function(a)    {return new V_Num(1/Math.tan(a.asNum()));};\n\n// Inverse Trigonometry\nexports.asin = function(a)    {return new V_Num(Math.asin(  a.asNum()));};\nexports.acos = function(a)    {return new V_Num(Math.acos(  a.asNum()));};\nexports.atan = function(a)    {return new V_Num(Math.atan(  a.asNum()));};\nexports.atan2 = function(y,x)    {return new V_Num(Math.atan2(y.asNum(), x.asNum()));};\nexports.acsc = function(a)    {return new V_Num(Math.asin(1/a.asNum()));};\nexports.asec = function(a)    {return new V_Num(Math.acos(1/a.asNum()));};\nexports.acot = function(a)    {return new V_Num(Math.atan(1/a.asNum()));};\n\n// Hyperbolic Trigonometry\nexports.sinh = function(a)    {return new V_Num(  Math.sinh(a.asNum()));};\nexports.cosh = function(a)    {return new V_Num(  Math.cosh(a.asNum()));};\nexports.tanh = function(a)    {return new V_Num(  Math.tanh(a.asNum()));};\nexports.csch = function(a)    {return new V_Num(1/Math.sinh(a.asNum()));};\nexports.sech = function(a)    {return new V_Num(1/Math.cosh(a.asNum()));};\nexports.coth = function(a)    {return new V_Num(1/Math.tanh(a.asNum()));};\n\n// Inverse Hyperbolic Trigonometry\nexports.asinh = function(a)    {return new V_Num(Math.asinh(  a.asNum()));};\nexports.acosh = function(a)    {return new V_Num(Math.acosh(  a.asNum()));};\nexports.atanh = function(a)    {return new V_Num(Math.atanh(  a.asNum()));};\nexports.acsch = function(a)    {return new V_Num(Math.asinh(1/a.asNum()));};\nexports.asech = function(a)    {return new V_Num(Math.acosh(1/a.asNum()));};\nexports.acoth = function(a)    {return new V_Num(Math.atanh(1/a.asNum()));};\n\n/*\n    Rounding, ceiling and floor functions.\n        Special measures were taken to reproduce the conventions.\n*/\n\nvar signedFloor = Math.trunc || function(n) {return (n<0) ? Math.ceil (n) : Math.floor(n);};\nvar signedCeil  =               function(n) {return (n<0) ? Math.floor(n) : Math.ceil (n);};\n\nfunction genCeilFloor(operands, func)\n{\n    switch (operands.length)\n    {\n    case 1: return function(a)    {return new V_Num(func(a.asNum()));};\n    case 2: return function(a, b) {var prec = b.asNum(); return new V_Num(func(a.asNum()/prec) * prec);};\n    }\n}\n\nfunction genRound(operands, func)\n{\n    var lndigit = Math.log(0.1);\n    switch (operands.length)\n    {\n    case 1: return function(a)    {return new V_Num(func(a.asNum()));};\n    case 2: return function(a, b) {var prec = Math.exp(lndigit*b.asNum()); return new V_Num(func(a.asNum()/prec) * prec);};\n    }\n}\n\n\nexports.floor =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.floor);}\n};\nexports.ceil =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.ceil);}\n};\n\n/*exports.floor_precise =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.floor);}\n};\nexports.ceil_precise =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.ceil);}\n};*/\nexports.round =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, Math.round);}\n};\nexports.roundup =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, signedCeil);}\n};\nexports.rounddown =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, signedFloor);}\n};\n\nexports.trunc = exports.rounddown;\n\n// Related functions\nexports.fract  = function(a)      {a = a.asNum(); return new V_Num(a-signedFloor(a));};\nexports.modulo = function(a,b)    {b = b.asNum(); return new V_Num(b*Math.floor(a/b));};\n\nexports.mod = exports.modulo;\n\n\n/*\n    Interpolation\n*/\nexports.mix = function(a,b,m) {\n    a = a.asNum();\n    b = b.asNum();\n    m = m.asNum();\n    return new V_Num(a + (b-a) * m);\n};\n\nexports.step = function(e,x)    {return new V_Num((x.asNum()<e.asNum()) ? 0.0 : 1.0);};\n\nexports.smoothstep = function(e0,e1,x) {\n    x  = x .asNum();\n    e0 = e0.asNum();\n    e1 = e1.asNum();\n    if (x < e0) return new V_Num(0.0);\n    if (x > e1) return new V_Num(1.0);\n    x = (x-e0) / (e1-e0);\n    return new V_Num(3*x*x - 2*x*x*x);\n};\n\n\n\n/*\n    Algorithms\n*/\nfunction compute_gcd(a, b) {\n    a = Math.abs(Math.round(a));\n    b = Math.abs(Math.round(b));\n    if (b > a) {var temp = a; a = b; b = temp;}\n    var limit = 1000;\n    while (true) {\n        if (b == 0) return a;\n        a %= b;\n        if (a == 0) return b;\n        b %= a;\n        if (--limit < 0) throw \"GCD function is nonterminal!\";\n    }\n}\n\nfunction compute_lcm(a, b) {\n    a = Math.abs(Math.round(a));\n    b = Math.abs(Math.round(b));\n    return (!a || !b) ? 0 : Math.abs((a * b) / compute_gcd(a, b));\n}\n\nexports.gcd = function(a,b) {\n    return new V_Num(compute_gcd(a.asNum(), b.asNum()));\n};\n\nexports.lcm = function(a,b) {\n    return new V_Num(compute_lcm(a.asNum(), b.asNum()));\n};\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/math.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214171708994",
            "created": "20171214171454666"
        },
        "$:/plugins/ebalster/formula/functions/regexp.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Num  = Val.V_Num;\nvar V_Text = Val.V_Text;\n\n\n// Compile regex.  TODO: Precompile these where possible\nvar TW_RX_FLAGS = /^\\(\\?[a-z]*\\)|\\(\\?[a-z]*\\)$/i;\n\nfunction tw_regex(rx_str, defaultFlags) {\n\tif (!rx_str) throw \"Empty regular expression\";\n\tvar flagPart = TW_RX_FLAGS.exec(rx_str);\n\tif (flagPart) {\n\t\tvar flagLen = flagPart[0].length;\n\t\tvar flags = flagPart[0].substr(2, flagPart[0].length-3);\n\t\tif (flagPart.index == 0) return new RegExp(rx_str.substr(flagLen), flags);\n\t\telse                     return new RegExp(rx_str.substr(0, rx_str.length-flagLen), flags);\n\t}\n\treturn new RegExp(rx_str, defaultFlags);\n}\n\n\n// Regex replace\nexports.regexreplace = function(s, rx, b) {\n\trx = tw_regex(rx.asString(), \"g\");\n\treturn new V_Text(s.asString().replace(rx, b.asString()));\n};\n\n// Regex match\nexports.regexmatch = function(s, rx) {\n\trx = tw_regex(rx.asString(), \"\");\n\treturn new Val.V_Bool(rx.test(s.asString()));\n};\n\n// Regex extract\nfunction regexextract(s, rx) {\n\trx = tw_regex(rx.asString(), \"g\");\n\ts = s.asString();\n\tvar captureIndex = (arguments[2] ? arguments[2].asNum() : 0);\n\tvar matches = [];\n\tvar match;\n\twhile ((match = rx.exec(s)) != null) {\n\t\tif (match[0].length == 0) ++rx.lastIndex;\n\t\tmatches.push(new V_Text(match[captureIndex] || \"\"));\n\t\tif (!rx.global) break;\n\t}\n\treturn new Val.V_Array(matches);\n}\n\nexports.regexextract = {\n\tmin_args: 2, max_args: 3,\n\tselect: function(operands) {return regexextract;}\n};\n\n// Regex extract, single argument\nfunction regexextract1(s, rx, dfl) {\n\trx = tw_regex(rx.asString(), \"\");\n\ts = s.asString();\n\tvar captureIndex = (arguments[3] ? arguments[3].asNum() : 0);\n\tvar match = rx.exec(s);\n\treturn new Val.V_Text(\n\t\t(match && match[captureIndex]) ? match[captureIndex] : dfl.asString());\n}\n\nexports.regexextract1 = {\n\tmin_args: 3, max_args: 4,\n\tselect: function(operands) {return regexextract1;}\n};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/regexp.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171220230855457",
            "created": "20171220230845098"
        },
        "$:/plugins/ebalster/formula/functions/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Text = Val.V_Text;\n\n\n\n// Cast to text.  Second argument not yet supported.\nexports.t = function(a)    {return new V_Text(a.asString());};\n\nexports.text = {\n\tmin_args: 1, max_args: 1,\n\tselect: function(operands) {\n\t\tif (operands.length == 1) return exports.t;\n\t\treturn function(a, format) {return new V_Text(a.asString());};\n\t}\n};\n\n// Cast string to number.\nexports.value = function(a)    {return new Val.V_Num(a.get());};\n\n// Array to string\nexports.textjoin = function(delimiter, ignore_empty, a) {\n\tdelimiter = delimiter.asString();\n\tvar s = \"\";\n\tvar i = 1;\n\tif (ignore_empty instanceof Val.V_Bool) {\n\t\ti = 2;\n\t\tignore_empty = ignore_empty.get();\n\t}\n\telse ignore_empty = true;\n\tfor (; i < arguments.length; ++i)\n\t{\n\t\tvar arg = arguments[i];\n\t\tif (arg instanceof Val.V_Array) {\n\t\t\targ = arg.get();\n\t\t\tfor (var j = 0; j < arg.length; ++j) {\n\t\t\t\tif (s.length) s += delimiter;\n\t\t\t\ts += arg[j].asString();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s.length) s += delimiter;\n\t\t\ts += arg.asString();\n\t\t}\n\t}\n\treturn new V_Text(s);\n};\nexports.textjoin.variadic = true;\n\n// Split string to array\nexports.split = function(str, delimiter) {\n\tdelimiter = delimiter.asString();\n\tvar split = str.asString().split(delimiter);\n\tvar results = [];\n\tfor (var i = 0; i < split.length; ++i) {\n\t\tif (split[i].length) results.push(split[i]);\n\t}\n\treturn new Val.V_Array(results);\n};\n\n// String length\nexports.len = function(str)     {return new Val.V_Num(str.asString().length);};\n\n// String exact match\nexports.exact = function(a, b)    {return new Val.V_Bool(a.asString() === b.asString());};\n\n\n// Substrings\nexports.mid = function(str, i, n)    {return new V_Text(str.asString().substr(i.asNum()-1, n.asNum()));};\n\nexports.substr = exports.mid;\n\n\n// Substitute\nexports.substitute = function(s, f, r)    {return new V_Text(s.asString().replace(f.asString(), r.asString()));};\n\n// Replace (N/I)\n//exports.replace = function(s, p, l, r)    {return new V_Text(s.asString().splice(a.asString(), b.asString()));};\n\n\n// Concatenate\nexports.cat = function(a, b)    {return new V_Text(a.asString() + b.asString());};\n\n// Trim space\nexports.trim = function(a)      {return new V_Text(a.asString().replace(/^\\s+|\\s+$/g, \"\"));};\n\n\n// Aliases\nexports.concatenate = exports.cat;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/strings.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171213003237206",
            "created": "20171213003135495"
        },
        "$:/plugins/ebalster/formula/license": {
            "text": "!!The MIT License (MIT)\n\nCopyright (c) 2017 Evan Balster\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "bag": "default",
            "revision": "0",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/ebalster/formula/license",
            "tags": "",
            "modified": "20171220211838536",
            "created": "20171220071005710",
            "caption": "license"
        },
        "$:/plugins/ebalster/formula/macros/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\n  Information about this macro\n*/\n\nexports.name = \"formula\";\nexports.params = [{\"name\": \"formula\"}];\n\n/*\nRun the macro\n*/\nexports.run = function(formula) {\n\n  var formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n  return formulas.evalFormula(formula, this);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/macros/formula.js",
            "tags": "",
            "module-type": "macro",
            "modified": "20171212194124031",
            "created": "20171210215758530"
        },
        "$:/plugins/ebalster/formula/operands.js": {
            "text": "/*\\\ntitle: $:/plugins/ebalster/formula/operands.js\ntype: application/javascript\nmodule-type: macro\n\nLibrary defining formula operands.\nOperands represent some value within the formula: an expression, datum, operator, constant or query...\nOperands may be constant, allowing the formula compiler to optimize them away.\n\n\\*/\n(function(){\n\n\"use strict\";\n\nvar Values   = require(\"$:/plugins/ebalster/formula/value.js\");\n\nexports.Operand = function() {\n};\nexports.Operand.prototype.is_constant = false;\nexports.Operand.prototype.name = \"unknown-operand\";\nexports.Operand.prototype.toString = function()    {return \"[Operand \" + this.name + \"]\";};\n\n// Operand::compute -- produce\nexports.Operand.prototype.compute = (function(widget, recur) {return new Values.V_Undefined();});\n\n\n// An operand that just throws an error.\nexports.Opd_Error = function(exception) {\n  this.exception = exception;\n};\nexports.Opd_Error.prototype = new exports.Operand();\nexports.Opd_Error.prototype.name = \"error\";\nexports.Opd_Error.prototype.compute = function(widget, recur)\n{\n  // Throw up\n  throw this.exception;\n};\n\n\n// String constant operand.\nexports.Opd_Text = function(value) {\n  this.value = value;\n};\nexports.Opd_Text.prototype = new exports.Operand();\nexports.Opd_Text.prototype.name = \"string\";\nexports.Opd_Text.prototype.is_constant = true;\n\nexports.Opd_Text.prototype.compute = function(widget, recur)\n{\n  // Returns a string value\n  return new Values.V_Text(this.value);\n};\n\n\n// Date constant operand.\nexports.Opd_Date = function(value) {\n  this.value = value;\n};\nexports.Opd_Date.prototype = new exports.Operand();\nexports.Opd_Date.prototype.name = \"date\";\nexports.Opd_Date.prototype.is_constant = true;\n\nexports.Opd_Date.prototype.compute = function(widget, recur)\n{\n  // Returns a string value\n  return new Values.V_Date(this.value);\n};\n\n\n// Boolean constant operand.\nexports.Opd_Bool = function(value) {\n  this.value = value;\n};\nexports.Opd_Bool.prototype = new exports.Operand();\nexports.Opd_Bool.prototype.name = \"boolean\";\nexports.Opd_Bool.prototype.is_constant = true;\n\nexports.Opd_Bool.prototype.compute = function(widget, recur)\n{\n  // Returns a number value\n  return new Values.V_Bool(this.value);\n};\n\n\n// Number constant operand.\nexports.Opd_Number = function(value) {\n  this.value = value;\n};\nexports.Opd_Number.prototype = new exports.Operand();\nexports.Opd_Number.prototype.name = \"number\";\nexports.Opd_Number.prototype.is_constant = true;\n\nexports.Opd_Number.prototype.compute = function(widget, recur)\n{\n  // Returns a number value\n  return new Values.V_Num(this.value);\n};\n\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n\n// Opd_Transcluded operand.\nexports.Opd_Transclude = function(textReference) {\n  this.textReference = textReference;\n  this.datum = null;\n  this.op = null;\n};\nexports.Opd_Transclude.prototype = new exports.Operand();\nexports.Opd_Transclude.prototype.name = \"transclude\";\n\nexports.Opd_Transclude.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.wiki.getTextReference(this.textReference, \"\", widget.getVariable(\"currentTiddler\"));\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    try\n    {\n      this.op = Compile.compileDatum(newDatum);\n    }\n    catch (err)\n    {\n      // Save the error\n      this.op = new exports.Opd_Error(\n        err + \"\\n  source: \\\"\" + this.datum + \"\\\"\\n  from {{\" + this.textReference + \"}}\");\n    }\n  }\n\n  return this.op.compute(widget, recur+1);\n};\n\n\n// Opd_Variable operand.\nexports.Opd_Variable = function(variable) {\n  this.variable = variable;\n  this.datum = null;\n  this.op = null;\n  this.compileError = null;\n};\nexports.Opd_Variable.prototype = new exports.Operand();\nexports.Opd_Variable.prototype.name = \"variable\";\n\nexports.Opd_Variable.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.getVariable(this.variable) || \"\";\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    try\n    {\n      this.op = Compile.compileDatum(newDatum);\n    }\n    catch (err)\n    {\n      // Save the error\n      this.op = new exports.Opd_Error(\n        err + \"\\n  source: \\\"\" + this.datum + \"\\\"\\n  from <<\" + this.variable + \">>\");\n    }\n  }\n\n  return this.op.compute(widget, recur+1);\n};\n\n\n// Opd_Filter operand, with some lazy-compile optimizations.\nexports.Opd_Filter = function(filter) {\n  this.filter = filter;\n  this.elements = {}; // Each has count, op, value\n  //this.array = [];\n  this.compileError = null;\n};\nexports.Opd_Filter.prototype = new exports.Operand();\nexports.Opd_Filter.prototype.name = \"filter\";\n\nexports.Opd_Filter.prototype.compute = function(widget, recur) {\n  // Apply the filter and compile each result\n  var i, expr, elem, exprs = widget.wiki.filterTiddlers(this.filter, widget);\n\n  // Clear the array and mark all existing elements for removal\n  for (expr in this.elements) this.elements[expr].count = 0;\n  //this.array = [];\n\n  // Selectively re-compile any filter results that have changed\n  for (i = 0; i < exprs.length; ++i)\n  {\n    expr = exprs[i];\n    elem = this.elements[expr];\n    //this.array.push(expr);\n    \n    if (elem) ++elem.count;\n    else try {\n      this.elements[expr] = {count: 1, op: Compile.compileDatum(expr), value: null};\n    }\n    catch (err) {\n      // Save the error\n      this.elements[expr] = new exports.Opd_Error(\n        err + \"\\n  source: \\\"\" + expr + \"\\\"\\n  from \\\"\" + this.filter + \"\\\"\");\n    }\n  }\n\n  // Compute (unique) values.  Delete any elements with no copies left.\n  for (expr in this.elements) {\n    elem = this.elements[expr];\n    if (elem.count === 0) delete this.elements[expr];\n    else elem.val = elem.op.compute(widget, recur+1);\n  }\n\n  // Return value computes an array of datum values.\n  var results = [];\n  for (i = 0; i < exprs.length; ++i) {\n    expr = exprs[i];\n    results.push(this.elements[expr].val);\n  }\n  return new Values.V_Array(results);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operands.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183031273",
            "description": "",
            "created": "20171211183000431"
        },
        "$:/plugins/ebalster/formula/operators.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\n\nexports.Operator = function Operator() {\n};\nexports.Operator.prototype.name = \"unknown-operator\";\nexports.Operator.prototype = new Operands.Operand();\n\n/*\n  All operators and functions are implemented with this \"function call\" operator.\n*/\n\nexports.CallOperator = function CallOperator(func, args) {\n  this.func = func;\n  this.args = args;\n};\nexports.CallOperator.prototype = new exports.Operator();\nexports.CallOperator.prototype.name = \"function-call\";\nexports.CallOperator.prototype.compute = (function(widget, recur) {\n  var vals = [];\n  this.args.forEach(function(arg) {vals.push(arg.compute(widget, recur));});\n  return this.func.apply(null, vals);\n});\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183054390",
            "description": "",
            "created": "20171211183047843"
        },
        "$:/plugins/ebalster/formula/operators/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Unary sign operators\nexports.uplus    = {arity: 1, position: \"pre\",  operator: \"+\", function: \"uplus\"};\nexports.uminus   = {arity: 1, position: \"pre\",  operator: \"-\", function: \"uminus\"};\n\n// Add\nexports.plus     = {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"};\nexports.minus    = {arity: 2, precedence: 10,   operator: \"-\", function: \"sub\"};\n\n// Multiply\nexports.multiply = {arity: 2, precedence: 20,   operator: \"*\", function: \"mul\"};\nexports.divide   = {arity: 2, precedence: 20,   operator: \"/\", function: \"div\"};\n\n// Exponential\nexports.pow      = {arity: 2, precedence: 30,   operator: \"^\", function: \"pow\", associativity: \"right\"};\n\n// Percentage\nexports.percent  = {arity: 1, position: \"post\", operator: \"%\", function: \"percent\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/arithmetic.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171212223539769",
            "created": "20171212223503019"
        },
        "$:/plugins/ebalster/formula/operators/compare.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Equality\nexports.eq  = {arity: 2, precedence: 0,   operator: \"=\",  function: \"eq\"};\nexports.ne  = {arity: 2, precedence: 0,   operator: \"<>\", function: \"ne\"};\n\n// Inequality\nexports.gt  = {arity: 2, precedence: 0,   operator: \">\",  function: \"gt\"};\nexports.gte = {arity: 2, precedence: 0,   operator: \">=\", function: \"gte\"};\nexports.lt  = {arity: 2, precedence: 0,   operator: \"<\",  function: \"lt\"};\nexports.lte = {arity: 2, precedence: 0,   operator: \"<=\", function: \"lte\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/compare.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171214050739104",
            "created": "20171214050556123"
        },
        "$:/plugins/ebalster/formula/operators/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Concatenate\nexports.concatenate = {arity: 2, precedence: 4, operator: \"&\", function: \"cat\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/strings.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171213003346943",
            "created": "20171213003246267"
        },
        "$:/plugins/ebalster/formula/readme": {
            "text": "''Formula'' for TiddlyWiki, version {{$:/plugins/ebalster/formula!!version}}, by Evan Balster.\n\nFormulas are written between `(=` mushroom brackets `=)`.  Where possible, their functions and syntax are designed to emulate popular spreadsheet software (Microsoft Excel and Google Sheets).  They //also// support WikiText-like syntax for `{{`transclusion`}}`, `[`filters`]`, `<<`variables`>>`, and a large number of functions.\n\nFormulas can also be evaluated by the `$formula` widget, the `$formula-vars` widget and the `<<formula>>` macro.\n\nFurther documentation is available here: [[https://evanbalster.com/tiddlywiki/formulas.html]].\n\nThis plugin is a work in progress; please report any issues on GitHub: [[https://github.com/EvanBalster/TiddlyWikiFormula/issues]].",
            "bag": "default",
            "revision": "0",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/ebalster/formula/readme",
            "tags": "",
            "modified": "20171220212520970",
            "created": "20171220042006170",
            "caption": "readme"
        },
        "$:/plugins/ebalster/formula/settings": {
            "text": "Currently no global settings are implemented, but formulas can be controlled by setting some global macros.  For example:\n\n|Macro|Meaning|h\n|`\\define formulaFixed() 2`|makes numbers display with 2 decimal points.|\n|`\\define formulaPrecision() 4`|makes numbers display with 4 significant digits (but `formulafixed` takes priority.|\n|`\\define formulaDateFormat() YYYY-MM-0DD`|Sets a date display format using the same rules as TiddlyWiki.|\n\nPlace these at the top of the tiddler where they should take effect, or create a tiddler tagged with <<tag $:/tags/Macro>> to make them apply to all tiddlers.\n\nIn the future, we'll probably add some global settings here...",
            "bag": "default",
            "revision": "0",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/ebalster/formula/settings",
            "tags": "",
            "modified": "20171221002035357",
            "created": "20171221001634811",
            "caption": "readme"
        },
        "$:/plugins/ebalster/formula/value.js": {
            "text": "(function(){\n\n\"use strict\";\n\n\nexports.NumberFormatFunc = null;\n\nexports.DateFormat = \"0hh:0mm, DDth MMM YYYY\";\n\n\n// Base type for formula values\nexports.Value = function() {\n  this.name = \"unknown-value\";\n};\n\n// Get the value payload\nexports.Value.prototype.get = function()    {return undefined;};\n\n// Describe the value\nexports.Value.prototype.describe = function()    {return this.name + \" (\" + String(this.get()) + \")\";};\n\nexports.Value.prototype.toString = function()    {return \"[Value \" + this.describe() + \"]\";};\n\n// Get the value as a number (generic implementation)\nexports.Value.prototype.asNum = function() {\n  var v = this.get();\n  var n = Number(v);\n  if (isNaN(n)) throw \"Cannot convert \" + this.describe() + \" to a number!\";\n  return n;\n};\n\n// Get the value as a number, summing arrays (generic implementation)\nexports.Value.prototype.asSum = function() {\n  var v = this.get();\n  var n;\n  if (Array.isArray(v)) {n = 0; for (var i = 0; i < v.length; ++i) n += Number(v[i]);}\n  else                  n = Number(v);\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n};\n\n// More convertsions\nexports.Value.prototype.asString = function() {\n  return String(this.get());\n};\nexports.Value.prototype.asArray = function() {\n  var v = this.get();\n  if (Array.isArray(v)) return v;\n  else return [v];\n};\nexports.Value.prototype.asDate = function() {\n  throw \"Cannot convert \" + this.describe() + \" to a date!\";\n};\n\n\n// Undefined value.\nexports.V_Undefined = function() {\n  this.name = \"undefined\";\n};\nexports.V_Undefined.prototype = new exports.Value();\nexports.V_Undefined.prototype.get = function()    {return undefined;};\n\n\n// Array value.\nexports.V_Array = function(value) {\n  this.name = \"array\";\n\n  this.value = value;\n};\nexports.V_Array.prototype = new exports.Value();\nexports.V_Array.prototype.get   = function() {return this.value;};\nexports.V_Array.prototype.asNum = function() {throw \"Cannot convert \" + this.describe() + \" to number!\";};\nexports.V_Array.prototype.asSum = function() {\n  var n = 0;\n  for (var i = 0; i < this.value.length; ++i) n += this.value[i].asNum();\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n};\nexports.V_Array.prototype.asString     = function() {\n  var result = \"\";\n  for (var i = 0; i < this.value.length; ++i) {\n    var part = this.value[i].asString();\n    if (i && part.length) result += \" \";\n    if (part.indexOf(/\\s/g) >= 0) result += \"[[\" + part + \"]]\";\n    else result += part;\n  }\n  return result;\n};\n\n\n// String value.\nexports.V_Text = function(value) {\n  this.name = \"string\";\n\n  this.value = value;\n};\nexports.V_Text.prototype = new exports.Value();\nexports.V_Text.prototype.get    = function()    {return this.value;};\n//exports.V_Text.prototype.asDate = function() {return $tw.utils.parseDate();}\n\n\n// Date value.\nexports.V_Date = function(value) {\n  this.name = \"date\";\n\n  this.value = value;\n};\nexports.V_Date.prototype = new exports.Value();\nexports.V_Date.prototype.get      = function()    {return this.value;};\nexports.V_Date.prototype.asString = function()    {return $tw.utils.formatDateString(this.value, exports.DateFormat);};\nexports.V_Date.prototype.asNum    = function()    {throw \"Date-to-Number conversion usupported\";};\nexports.V_Date.prototype.asSum    = function()    {throw \"Date-to-Number conversion usupported\";};\nexports.V_Date.prototype.asDate   = function()    {return this.value;};\n\n\n// Boolean value.\nexports.V_Bool = function(value) {\n  this.name = \"boolean\";\n\n  this.value = value;\n};\nexports.V_Bool.prototype = new exports.Value();\nexports.V_Bool.prototype.get      = function()    {return this.value;};\nexports.V_Bool.prototype.asString = function()    {return this.value ? \"TRUE\" : \"FALSE\";};\nexports.V_Bool.prototype.asNum    = function()    {return this.value ? 1 : 0;};\nexports.V_Bool.prototype.asSum    = function()    {return this.value ? 1 : 0;};\n\n\n// Number value.\nexports.V_Num = function(value) {\n  this.name = \"number\";\n\n  this.value = value;\n};\nexports.V_Num.prototype = new exports.Value();\nexports.V_Num.prototype.get      = function()    {return this.value;};\nexports.V_Num.prototype.asString = function()    {return (exports.NumberFormatFunc || String)(this.value);};\nexports.V_Num.prototype.asNum    = function()    {return this.value;};\nexports.V_Num.prototype.asSum    = function()    {return this.value;};\n\n\n// Percentage value.\nexports.V_Percent = function(value) {\n  this.name = \"percentage\";\n\n  this.value = value;\n};\nexports.V_Percent.prototype = new exports.V_Num();\nexports.V_Percent.prototype.asString = function()\n{\n  return (exports.NumberFormatFunc || String)(100*this.value) + \"%\";\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/value.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211195014088",
            "description": "",
            "created": "20171211195003728"
        },
        "$:/plugins/ebalster/formula/widgets/attributes/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\nvar FormulaAttribute = function(widget, node) {\n\tthis.widget = widget;\n\tthis.formula = node.formula;\n\ttry {\n\t\tthis.compiledFormula = Formulas.compileFormula(this.formula);\n\t}\n\tcatch (err) {\n\t\tthis.compiledFormula = new Operands.Opd_Error(err);\n\t}\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new Attribute();\n\nFormulaAttribute.prototype.compute = function() {\n\t// Compute options\n\tthis.formatOptions =\n\t{\n\t\tfixed:      (this.widget.getVariable(\"formulaFixed\")),\n\t\tprecision:  (this.widget.getVariable(\"formulaPrecision\")),\n\t\tdateFormat: (this.widget.getVariable(\"formulaDateFormat\")),\n\t};\n\t// Execute the formula.\n\treturn Formulas.computeFormula(this.compiledFormula, this.widget, this.formatOptions);\n};\n\nFormulaAttribute.prototype.refresh = function(changedTiddlers) {\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.formula = FormulaAttribute;\n\n})();\n\t",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/widgets/attributes/formula.js",
            "tags": "",
            "module-type": "attributevalue",
            "modified": "20171225035808674",
            "description": "Evaluates a formula as an attribute value string.",
            "created": "20171225035721011"
        },
        "$:/plugins/ebalster/formula/widgets/formula-vars.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\nvar FormulaVarsWidget = function(parseTreeNode,options) {\n\t// Call the constructor\n\tWidget.call(this);\n\t// Initialise\t\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaVarsWidget.prototype = Object.create(Widget.prototype);\n\n/*\nRender this widget into the DOM\n*/\nFormulaVarsWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nRecompute formulas\n*/\nFormulaVarsWidget.prototype.formula_recompute = function() {\n\t// Parse variables\n\tvar self = this;\n\n\tthis.formatOptions =\n\t{\n\t\tfixed:      (this.getAttribute(\"$toFixed\")     || this.parentWidget.getVariable(\"formulaFixed\")),\n\t\tprecision:  (this.getAttribute(\"$toPrecision\") || this.parentWidget.getVariable(\"formulaPrecision\")),\n\t\tdateFormat: (this.getAttribute(\"$dateFormat\")  || this.parentWidget.getVariable(\"formulaDateFormat\")),\n\t};\n\n\tif (!this.currentValues)\n\t{\n\t\t// Initial values\n\t\tthis.currentValues = {};\n\t\tthis.formulaSrc = {};\n\t\tthis.formulaComp = {};\n\t}\n\n\t$tw.utils.each(this.attributes,function(val,key) {\n\t\tif(key.charAt(0) !== \"$\") {\n\t\t\t// Recompile if necessary\n\t\t\tif (self.formulaSrc[key] != val) {\n\t\t\t\tself.formulaSrc[key] = val;\n\t\t\t\ttry {\n\t\t\t\t\tself.formulaComp[key] = Formulas.compileFormula(self.formulaSrc[key]);\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tself.formulaComp[key] = new Operands.Opd_Error(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Recompute the formula\n\t\t\tif (self.formulaComp[key]) {\n\t\t\t\tself.currentValues[key] = Formulas.computeFormula(\n\t\t\t\t\tself.formulaComp[key], self, self.formatOptions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself.currentValues[key] = \"Error: formula not assigned\";\n\t\t\t}\n\t\t}\n\t});\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaVarsWidget.prototype.execute = function() {\n\t// Recompute formulas\n\tthis.formula_recompute();\n\n\tfor (var key in this.currentValues) {\n\t\tthis.setVariable(key, this.currentValues[key]);\n\t}\n\n\t// Construct the child widgets\n\tthis.makeChildWidgets();\n};\n\n/*\nRefresh the widget by ensuring our attributes are up to date\n*/\nFormulaVarsWidget.prototype.refresh = function formulaVarsRefresh(changedTiddlers) {\n\tthis.computeAttributes();\n\tvar oldValues = Object.assign({}, this.currentValues || {});\n\tthis.formula_recompute();\n\n\t// Did any computed values change?\n\tvar changedValues = false;\n\tfor (var key in this.currentValues) {\n\t\tif (this.currentValues[key] !== oldValues[key]) {\n\t\t\tthis.setVariable(key, this.currentValues[key]);\n\t\t\tchangedValues = true;\n\t\t}\n\t}\n\n\tif (this.getAttribute(\"$noRebuild\") === \"true\") changedValues = false;\n\n\tif(changedValues) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn this.refreshChildren(changedTiddlers);\n\t}\n};\n\nexports[\"formula-vars\"] = FormulaVarsWidget;\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/widgets/formula-vars.js",
            "tags": "",
            "module-type": "widget",
            "modified": "20171222071557661",
            "description": "As the $vars widget, but each attribute is interpreted as a formula.",
            "created": "20171216003055342"
        },
        "$:/plugins/ebalster/formula/widgets/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\nvar FormulaWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nFormulaWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.rerender(parent,nextSibling);\n};\n\nFormulaWidget.prototype.rerender = function(parent, nextSibling) {\n\n\tthis.removeChildDomNodes();\n\n\t// Parse the value, or, failing this, produce a text node.\n\tvar parser = this.wiki.parseText(\n\t\tthis.wikifyType, this.currentValue,\n\t\t{parseAsInline: this.wikifyMode === \"inline\"});\n\tvar parseTreeNodes = (parser ? parser.tree : [{type: \"text\", text: this.currentValue}]);\n\n\t// Construct and render the child widgets.\n\tthis.makeChildWidgets(parseTreeNodes);\n\tthis.renderChildren(parent,nextSibling);\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaWidget.prototype.execute = function() {\n\n\tvar oldFormula = this.formula;\n\n\t// Get parameters from our attributes\n\tthis.formula   = this.getAttribute(\"formula\");\n\tthis.debug     = this.getAttribute(\"debug\");\n\n\tthis.wikifyType = this.getAttribute(\"outputType\");\n\tthis.wikifyMode = this.getAttribute(\"outputMode\",\"inline\");\n\n\tthis.formatOptions =\n\t{\n\t\tfixed:      (this.getAttribute(\"toFixed\")     || this.getVariable(\"formulaFixed\")),\n\t\tprecision:  (this.getAttribute(\"toPrecision\") || this.getVariable(\"formulaPrecision\")),\n\t\tdateFormat: (this.getAttribute(\"dateFormat\")  || this.getVariable(\"formulaDateFormat\")),\n\t};\n\n\t// Compile the formula, if it has changed, yielding compiledFormula\n\tif(this.formula !== oldFormula) {\n\t\tif (this.formula) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.compiledFormula = Formulas.compileFormula(this.formula);\n\t\t\t}\n\t\t\tcatch (err) {this.compiledFormula = new Operands.Opd_Error(err);}\n\t\t}\n\t\telse {\n\t\t\tthis.compiledFormula = null;\n\t\t}\n\t}\n\n\t// Compute the formula, yielding currentValue\n\tif(this.compiledFormula) {\n\t\tthis.currentValue = Formulas.computeFormula(this.compiledFormula, this, this.formatOptions, Boolean(this.debug));\n\t} else {\n\t\tthis.currentValue = \"`Error: formula not assigned`\";\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nFormulaWidget.prototype.refresh = function(changedTiddlers) {\n\t// Re-execute the filter to get the count\n\tthis.computeAttributes();\n\tvar oldValue = this.currentValue;\n\tthis.execute();\n\tif(this.currentValue !== oldValue) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\t//   We DON'T call refreshSelf() because it call execute() again\n\t\tvar nextSibling = this.findNextSiblingDomNode();\n\t\tthis.rerender(this.parentDomNode,nextSibling);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\n};\n\nexports.formula = FormulaWidget;\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/widgets/formula.js",
            "tags": "",
            "module-type": "widget",
            "modified": "20171212194059701",
            "description": "Evaluates a formula.",
            "created": "20171210232543292"
        },
        "$:/plugins/ebalster/formula/wikiparser/attributes/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\nexports.formula = function(source, pos, node) {\n\t// Is it a formula?\n\tvar reFormulaValue = /\\(=(([^=]+|=[^\\)])*)=\\)/g;\n\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reFormulaValue);\n\tif (!value) return null;\n\n\tnode.type = \"formula\";\n\tnode.formula = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/wikiparser/attributes/formula.js",
            "tags": "",
            "module-type": "attributerule",
            "modified": "20171225042523039",
            "description": "Tag attribute rule for formulas.  Ex. `(= 2+2 =)`",
            "created": "20171224060415431"
        },
        "$:/plugins/ebalster/formula/wikiparser/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.name = \"formula\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\t// Regexp to match\n\tthis.matchRegExp = /\\(=/mg;\n\tthis.endMatchRegExp = /=\\)/mg;\n};\n\nexports.parse = function() {\n\t// Move past the match\n\tthis.parser.pos = this.matchRegExp.lastIndex;\n\t// Look for the end marker\n\tthis.endMatchRegExp.lastIndex = this.parser.pos;\n\tvar match = this.endMatchRegExp.exec(this.parser.source),\n\t\ttext;\n\t// Process the text\n\tif(match) {\n\t\ttext = this.parser.source.substring(this.parser.pos,match.index);\n\t\tthis.parser.pos = match.index + match[0].length;\n\t} else {\n\t\ttext = this.parser.source.substr(this.parser.pos);\n\t\tthis.parser.pos = this.parser.sourceLength;\n\t}\n\treturn [{\n\t\ttype: \"formula\",\n\t\tattributes: {\n\t\t\tformula: {type: \"string\", value: text},\n\t\t}\n\t}];\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/wikiparser/formula.js",
            "tags": "",
            "module-type": "wikirule",
            "modified": "20171211181716654",
            "description": "Wiki text inline rule for formulas.  Ex. `((=2+2))`",
            "created": "20171211033327565"
        }
    }
}