created: 20171209233132315
description: Spreadsheet-like formulas in TiddlyWiki.
modified: 20171215035316074
name: TiddlyFormula
plugin-type: plugin
tags: 
title: $:/plugins/ebalster/formula
type: application/json
version: 0.1.0

{
    "tiddlers": {
        "$:/plugins/ebalster/formula/compile.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Values    = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Operands  = require(\"$:/plugins/ebalster/formula/operands.js\");\nvar Operators = require(\"$:/plugins/ebalster/formula/operators.js\");\n\nvar rxDatumIsFormula      = /^\\s*\\(=.*=\\)\\s*$/;\nvar rxDatumIsDecimal      = /^\\s*[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))\\s*$/;\nvar rxDatumIsTrue         = /^s*TRUE\\s*$/i;\nvar rxDatumIsFalse        = /^s*FALSE\\s*$/i;\n\nvar rxSkipWhitespace    = /\\s*/g;\nvar rxNotWhitespace     = /[^\\s]+/g;\nvar rxOperandFilter     = /\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]/g;\nvar rxOperandTransclusion =     /\\{\\{[^\\{\\}]+\\}\\}/g;\nvar rxDatumIsTransclusion = /^\\s*\\{\\{[^\\{\\}]+\\}\\}\\s*$/;\nvar rxOperandVariable     =     /<<[^<>]+>>/g;\nvar rxDatumIsVariable     = /^\\s*<<[^<>]+>>\\s*$/;\nvar rxCellName            = /[a-zA-Z]{1,2}[0-9]+/g;\nvar rxIdentifier          = /[_a-zA-Z][_a-zA-Z0-9]*/g;\n\nvar rxUnsignedDecimal =      /((\\d+(\\.\\d*)?)|(\\.\\d+))/g\nvar rxDecimal         = /[+-]?((\\d+(\\.\\d*)?)|(\\.\\d+))/g\n\nvar rxString          = /(\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*')/g\n\nvar formulaFunctions   = null;\nvar operatorsUnaryPre  = null;\nvar operatorsUnaryPost = null;\nvar operatorsBinary    = null;\nvar operatorsTernary   = null;\n\nfunction Parser(src)\n{\n  this.src = src;\n  this.pos = 0;\n  this.end = src.length;\n}\nParser.prototype.getChar = function()\n{\n  return this.src.charAt(this.pos);\n}\nParser.prototype.remaining = function()\n{\n  return this.src.substring(this.pos, this.end);\n}\nParser.prototype.nextToken = function()\n{\n  rxNotWhitespace.lastIndex = this.pos;\n  rxNotWhitespace.test(this.src);\n  return this.src.substring(this.pos, rxNotWhitespace.lastIndex);\n}\nParser.prototype.match_here = function(regex)\n{\n  // TODO this is doing much more work than is necessary\n  regex.lastIndex = this.pos;\n  var result = regex.exec(this.src);\n  if (!result || result.index != this.pos || result.index+result[0].length > this.end) return null;\n  this.pos = regex.lastIndex;\n  return result;\n}\nParser.prototype.skipWhitespace = function()\n{\n  rxSkipWhitespace.lastIndex = this.pos;\n  rxSkipWhitespace.test(this.src);\n  this.pos = Math.min(rxSkipWhitespace.lastIndex, this.end);\n}\n\nvar initialize = function() {\n  formulaFunctions = {};\n  var operators = {}\n  $tw.modules.applyMethods(\"formula-function\", formulaFunctions);\n  $tw.modules.applyMethods(\"formula-operator\", operators);\n\n  operatorsUnaryPre = {};\n  operatorsUnaryPost = {};\n  operatorsBinary = {}; //{}; //{plus: {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"}};\n  operatorsTernary = {};\n  for (var opName in operators)\n  {\n    var op = operators[opName];\n\n    // Bind the associated function.  \n    var func = formulaFunctions[op.function];\n    if (!func) continue;\n    op.func_bind = func;\n\n    // Sort the op by arity and position.\n    switch (op.arity)\n    {\n    case 2:           operatorsBinary  [opName] = op; break;\n    case 3:           operatorsTernary [opName] = op; break;\n    case 1:\n      switch (op.position)\n      {\n        case \"pre\":  operatorsUnaryPre [opName] = op; break;\n        case \"post\": operatorsUnaryPost[opName] = op; break;\n      }\n      break;\n    }\n  }\n}\n\n\nexports.compileExpression = function(expression) {\n\n  // Create a parser and process the formula as an expression.\n  var parser = new Parser(expression);\n\n  var operand = buildExpression(parser);\n\n  return operand;\n};\n\nexports.compileDatum = function(datum) {\n\n  // Could be a number?\n  if (rxDatumIsDecimal.test(datum)) {\n    // Treat as a number constant\n    return new Operands.Opd_Number(Number(datum));\n  }\n\n  // Could be a formula?\n  if (rxDatumIsFormula.test(datum)) {\n    // Parse contents as a formula\n    var parser = new Parser(datum);\n    parser.pos = datum.indexOf(\"=\")+1;\n    parser.end = datum.lastIndexOf(\"=\");\n    return buildExpression(parser);\n  }\n\n  // Could be a transclusion or variable?\n  if (rxDatumIsTransclusion.test(datum) ||\n      rxDatumIsVariable.test(datum)) {\n    // Defer to the operand parser...\n    var parser = new Parser(datum);\n    return buildOperand(parser);\n  }\n\n  // Booleans?\n  if (rxDatumIsFalse.test(datum)) return new Operands.Opd_Bool(false);\n  if (rxDatumIsTrue .test(datum)) return new Operands.Opd_Bool(true);\n\n  // Otherwise, treat as a string constant\n  return new Operands.Opd_Text(datum);\n};\n\nexports.compileFormula = function(formulaString)\n{\n  // Process the formula string into a root operand\n  try\n  {\n    return exports.compileExpression(formulaString);\n  }\n  catch (err)    {return new Operands.Opd_Text(\"`FormulaError: \" + err + \"`\");}\n}\n\nexports.computeFormula = function(compiledFormula, widget, numberFormat=null, debug=false) {\n  \n  var value;\n\n  Values.NumberFormatFunc = numberFormat;\n\n  // Compute a value from the root operand of the compiled formula.\n  try\n  {\n    value = compiledFormula.compute(widget, 0);\n  }\n  catch (err)    {return \"`ComputeError: \" + String(err) + \"\\noperand: \" + String(compiledFormula) + \"`\";}\n\n  // Format the root operand as a string.\n  try\n  {\n    if (debug) return value.asString() + \"\\n - Val:\" + String(value) + \", Op:\" + compiledFormula.name;\n    else       return value.asString();\n  }\n  catch (err)    {return \"`ValueError: \" + String(err) + \"\\nvalue: \" + String(value) + \"`\";}\n};\n\nexports.evalFormula = function(formulaString, widget, numberFormat=null, debug=false) {\n  \n  var compiledFormula;\n\n  // Compile the formula\n  try\n  {\n    var compiledFormula = exports.compileExpression(formulaString);\n  }\n  catch (err)    {return \"`FormulaError: \" + String(err) + \"`\";}\n\n  // Compute the formula\n  return exports.computeFormula(compiledFormula, widget, numberFormat, debug);\n};\n\n\n\n// Compile an operator\nfunction parseOperator(parser, operatorGroup) {\n\n  // Skip more whitespace\n  parser.skipWhitespace();\n\n  var result = null;\n\n  // Find the longest operator matching the current text.\n  for (var opName in operatorGroup)\n  {\n    var op = operatorGroup[opName];\n    if (parser.src.substr(parser.pos, op.operator.length) == op.operator\n      && parser.pos+op.operator.length <= parser.end)\n    {\n      if (!result || result.operator.length < op.operator.length) result = op;\n    }\n  }\n\n  if (result) parser.pos += result.operator.length;\n\n  return result;\n}\n\n// Parse a formula.\nfunction buildExpression(parser, nested = false) {\n  \n  // Make sure math functions are initialized\n  if (!formulaFunctions) initialize();\n\n  parser.skipWhitespace();\n\n  var operands = [];\n  var operators = [];\n  var precedences = [];\n\n  while (true)\n  {\n    var unaries = [];\n\n    // Prefix operators\n    while (true)\n    {\n      var prefix = parseOperator(parser, operatorsUnaryPre);\n      if (prefix) unaries.unshift(prefix);\n      else break;\n    }\n\n    // Grab the operand\n    var operand = buildOperand(parser);\n\n    // Missing operand is an error\n    if (operand === null)\n    {\n      var token = parser.nextToken();\n      if (token && token[0] != \")\" && token[0] != \",\")\n        throw \"invalid operand\\\"\" + token + \"\\\"\";\n      else if (operators.length)\n        throw \"missing operand after \\\"\" + operators[operators.length-1].operator + \"\\\"\";\n      else throw \"empty expression\";\n    }\n\n    // Postfix operators\n    while (true)\n    {\n      var postfix = parseOperator(parser, operatorsUnaryPost);\n      if (postfix) unaries.push(postfix);\n      else break;\n    }\n\n    unaries.forEach(function(unary) {\n      operand = new Operators.CallOperator(unary.func_bind, [operand]);\n    });\n\n    operands.push(operand);\n\n    // Infix operators\n    var operator = parseOperator(parser, operatorsBinary);\n\n    // Missing operator ends the expression\n    if (operator === null) break;\n\n    // Add the operator and its precedence level.\n    operators.push(operator);\n    var precedence = operator.precedence;\n    if (precedences.indexOf(precedence || 0) == -1) precedences.push(precedence);\n  }\n\n  // Sanity check\n  if (operands.length != operators.length+1)\n    throw \"internal error: operator/operand parsing inconsistency\";\n\n  // Resolve operators by precedence\n  precedences.sort(function(a,b) {return (a>b)?-1:1;});\n\n  for (var j = 0; j < precedences.length; ++j)\n  {\n    var prec = precedences[j];\n    for (var i = 0; i < operators.length; )\n    {\n      // Process only operators at the current precedence level.\n      var op = operators[i];\n      if (op.precedence != prec) {++i; continue;}\n\n      // Collapse the previous and next operands with this operator.\n      operands[i] = new Operators.CallOperator(op.func_bind, [operands[i], operands[i+1]]);\n      operators.splice(i, 1);\n      operands.splice(i+1, 1);\n    }\n  }\n\n  // Sanity check\n  if (operators.length != 0 || operands.length != 1)\n    throw \"internal error: resoving failed; \" + operands.length + \" operands and \" + operators.length + \" operators remain\";\n\n  // For non-nested expressions, throw if any tokens remain.\n  if (!nested)\n  {\n    parser.skipWhitespace();\n\n    if (parser.pos < parser.end)\n    {\n      throw \"expected operator, got \\\"\" + parser.nextToken() + \"\\\"\";\n    }\n  }\n\n  return operands[0];\n};\n\n// Compile a function argument list.  Error if the next \nfunction buildArguments(parser) {\n\n  // Skip whitespace\n  parser.skipWhitespace();\n\n  // Argument list present?\n  if (parser.getChar() != \"(\") return null;\n  ++parser.pos;\n\n  // Zero arguments?\n  parser.skipWhitespace();\n  if (parser.getChar() == \")\") return [];\n  \n  var results = [];\n\n  while (true)\n  {\n    // Compile an expression.\n    results.push(buildExpression(parser, true));\n\n    // Skip more whitespace\n    parser.skipWhitespace();\n\n    // Expect ) or , after argument.\n    var char = parser.getChar();\n    ++parser.pos;\n    if (char == \")\") break;\n    if (char != \",\") throw \"Expect ',' or ')' after function argument\";\n  }\n\n  return results;\n};\n\n// Compile an operand into a function returning the operand value.\nfunction buildOperand(parser) {\n\n  var term;\n  \n  // Skip whitespace\n  parser.skipWhitespace();\n\n  if (parser.pos == parser.end) return null;\n\n  var char = parser.getChar();\n\n  if (char.match(/[0-9\\.+=]/i))\n  {\n    // Number constant\n    term = parser.match_here(rxDecimal);\n    if (term) return new Operands.Opd_Number(Number(term[0]));\n    throw \"Invalid number: \" + parser.nextToken();\n  }\n  else if (char.match(/[a-z]/i))\n  {\n    // Cell name?\n    term = parser.match_here(rxCellName);\n    if (term) return new Operands.Opd_Transclude(\"##\" + term[0]);\n\n    // Function call?\n    term = parser.match_here(rxIdentifier);\n\n    if (term)\n    {\n      var func = formulaFunctions[term[0].toLowerCase()];\n\n      if (!func) throw \"unknown function: \" + term[0];\n\n      var args = buildArguments(parser);\n\n      // Omitting arguments is only OK for zero-parameter functions.\n      if (args == null)\n      {\n        if (func.min_args || func.length) throw \"Expected '(' after \" + term[0];\n        args = [];\n      }\n\n      if (func instanceof Function)\n      {\n        // Check parameter count\n        if (args.length > func.length && !func.variadic)\n          throw \"too many arguments for \" + term[0] + \" (max \" + func.length + \")\";\n        if (args.length < func.length)\n          throw \"too few arguments for \" + term[0] + \" (min \" + func.length + \")\";\n      }\n      else\n      {\n        // Use a \"select\" function\n        if (func.max_args && args.length > func.max_args)\n          throw \"too many arguments for \" + term[0] + \" (max \" + func.max_args + \")\";\n        if (func.min_args && args.length < func.min_args)\n          throw \"too few arguments for \" + term[0] + \" (min \" + func.min_args + \")\";\n        func = func.select(args);\n      }\n\n      return new Operators.CallOperator(func, args);\n    }\n  }\n  else switch (char)\n  {\n  case \"(\": // Parenthesized expression\n    ++parser.pos;\n    var parentheses = buildExpression(parser, true);\n    parser.skipWhitespace();\n    if (parser.getChar() != \")\")\n    {\n      if (parser.pos == parser.end) throw \"missing ')' at end of formula\";\n      else                          throw \"expected ')', got \\\"\" + parser.nextToken() + \"\\\"\";\n    }\n    ++parser.pos;\n    return parentheses;\n    break;\n\n  case \"'\":\n  case \"\\\"\": // String constant\n    term = parser.match_here(rxString);\n    if (term) return new Operands.Opd_Text(term[0].substr(1, term[0].length-2));\n    throw \"Invalid string: \" + parser.nextToken();\n    break;\n\n  case \"[\": // Filter operand\n    term = parser.match_here(rxOperandFilter);\n    if (term) return new Operands.Opd_Filter(term[0]);\n    break;\n\n  case \"{\": // Transclusion operand\n    term = parser.match_here(rxOperandTransclusion);\n    if (term) return new Operands.Opd_Transclude(term[0].substring(2, term[0].length-2));\n    break;\n\n  case \"<\": // Variable operand\n    term = parser.match_here(rxOperandVariable);\n    if (term) return new Operands.Opd_Variable(term[0].substring(2, term[0].length-2));\n    break;\n  }\n\n  // Didn't recognize the operand\n  return null;\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/compile.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211181652443",
            "description": "",
            "created": "20171210195223539"
        },
        "$:/plugins/ebalster/formula/functions/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Unary sign operators\nexports.uplus  = function(a)    {return new a;};\nexports.uminus = function(a)    {return new Val.V_Num(-a.asNum());};\n\n// Add\nexports.add = function(a, b)    {return new Val.V_Num(a.asSum() + b.asSum());};\nexports.sub = function(a, b)    {return new Val.V_Num(a.asSum() - b.asSum());};\n\n// Multiply\nexports.mul = function(a, b)    {return new Val.V_Num(a.asNum() * b.asNum());};\nexports.div = function(a, b)    {return new Val.V_Num(a.asNum() / b.asNum());};\n\n// Percent -- TODO make this a different value-type\nexports.percent = function(a, b)    {return new Val.V_Percent(a.asNum() / 100);};\n\n\n// Aliases\nexports.subtract = exports.sub;\nexports.minus    = exports.sub;\nexports.multiply = exports.mul;\nexports.divide   = exports.div;\nexports.quotient = exports.div;\nexports.power    = exports.pow;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/arithmetic.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171212223526867",
            "created": "20171211192843088"
        },
        "$:/plugins/ebalster/formula/functions/compare.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Equality\nexports.eq  = function(a, b)    {return new Val.V_Bool(a.get() == b.get());};\nexports.ne  = function(a, b)    {return new Val.V_Bool(a.get() != b.get());};\n\n// Inequality\nexports.gt  = function(a, b)    {return new Val.V_Bool(a.get() >  b.get());};\nexports.gte = function(a, b)    {return new Val.V_Bool(a.get() >= b.get());};\nexports.lt  = function(a, b)    {return new Val.V_Bool(a.get() <  b.get());};\nexports.lte = function(a, b)    {return new Val.V_Bool(a.get() <= b.get());};\n\n\n// Aliases\nexports.equal            = exports.eq;\nexports.not_equal        = exports.ne;\nexports.greater          = exports.gt;\nexports.greater_or_equal = exports.gte;\nexports.less             = exports.lt;\nexports.less_or_equal    = exports.lte;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/compare.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214050803365",
            "created": "20171214050022626"
        },
        "$:/plugins/ebalster/formula/functions/logic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Constants\nexports.true  = function()    {return new Val.V_Bool(true);};\nexports.false = function()    {return new Val.V_Bool(false);};\n\n// Logical operators\nexports.not = function(a)       {return new Val.V_Bool(!a.get());};\nexports.and = function(a, b)    {return new Val.V_Bool(a.get() && b.get());};\nexports.or  = function(a, b)    {return new Val.V_Bool(a.get() || b.get());};\nexports.xor = function(a, b)    {return new Val.V_Bool(a.get() ? !b.get() : !!b.get());};\n\n// Ternary\nexports.if  = function(p, a, b) {return p.get() ? a.get() : b.get();};\n\n\n// IFERROR\nexports.iferror = function(a, b) {try {return a.get();} catch (err) {return b.get();}};\n\n\n// SWITCH (variadic)\nexports.switch =\n{\n  min_args: 3,\n  select: function(operands)\n  {\n    switch (operands.length % 2)\n    {\n    default:\n    case 0: return function(a) // Switch with default\n      {\n        var value = a.get();\n        for (var i = 1; i+1 < arguments.length; i += 2)\n          {if (arguments[i].get() == value) return arguments[i+1];}\n        return arguments[arguments.length-1];\n      }\n    case 1: return function(a) // Switch, no default\n      {\n        var value = a.get();\n        for (var i = 1; i+1 < arguments.length; i += 2)\n          {if (arguments[i].get() == value) return arguments[i+1];}\n        return new Val.V_Undefined();\n      }\n    }\n  }\n};\n\n// CHOOSE (variadic)\nexports.choose = function(a, b)\n{\n  var index = Math.floor(a.asNum());\n  var result = arguments[index];\n  if (index < 1 || !result) return new Val.V_Undefined();\n  return result;\n};\nexports.choose.variadic = true;\n\n// IFS function (variadic)\nexports.ifs =\n{\n  min_args : 2,\n  select : function(operands)\n  {\n    if (operands.length % 2 != 0)\n      throw \"Odd number of arguments to IFS\";\n\n    return function()\n    {\n      for (var i = 0; i < arguments.length; i += 2)\n        {if (arguments[i].get()) return arguments[i+1];}\n      return new Val.V_Undefined();\n    };\n  }\n};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/logic.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214060456114",
            "created": "20171214054240274"
        },
        "$:/plugins/ebalster/formula/functions/math.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\nvar V_Num = Val.V_Num;\n\n\n// Constants\nexports.pi = function()    {return new V_Num(Math.PI);}\nexports._e = function()    {return new V_Num(Math.E);}\n\n\n// Random\nexports.rand        = function()        {return new V_Num(Math.random());}\nexports.randbetween = function(a, b)    {a=a.asNum(); b=b.asNum(); return new V_Num(a+(b-a)*Math.random());}\nexports.random = exports.rand;\n\n\n// Sign and absolute value\nexports.abs  = function(a)    {return new V_Num(Math.abs(a.asNum()));}\nexports.sign = function(a)    {var x = a.asNum(); return new V_Num(((x > 0) - (x < 0)) || +x);}\n\n// Min/max\nexports.min = function(a)\n{\n    var min = a.asNum();\n    for (var i = 1; i < arguments.length; ++i) min = Math.min(min, arguments[i].asNum());\n    return new V_Num(min);\n}\nexports.min.variadic = true;\n\nexports.max = function(a)\n{\n    var max = a.asNum();\n    for (var i = 1; i < arguments.length; ++i) max = Math.max(max, arguments[i].asNum());\n    return new V_Num(max);\n}\nexports.max.variadic = true;\n\n\n/*\n    Series arithmetic\n*/\nexports.sum =\n{\n    min_args : 1,\n    select : function(operands)\n    {\n        switch (operands)\n        {\n        case 1: return function(a) {return new Val.V_Num(a.asSum());};\n        default: return function()\n            {\n                var sum = 0;\n                for (var i = 0; i < arguments.length; ++i) sum += arguments[i].asSum();\n                return new V_Num(sum);\n            }\n        }\n    }\n};\nexports.product = function()\n{\n    var product = 1;\n    for (var i = 0; i < arguments.length; ++i) product *= arguments[i].asNum();\n    return new V_Num(product);\n};\nexports.product.variadic = true;\n\n\n/*\n    Exponential\n*/\n\n// Exponentiation and logarithm\nexports.pow   = function(a, b)    {return new V_Num(Math.pow(a.asNum(), b.asNum()));};\nexports.exp   = function(a)       {return new V_Num(Math.exp(a.asNum()));}\nexports.log   = function(a, b)    {return new V_Num(Math.log(a.asNum()) / Math.log(b.asNum()));}\nexports.ln    = function(a)       {return new V_Num(Math.log(a.asNum()));}\nexports.log2  = function(a)       {return new V_Num(Math.log2(a.asNum()));}\nexports.log10 = function(a)       {return new V_Num(Math.log10(a.asNum()));}\n\nexports.power = exports.pow;\n\n// Precise exponentiation and logarithm\nexports.expm1 = function(a)       {return new V_Num(Math.expm1(a.asNum()));}\nexports.log1p = function(a)       {return new V_Num(Math.log1p(a.asNum()));}\n\n// Roots\nexports.sqrt = function(a)    {return new V_Num(Math.sqrt(a.asNum()));}\nexports.cbrt = function(a)    {return new V_Num(Math.cbrt(a.asNum()));}\n\n\n/*\n    Trigonometry\n*/\n\n// Conversion\nexports.radians = function(a)    {return new V_Num(Math.PI*a.asNum()/180);}\nexports.degrees = function(a)    {return new V_Num(180*a.asNum()/Math.PI);}\n\n// Trigonometry\nexports.sin = function(a)    {return new V_Num(  Math.sin(a.asNum()));}\nexports.cos = function(a)    {return new V_Num(  Math.cos(a.asNum()));}\nexports.tan = function(a)    {return new V_Num(  Math.tan(a.asNum()));}\nexports.csc = function(a)    {return new V_Num(1/Math.sin(a.asNum()));}\nexports.sec = function(a)    {return new V_Num(1/Math.cos(a.asNum()));}\nexports.cot = function(a)    {return new V_Num(1/Math.tan(a.asNum()));}\n\n// Inverse Trigonometry\nexports.asin = function(a)    {return new V_Num(Math.asin(  a.asNum()));}\nexports.acos = function(a)    {return new V_Num(Math.acos(  a.asNum()));}\nexports.atan = function(a)    {return new V_Num(Math.atan(  a.asNum()));}\nexports.acsc = function(a)    {return new V_Num(Math.asin(1/a.asNum()));}\nexports.asec = function(a)    {return new V_Num(Math.acos(1/a.asNum()));}\nexports.acot = function(a)    {return new V_Num(Math.atan(1/a.asNum()));}\n\n// Hyperbolic Trigonometry\nexports.sinh = function(a)    {return new V_Num(  Math.sinh(a.asNum()));}\nexports.cosh = function(a)    {return new V_Num(  Math.cosh(a.asNum()));}\nexports.tanh = function(a)    {return new V_Num(  Math.tanh(a.asNum()));}\nexports.csch = function(a)    {return new V_Num(1/Math.sinh(a.asNum()));}\nexports.sech = function(a)    {return new V_Num(1/Math.cosh(a.asNum()));}\nexports.coth = function(a)    {return new V_Num(1/Math.tanh(a.asNum()));}\n\n// Inverse Hyperbolic Trigonometry\nexports.asinh = function(a)    {return new V_Num(Math.asinh(  a.asNum()));}\nexports.acosh = function(a)    {return new V_Num(Math.acosh(  a.asNum()));}\nexports.atanh = function(a)    {return new V_Num(Math.atanh(  a.asNum()));}\nexports.acsch = function(a)    {return new V_Num(Math.asinh(1/a.asNum()));}\nexports.asech = function(a)    {return new V_Num(Math.acosh(1/a.asNum()));}\nexports.acoth = function(a)    {return new V_Num(Math.atanh(1/a.asNum()));}\n\n/*\n    Rounding, ceiling and floor functions.\n        Special measures were taken to reproduce the conventions.\n*/\n\nvar signedFloor = Math.trunc || function(n) {return (n<0) ? Math.ceil (n) : Math.floor(n);}\nvar signedCeil  =               function(n) {return (n<0) ? Math.floor(n) : Math.ceil (n);}\n\nfunction genCeilFloor(operands, func)\n{\n    switch (operands.length)\n    {\n    case 1: return function(a)    {return new V_Num(func(a.asNum()));};\n    case 2: return function(a, b) {var prec = b.asNum(); return func(a.asNum()/prec) * prec;};\n    }\n}\n\nfunction genRound(operands, func)\n{\n    switch (operands.length)\n    {\n    case 1: return function(a)    {return new V_Num(func(a.asNum()));};\n    case 2: return function(a, b) {var prec = Math.pow(10, b.asNum()); return func(a.asNum()/prec) * prec;};\n    }\n}\n\n\nexports.floor =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.floor);}\n};\nexports.ceil =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.ceil);}\n};\n/*exports.floor_precise =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.floor);}\n};\nexports.ceil_precise =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genCeilFloor(operands, Math.ceil);}\n};*/\nexports.round =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, Math.round);}\n};\nexports.roundup =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, signedCeil);}\n};\nexports.rounddown =\n{\n    min_args : 1, max_args : 2,\n    select : function(operands) {return genRound(operands, signedFloor);}\n};\n\nexports.trunc = exports.rounddown;\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/math.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171214171708994",
            "created": "20171214171454666"
        },
        "$:/plugins/ebalster/formula/functions/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Val = require(\"$:/plugins/ebalster/formula/value.js\");\n\n\n// Concatenate\nexports.cat = function(a, b)    {return new Val.V_Text(a.asString() + b.asString());};\n\n\n// Aliases\nexports.concatenate = exports.cat;\n\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/functions/strings.js",
            "tags": "",
            "module-type": "formula-function",
            "modified": "20171213003237206",
            "created": "20171213003135495"
        },
        "$:/plugins/ebalster/formula/macros/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\n  Information about this macro\n*/\n\nexports.name = \"formula\";\nexports.params = [{\"name\": \"formula\"}];\n\n/*\nRun the macro\n*/\nexports.run = function(formula) {\n\n  var formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n  return formulas.evalFormula(formula, this);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/macros/formula.js",
            "tags": "",
            "module-type": "macro",
            "modified": "20171212194124031",
            "created": "20171210215758530"
        },
        "$:/plugins/ebalster/formula/operands.js": {
            "text": "/*\\\ntitle: $:/core/modules/macros/csvtiddlers.js\ntype: application/javascript\nmodule-type: macro\n\nLibrary defining formula operands.\nOperands represent some value within the formula: an expression, datum, operator, constant or query...\nOperands may be constant, allowing the formula compiler to optimize them away.\n\n\\*/\n(function(){\n\n\"use strict\";\n\nvar Values   = require(\"$:/plugins/ebalster/formula/value.js\");\n\nexports.Operand = function() {\n}\nexports.Operand.prototype.is_constant = false;\nexports.Operand.prototype.name = \"unknown-operand\";\n\n// Operand::compute -- produce\nexports.Operand.prototype.compute = (function(widget, recur) {return new Values.V_Undefined();});\n\n\n// String constant operand.\nexports.Opd_Text = function(value) {\n  this.value = value;\n}\nexports.Opd_Text.prototype = new exports.Operand();\nexports.Opd_Text.prototype.name = \"string\";\nexports.Opd_Text.prototype.is_constant = true;\n\nexports.Opd_Text.prototype.compute = function(widget, recur)\n{\n  // Returns a string value\n  return new Values.V_Text(this.value);\n}\n\n\n// Boolean constant operand.\nexports.Opd_Bool = function(value) {\n  this.value = value;\n}\nexports.Opd_Bool.prototype = new exports.Operand();\nexports.Opd_Bool.prototype.name = \"boolean\";\nexports.Opd_Bool.prototype.is_constant = true;\n\nexports.Opd_Bool.prototype.compute = function(widget, recur)\n{\n  // Returns a number value\n  return new Values.V_Bool(this.value);\n}\n\n\n// Number constant operand.\nexports.Opd_Number = function(value) {\n  this.value = value;\n}\nexports.Opd_Number.prototype = new exports.Operand();\nexports.Opd_Number.prototype.name = \"number\";\nexports.Opd_Number.prototype.is_constant = true;\n\nexports.Opd_Number.prototype.compute = function(widget, recur)\n{\n  // Returns a number value\n  return new Values.V_Num(this.value);\n}\n\n\nvar Compile = require(\"$:/plugins/ebalster/formula/compile.js\");\n\n\n// Opd_Transcluded operand.\nexports.Opd_Transclude = function(textReference) {\n  this.textReference = textReference;\n  this.datum = null;\n  this.op = null;\n}\nexports.Opd_Transclude.prototype = new exports.Operand();\nexports.Opd_Transclude.prototype.name = \"transclude\";\n\nexports.Opd_Transclude.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.wiki.getTextReference(this.textReference, \"\", widget.getVariable(\"currentTiddler\"));\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    try\n    {\n      this.op = Compile.compileDatum(newDatum);\n    }\n    catch (err) {throw err + \"\\n  source: \\\"\" + this.datum + \"\\\"\\n  from {{\" + this.textReference + \"}}\";}\n  }\n\n  return this.op.compute(widget, recur+1);\n}\n\n\n// Opd_Variable operand.\nexports.Opd_Variable = function(variable) {\n  this.variable = variable;\n  this.datum = null;\n  this.op = null;\n}\nexports.Opd_Variable.prototype = new exports.Operand();\nexports.Opd_Variable.prototype.name = \"variable\";\n\nexports.Opd_Variable.prototype.compute = function(widget, recur) {\n\n  var newDatum = widget.getVariable(this.variable) || \"\";\n\n  if (newDatum != this.datum)\n  {\n    this.datum = newDatum;\n    try\n    {\n      this.op = Compile.compileDatum(newDatum);\n    }\n    catch (err) {throw err + \"\\n  source: \\\"\" + this.datum + \"\\\"\\n  from <<\" + this.variable + \">>\";}\n  }\n\n  return this.op.compute(widget, recur+1);\n}\n\n\n// Opd_Filter operand.\nexports.Opd_Filter = function(filter) {\n  this.filter = filter;\n  this.elements = {};\n}\nexports.Opd_Filter.prototype = new exports.Operand();\nexports.Opd_Filter.prototype.name = \"filter\";\n\nexports.Opd_Filter.prototype.compute = function(widget, recur) {\n  // Apply the filter and compile each result\n  var exprs = widget.wiki.filterTiddlers(this.filter, widget);\n\n  // Mark all existing elements for removal\n  for (var expr in this.elements) this.elements[expr].count = 0;\n\n  // Selectively re-compile any filter results that have changed\n  for (var i = 0; i < exprs.length; ++i)\n  {\n    var expr = exprs[i];\n    var found = this.elements[expr];\n    if (found) ++found.count;\n    else try\n    {\n      this.elements[expr] = {count: 1, op: Compile.compileDatum(expr)};\n    }\n    catch (err) {throw err + \"\\n  source: \\\"\" + expr + \"\\\"\\n  from \\\"\" + this.filter + \"\\\"\";}\n  }\n  \n\n  // Delete any elements with no copies left\n  for (var expr in this.elements) if (this.elements[expr].count == 0) delete this.elements[expr];\n\n  // Return value computes an array of datum values.\n  var results = [];\n  for (var expr in this.elements) {\n    var elem = this.elements[expr];\n    results.push(elem.op.compute(widget, recur+1));\n  }\n  return new Values.V_Array(results);\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operands.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183031273",
            "description": "",
            "created": "20171211183000431"
        },
        "$:/plugins/ebalster/formula/operators.js": {
            "text": "(function(){\n\n\"use strict\";\n\nvar Values   = require(\"$:/plugins/ebalster/formula/value.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\n\nexports.Operator = function Operator() {\n}\nexports.Operator.prototype.name = \"unknown-operator\";\nexports.Operator.prototype = new Operands.Operand();\n\n/*\nexports.UnaryOperator = function UnaryOperator() {\n  this.first = null;\n}\nexports.UnaryOperator.prototype = new exports.Operator();\nexports.UnaryOperator.prototype.name = \"unknown-unary-operator\";\n\n\nexports.BinaryOperator = function BinaryOperator() {\n  this.first = null;\n  this.second = null;\n}\nexports.BinaryOperator.prototype = new exports.Operator();\nexports.BinaryOperator.prototype.name = \"unknown-binary-operator\";\n*/\n\nexports.CallOperator = function CallOperator(func, args) {\n  this.func = func;\n  this.args = args;\n}\nexports.CallOperator.prototype = new exports.Operator();\nexports.CallOperator.prototype.name = \"function-call\";\nexports.CallOperator.prototype.compute = (function(widget, recur) {\n  var vals = [];\n  this.args.forEach(function(arg) {vals.push(arg.compute(widget, recur));});\n  return this.func.apply(null, vals);\n});\n\n/*\nexports.BinaryMathOperator = function BinaryMathOperator() {\n}\nexports.BinaryMathOperator.prototype = new exports.BinaryOperator();\nexports.BinaryMathOperator.prototype.name = \"unknown-binary-math-operator\";\nexports.BinaryMathOperator.prototype.compute = (function(widget, recur) {\n  return mathOp(this.first.compute(widget, recur).asNum(), this.first.compute(widget, recur).asNum());\n});\n\n\n// Identity operator (used for unary plus)\nexports.Operator_UnaryPlus = function Operator_UnaryPlus(first) {this.first = first;}\nexports.Operator_UnaryPlus.prototype = new exports.UnaryOperator();\nexports.Operator_UnaryPlus.prototype.name = \"unary-plus\";\nexports.Operator_UnaryPlus.prototype.compute = function(widget, recur) {return +this.first.compute(widget, recur).asSum();}\n\n// Negation operator (used for unary minus)\nexports.Operator_UnaryMinus = function Operator_UnaryMinus(first) {this.first = first;}\nexports.Operator_UnaryMinus.prototype = new exports.UnaryOperator();\nexports.Operator_UnaryMinus.prototype.name = \"unary-minus\";\nexports.Operator_UnaryMinus.prototype.compute = function(widget, recur) {return -this.first.compute(widget, recur).asSum();}\n\n\n// Addition operator\nexports.Operator_Plus = function Operator_Plus(first, second) {this.first = first; this.second = second;}\nexports.Operator_Plus.prototype = new exports.BinaryMathOperator();\nexports.Operator_Plus.prototype.name = \"plus\";\nexports.Operator_Plus.prototype.mathOp = function(a, b) {return a+b;}\n\n// Subtraction operator\nexports.Operator_Minus = function Operator_Minus(first, second) {this.first = first; this.second = second;}\nexports.Operator_Minus.prototype = new exports.BinaryMathOperator();\nexports.Operator_Minus.prototype.name = \"minus\";\nexports.Operator_Minus.prototype.mathOp = function(a, b) {return a-b;}\n\n// Multiplication operator\nexports.Operator_Multiply = function Operator_Multiply(first, second) {this.first = first; this.second = second;}\nexports.Operator_Multiply.prototype = new exports.BinaryMathOperator();\nexports.Operator_Multiply.prototype.name = \"multiply\";\nexports.Operator_Multiply.prototype.mathOp = function(a, b) {return a*b;}\n\n// Division operator\nexports.Operator_Divide = function Operator_Divide(first, second) {this.first = first; this.second = second;}\nexports.Operator_Divide.prototype = new exports.BinaryMathOperator();\nexports.Operator_Divide.prototype.name = \"divide\";\nexports.Operator_Divide.prototype.mathOp = function(a, b) {return a/b;}\n\n// Division operator\nexports.Operator_Exponent = function Operator_Exponent(first, second) {this.first = first; this.second = second;}\nexports.Operator_Exponent.prototype = new exports.BinaryMathOperator();\nexports.Operator_Exponent.prototype.name = \"exponent\";\nexports.Operator_Exponent.prototype.mathOp = function(a, b) {return Math.pow(a, b);}\n*/\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211183054390",
            "description": "",
            "created": "20171211183047843"
        },
        "$:/plugins/ebalster/formula/operators/arithmetic.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Unary sign operators\nexports.uplus    = {arity: 1, position: \"pre\",  operator: \"+\", function: \"uplus\"};\nexports.uminus   = {arity: 1, position: \"pre\",  operator: \"-\", function: \"uminus\"};\n\n// Add\nexports.plus     = {arity: 2, precedence: 10,   operator: \"+\", function: \"add\"};\nexports.minus    = {arity: 2, precedence: 10,   operator: \"-\", function: \"sub\"};\n\n// Multiply\nexports.multiply = {arity: 2, precedence: 20,   operator: \"*\", function: \"mul\"};\nexports.divide   = {arity: 2, precedence: 20,   operator: \"/\", function: \"div\"};\n\n// Exponential\nexports.pow      = {arity: 2, precedence: 30,   operator: \"^\", function: \"pow\", associativity: \"right\"};\n\n// Percentage\nexports.percent  = {arity: 1, position: \"post\", operator: \"%\", function: \"percent\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/arithmetic.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171212223539769",
            "created": "20171212223503019"
        },
        "$:/plugins/ebalster/formula/operators/compare.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// Equality\nexports.eq  = {arity: 2, precedence: 0,   operator: \"=\",  function: \"eq\"};\nexports.ne  = {arity: 2, precedence: 0,   operator: \"<>\", function: \"ne\"};\n\n// Inequality\nexports.gt  = {arity: 2, precedence: 0,   operator: \">\",  function: \"gt\"};\nexports.gte = {arity: 2, precedence: 0,   operator: \">=\", function: \"gte\"};\nexports.lt  = {arity: 2, precedence: 0,   operator: \"<\",  function: \"lt\"};\nexports.lte = {arity: 2, precedence: 0,   operator: \"<=\", function: \"lte\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/compare.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171214050739104",
            "created": "20171214050556123"
        },
        "$:/plugins/ebalster/formula/operators/strings.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n// Concatenate\nexports.concatenate = {arity: 2, precedence: 4, operator: \"&\", function: \"cat\"};\n\n})();",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/operators/strings.js",
            "tags": "",
            "module-type": "formula-operator",
            "modified": "20171213003346943",
            "created": "20171213003246267"
        },
        "$:/plugins/ebalster/formula/value.js": {
            "text": "(function(){\n\n\"use strict\";\n\n\nexports.NumberFormatFunc = null;\n\n\n// Base type for formula values\nexports.Value = function() {\n  this.name = \"unknown-value\";\n}\n\n// Get the value payload\nexports.Value.prototype.get = function()    {return undefined;};\n\n// Describe the value\nexports.Value.prototype.describe = function()    {return this.name + \" (\" + String(this.get()) + \")\";}\n\nexports.Value.prototype.toString = function()    {return \"[Value \" + this.describe() + \"]\";}\n\n// Get the value as a number (generic implementation)\nexports.Value.prototype.asNum = function() {\n  var v = this.get();\n  var n = Number(v);\n  if (isNaN(n)) throw \"Cannot convert \" + this.describe() + \" to a number!\";\n  return n;\n}\n\n// Get the value as a number, summing arrays (generic implementation)\nexports.Value.prototype.asSum = function() {\n  var v = this.get();\n  var n;\n  if (Array.isArray(v)) {n = 0; for (var i = 0; i < v.length; ++i) n += Number(v[i]);}\n  else                  n = Number(v);\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n}\n\n// Get the value as a string\nexports.Value.prototype.asString = function() {\n  return String(this.get());\n}\n\n// Get the value as an array\nexports.Value.prototype.asArray = function() {\n  var v = this.get();\n  if (Array.isArray(v)) return v;\n  else return [v];\n}\n\n\n// Undefined value.\nexports.V_Undefined = function() {\n  this.name = \"undefined\";\n}\nexports.V_Undefined.prototype = new exports.Value();\nexports.V_Undefined.prototype.get = function()    {return undefined;}\n\n\n// String value.\nexports.V_Text = function(value) {\n  this.name = \"string\";\n\n  this.value = value;\n}\nexports.V_Text.prototype = new exports.Value();\nexports.V_Text.prototype.get = function()    {return this.value;}\n\n\n// Array value.\nexports.V_Array = function(value) {\n  this.name = \"array\";\n\n  this.value = value;\n}\nexports.V_Array.prototype = new exports.Value();\nexports.V_Array.prototype.get      = function()                {return this.value;}\nexports.V_Array.prototype.asNum = function()                {throw \"Cannot convert \" + this.describe() + \" to number!\";}\nexports.V_Array.prototype.asSum    = function() {\n  var n = 0;\n  for (var i = 0; i < this.value.length; ++i) n += this.value[i].asNum();\n  if (isNaN(n)) throw \"Cannot sum \" + this.describe() + \" to a number!\";\n  return n;\n}\nexports.V_Array.prototype.asString     = function() {\n  var result = \"[\";\n  if (this.value.length) result += this.value[0].asString();\n  for (var i = 1; i < this.value.length; ++i) result += \",\" + this.value[i].asString();\n  return result + \"]\";\n}\n\n\n// Number value.\nexports.V_Bool = function(value) {\n  this.name = \"boolean\";\n\n  this.value = value;\n}\nexports.V_Bool.prototype = new exports.Value();\nexports.V_Bool.prototype.get      = function()    {return this.value;}\nexports.V_Bool.prototype.asString = function()    {return this.value ? \"TRUE\" : \"FALSE\";}\nexports.V_Bool.prototype.asNum = function()    {return this.value ? 1 : 0;}\nexports.V_Bool.prototype.asSum    = function()    {return this.value ? 1 : 0;}\n\n\n// Number value.\nexports.V_Num = function(value) {\n  this.name = \"number\";\n\n  this.value = value;\n}\nexports.V_Num.prototype = new exports.Value();\nexports.V_Num.prototype.get      = function()    {return this.value;}\nexports.V_Num.prototype.asString = function()    {return (exports.NumberFormatFunc || String)(this.value);}\nexports.V_Num.prototype.asNum = function()    {return this.value;}\nexports.V_Num.prototype.asSum    = function()    {return this.value;}\n\n\n// Percentage value.\nexports.V_Percent = function(value) {\n  this.name = \"percentage\";\n\n  this.value = value;\n}\nexports.V_Percent.prototype = new exports.V_Num();\nexports.V_Percent.prototype.asString = function()\n{\n  return (exports.NumberFormatFunc || String)(100*this.value) + \"%\";\n}\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/value.js",
            "tags": "",
            "module-type": "library",
            "modified": "20171211195014088",
            "description": "",
            "created": "20171211195003728"
        },
        "$:/plugins/ebalster/formula/widgets/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar Formulas = require(\"$:/plugins/ebalster/formula/compile.js\");\nvar Operands = require(\"$:/plugins/ebalster/formula/operands.js\");\n\nvar FormulaWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nFormulaWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nFormulaWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar textNode = this.document.createTextNode(this.currentValue);\n\tparent.insertBefore(textNode,nextSibling);\n\tthis.domNodes.push(textNode);\n};\n\n/*\nCompute the internal state of the widget\n*/\nFormulaWidget.prototype.execute = function() {\n\n\tvar oldFormula = this.formula;\n\n\t// Get parameters from our attributes\n\tthis.formula   = this.getAttribute(\"formula\");\n\tthis.debug     = this.getAttribute(\"debug\");\n\tvar vPrecision = this.getAttribute(\"toPrecision\") || this.getVariable(\"formulaPrecision\");\n\tvar vFixed     = this.getAttribute(\"toFixed\")     || this.getVariable(\"formulaFixed\");\n\n\t// Compile the formula, if it has changed, yielding compiledFormula\n\tif(this.formula !== oldFormula) {\n\t\tif (this.formula) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.compiledFormula = Formulas.compileFormula(this.formula);\n\t\t\t}\n\t\t\tcatch (err) {this.compiledFormula = new Operands.Opd_String(err);}\n\t\t}\n\t\telse {\n\t\t\tthis.compiledFormula = null;\n\t\t}\n\t}\n\n\t// Compute the formula, yielding currentValue\n\tif(this.compiledFormula) {\n\t\tvar numberFormat = null;\n\t\tif      (vFixed    ) numberFormat = function(num) {return num.toFixed    (vFixed);};\n\t\telse if (vPrecision) numberFormat = function(num) {return num.toPrecision(vPrecision);};\n\t\tthis.currentValue = Formulas.computeFormula(this.compiledFormula, this, numberFormat, Boolean(this.debug));\n\t} else {\n\t\tthis.currentValue = \"`Error: formula not assigned`\";\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nFormulaWidget.prototype.refresh = function(changedTiddlers) {\n\t// Re-execute the filter to get the count\n\tthis.computeAttributes();\n\tvar oldValue = this.currentValue;\n\tthis.execute();\n\tif(this.currentValue !== oldValue) {\n\t\t// Regenerate and rerender the widget and replace the existing DOM node\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n\n};\n\nexports.formula = FormulaWidget;\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/widgets/formula.js",
            "tags": "",
            "module-type": "widget",
            "modified": "20171212194059701",
            "description": "Evaluates a formula.",
            "created": "20171210232543292"
        },
        "$:/plugins/ebalster/formula/wikiparser/formula.js": {
            "text": "(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.name = \"formula\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\t// Regexp to match\n\tthis.matchRegExp = /\\(=/mg;\n\tthis.endMatchRegExp = /=\\)/mg;\n};\n\nexports.parse = function() {\n\t// Move past the match\n\tthis.parser.pos = this.matchRegExp.lastIndex;\n\t// Look for the end marker\n\tthis.endMatchRegExp.lastIndex = this.parser.pos;\n\tvar match = this.endMatchRegExp.exec(this.parser.source),\n\t\ttext;\n\t// Process the text\n\tif(match) {\n\t\ttext = this.parser.source.substring(this.parser.pos,match.index);\n\t\tthis.parser.pos = match.index + match[0].length;\n\t} else {\n\t\ttext = this.parser.source.substr(this.parser.pos);\n\t\tthis.parser.pos = this.parser.sourceLength;\n\t}\n\treturn [{\n\t\ttype: \"formula\",\n\t\tattributes: {\n\t\t\tformula: {type: \"string\", value: text},\n\t\t}\n\t}];\n};\n\n})();\n",
            "bag": "default",
            "revision": "0",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/formula/wikiparser/formula.js",
            "tags": "",
            "module-type": "wikirule",
            "modified": "20171211181716654",
            "description": "Wiki text inline rule for formulas.  Ex. `((=2+2))`",
            "created": "20171211033327565"
        }
    }
}