core-version: >=5.1.22-pre
created: NaNNaNNaNNaNNaNNaNNaN
dependents: 
modified: NaNNaNNaNNaNNaNNaNNaN
plugin-type: plugin
revision: 0
title: $:/plugins/ebalster/attribute-modules
type: application/json
version: 0.0.7

{
    "tiddlers": {
        "$:/core/modules/parsers/wikiparser/attributes/filtered.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/filtered.js",
            "created": "20171224215126050",
            "description": "Tag attribute rule for filtered values, eg. {{{[all[shadows]]}}}.",
            "modified": "20171224215155435",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/filtered.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for filtered values, eg. {{{[all[shadows]]}}}.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.filtered = function(source,pos,node) {\n\t// Is it a filtered value?\n\tvar reFilteredValue = /\\{\\{\\{(.+?)\\}\\}\\}/g;\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);\n\tif (!value) return null;\n\tnode.type = \"filtered\";\n\tnode.filter = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/parsers/wikiparser/attributes/indirect.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/indirect.js",
            "created": "20171224214929513",
            "description": "Tag attribute rule for transcluded values, eg. {{Layout!!height}}.",
            "modified": "20171224215110965",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/indirect.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for transcluded values, eg. {{Layout!!height}}.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.indirect = function(source,pos,node) {\n\t// Is it an indirect (transcluded) value?\n\tvar reIndirectValue = /\\{\\{([^\\{\\}]+)\\}\\}/g;\n\tvar value = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);\n\tif (!value) return null;\n\tnode.type = \"indirect\";\n\tnode.textReference = value.match[1];\n\tnode.end = value.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/parsers/wikiparser/attributes/macro.js": {
            "title": "$:/core/modules/parsers/wikiparser/attributes/macro.js",
            "created": "20171224215158051",
            "description": "Tag attribute rule for macros and variables, eg. <<currentTiddler>>.",
            "modified": "20171224215427368",
            "module-type": "attributerule",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/parsers/wikiparser/attributes/macro.js\ntype: application/javascript\nmodule-type: attributerule\n\nTag attribute parser rule for macros and variables, eg. <<currentTiddler>>.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.macro = function(source,pos,node) {\n\t// Is it a macro invocation?\n\tvar macroInvocation = $tw.utils.parseMacroInvocation(source,pos);\n\tif (!macroInvocation) return null;\n\tnode.type = \"macro\";\n\tnode.value = macroInvocation;\n\tnode.end = macroInvocation.end;\n\treturn node;\n};\n\n})();"
        },
        "$:/core/modules/widgets/attributes/filtered.js": {
            "title": "$:/core/modules/widgets/attributes/filtered.js",
            "created": "20171225042329213",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042338300",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/filtered.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via filter expression.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar FilteredAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.filter = node.filter;\n\tthis.compiledFilter = this.widget.wiki.compileFilter(this.filter);\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nFilteredAttribute.prototype.compute = function() {\n\tthis.results = this.compiledFilter.call(this.widget.wiki,undefined,this.widget);\n\t// TODO why only one result?  Can we return a list??\n\treturn this.results[0] || \"\";\n};\n\nFilteredAttribute.prototype.refresh = function(changedTiddlers) {\n\t// TODO can filters be selectively refreshed in the future?\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.filtered = FilteredAttribute;\n\n})();\n\t"
        },
        "$:/core/modules/widgets/attributes/indirect.js": {
            "title": "$:/core/modules/widgets/attributes/indirect.js",
            "created": "20171225042213912",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042325491",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/indirect.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via filter expression.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar IndirectAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.textReference = $tw.utils.parseTextReference(node.textReference);\n\tif (!this.textReference.title) this.currentTiddler = this.widget.getVariable(\"currentTiddler\");\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nIndirectAttribute.prototype.compute = function() {\n\tvar tr = this.textReference,\n\t\ttitle = tr.title || this.currentTiddler,\n\t\twiki = this.widget.wiki;\n\tif(tr.field) {\n\t\tvar tiddler = wiki.getTiddler(title);\n\t\tif(tr.field === \"title\") { // Special case so we can return the title of a non-existent tiddler\n\t\t\treturn title;\n\t\t} else if(tiddler && $tw.utils.hop(tiddler.fields,tr.field)) {\n\t\t\treturn tiddler.getFieldString(tr.field);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t} else if(tr.index) {\n\t\treturn wiki.extractTiddlerDataItem(title,tr.index,\"\");\n\t} else {\n\t\treturn wiki.getTiddlerText(title,\"\");\n\t}\n};\n\nIndirectAttribute.prototype.refresh = function(changedTiddlers) {\n\tif (this.textReference.title) {\n\t\t// Recompute if the title tiddler changed.\n\t\tif (changedTiddlers[this.textReference.title])\n\t\t\tthis.value = this.compute();\n\t}\n\telse {\n\t\t// Did currentTiddler change?\n\t\tvar newTiddler = this.widget.getVariable(\"currentTiddler\");\n\t\tif (newTiddler != this.currentTiddler) {\n\t\t\tthis.currentTiddler = newTiddler;\n\t\t\tthis.value = this.compute();\n\t\t}\n\t\telse if (changedTiddlers[this.currentTiddler]) {\n\t\t\t// Recompute if the tiddler changed.\n\t\t\tthis.value = this.compute();\n\t\t}\n\t}\n\t// Return the latest value.\n\treturn this.value;\n};\n\n\nexports.indirect = IndirectAttribute;\n\n})();\n\t"
        },
        "$:/core/modules/widgets/attributes/macro.js": {
            "title": "$:/core/modules/widgets/attributes/macro.js",
            "created": "20171225042340029",
            "description": "An attribute value acquired via text reference.",
            "modified": "20171225042346461",
            "module-type": "attributevalue",
            "revision": "0",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\ntitle: $:/core/modules/widgets/attributes/macro.js\ntype: application/javascript\nmodule-type: attributevalue\n\nAn attribute value acquired via macro expansion.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar MacroAttribute = function(widget,node) {\n\tthis.widget = widget;\n\tthis.macro = node.value;\n\tthis.value = this.compute();\n};\n\n/*\nInherit from the base ??? class\n*/\n//FormulaAttribute.prototype = new AttributeGizmo();\n\nMacroAttribute.prototype.compute = function() {\n\tvar value = this.widget.getVariable(this.macro.name,{params: this.macro.params});\n\tif (value == null) value = \"\";\n\treturn value;\n};\n\nMacroAttribute.prototype.refresh = function(changedTiddlers) {\n\tthis.value = this.compute();\n\treturn this.value;\n};\n\n\nexports.macro = MacroAttribute;\n\n})();\n\t"
        },
        "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/utils/parseutils.js",
            "created": "20190629011900694",
            "modified": "20190630025250261",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\r\ntitle: $:/core/modules/utils/parseutils.js\r\ntype: application/javascript\r\nmodule-type: utils\n\nUtility functions concerned with parsing text into tokens.\n\nMost functions have the following pattern:\n\n* The parameters are:\r\n** `source`: the source string being parsed\r\n** `pos`: the current parse position within the string\r\n** Any further parameters are used to identify the token that is being parsed\r\n* The return value is:\r\n** null if the token was not found at the specified position\r\n** an object representing the token with the following standard fields:\r\n*** `type`: string indicating the type of the token\r\n*** `start`: start position of the token in the source string\r\n*** `end`: end position of the token in the source string\r\n*** Any further fields required to describe the token\n\nThe exception is `skipWhiteSpace`, which just returns the position after the whitespace.\n\n\\*/\r\n(function(){\n\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\n\n/*\r\nLook for a whitespace token. Returns null if not found, otherwise returns {type: \"whitespace\", start:, end:,}\r\n*/\r\nexports.parseWhiteSpace = function(source,pos) {\r\n\tvar p = pos,c;\r\n\twhile(true) {\r\n\t\tc = source.charAt(p);\r\n\t\tif((c === \" \") || (c === \"\\f\") || (c === \"\\n\") || (c === \"\\r\") || (c === \"\\t\") || (c === \"\\v\") || (c === \"\\u00a0\")) { // Ignores some obscure unicode spaces\r\n\t\t\tp++;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(p === pos) {\r\n\t\treturn null;\r\n\t} else {\r\n\t\treturn {\r\n\t\t\ttype: \"whitespace\",\r\n\t\t\tstart: pos,\r\n\t\t\tend: p\r\n\t\t}\r\n\t}\r\n};\n\n/*\r\nConvenience wrapper for parseWhiteSpace. Returns the position after the whitespace\r\n*/\r\nexports.skipWhiteSpace = function(source,pos) {\r\n\tvar c;\r\n\twhile(true) {\r\n\t\tc = source.charAt(pos);\r\n\t\tif((c === \" \") || (c === \"\\f\") || (c === \"\\n\") || (c === \"\\r\") || (c === \"\\t\") || (c === \"\\v\") || (c === \"\\u00a0\")) { // Ignores some obscure unicode spaces\r\n\t\t\tpos++;\r\n\t\t} else {\r\n\t\t\treturn pos;\r\n\t\t}\r\n\t}\r\n};\n\n/*\r\nLook for a given string token. Returns null if not found, otherwise returns {type: \"token\", value:, start:, end:,}\r\n*/\r\nexports.parseTokenString = function(source,pos,token) {\r\n\tvar match = source.indexOf(token,pos) === pos;\r\n\tif(match) {\r\n\t\treturn {\r\n\t\t\ttype: \"token\",\r\n\t\t\tvalue: token,\r\n\t\t\tstart: pos,\r\n\t\t\tend: pos + token.length\r\n\t\t};\r\n\t}\r\n\treturn null;\r\n};\n\n/*\r\nLook for a token matching a regex. Returns null if not found, otherwise returns {type: \"regexp\", match:, start:, end:,}\r\n*/\r\nexports.parseTokenRegExp = function(source,pos,reToken) {\r\n\tvar node = {\r\n\t\ttype: \"regexp\",\r\n\t\tstart: pos\r\n\t};\r\n\treToken.lastIndex = pos;\r\n\tnode.match = reToken.exec(source);\r\n\tif(node.match && node.match.index === pos) {\r\n\t\tnode.end = pos + node.match[0].length;\r\n\t\treturn node;\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n};\n\n/*\r\nLook for a string literal. Returns null if not found, otherwise returns {type: \"string\", value:, start:, end:,}\r\n*/\r\nexports.parseStringLiteral = function(source,pos) {\r\n\tvar node = {\r\n\t\ttype: \"string\",\r\n\t\tstart: pos\r\n\t};\r\n\tvar reString = /(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\")|(?:'([^']*)')/g;\r\n\treString.lastIndex = pos;\r\n\tvar match = reString.exec(source);\r\n\tif(match && match.index === pos) {\r\n\t\tnode.value = match[1] !== undefined ? match[1] :(\r\n\t\t\tmatch[2] !== undefined ? match[2] : match[3] \r\n\t\t\t\t\t);\r\n\t\tnode.end = pos + match[0].length;\r\n\t\treturn node;\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n};\n\n/*\r\nLook for a macro invocation parameter. Returns null if not found, or {type: \"macro-parameter\", name:, value:, start:, end:}\r\n*/\r\nexports.parseMacroParameter = function(source,pos) {\r\n\tvar node = {\r\n\t\ttype: \"macro-parameter\",\r\n\t\tstart: pos\r\n\t};\r\n\t// Define our regexp\r\n\tvar reMacroParameter = /(?:([A-Za-z0-9\\-_]+)\\s*:)?(?:\\s*(?:\"\"\"([\\s\\S]*?)\"\"\"|\"([^\"]*)\"|'([^']*)'|\\[\\[([^\\]]*)\\]\\]|([^\\s>\"'=]+)))/g;\r\n\t// Skip whitespace\r\n\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t// Look for the parameter\r\n\tvar token = $tw.utils.parseTokenRegExp(source,pos,reMacroParameter);\r\n\tif(!token) {\r\n\t\treturn null;\r\n\t}\r\n\tpos = token.end;\r\n\t// Get the parameter details\r\n\tnode.value = token.match[2] !== undefined ? token.match[2] : (\r\n\t\t\t\t\ttoken.match[3] !== undefined ? token.match[3] : (\r\n\t\t\t\t\t\ttoken.match[4] !== undefined ? token.match[4] : (\r\n\t\t\t\t\t\t\ttoken.match[5] !== undefined ? token.match[5] : (\r\n\t\t\t\t\t\t\t\ttoken.match[6] !== undefined ? token.match[6] : (\r\n\t\t\t\t\t\t\t\t\t\"\"\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\tif(token.match[1]) {\r\n\t\tnode.name = token.match[1];\r\n\t}\r\n\t// Update the end position\r\n\tnode.end = pos;\r\n\treturn node;\r\n};\n\n/*\r\nLook for a macro invocation. Returns null if not found, or {type: \"macrocall\", name:, parameters:, start:, end:}\r\n*/\r\nexports.parseMacroInvocation = function(source,pos) {\r\n\tvar node = {\r\n\t\ttype: \"macrocall\",\r\n\t\tstart: pos,\r\n\t\tparams: []\r\n\t};\r\n\t// Define our regexps\r\n\tvar reMacroName = /([^\\s>\"'=]+)/g;\r\n\t// Skip whitespace\r\n\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t// Look for a double less than sign\r\n\tvar token = $tw.utils.parseTokenString(source,pos,\"<<\");\r\n\tif(!token) {\r\n\t\treturn null;\r\n\t}\r\n\tpos = token.end;\r\n\t// Get the macro name\r\n\tvar name = $tw.utils.parseTokenRegExp(source,pos,reMacroName);\r\n\tif(!name) {\r\n\t\treturn null;\r\n\t}\r\n\tnode.name = name.match[1];\r\n\tpos = name.end;\r\n\t// Process parameters\r\n\tvar parameter = $tw.utils.parseMacroParameter(source,pos);\r\n\twhile(parameter) {\r\n\t\tnode.params.push(parameter);\r\n\t\tpos = parameter.end;\r\n\t\t// Get the next parameter\r\n\t\tparameter = $tw.utils.parseMacroParameter(source,pos);\r\n\t}\r\n\t// Skip whitespace\r\n\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t// Look for a double greater than sign\r\n\ttoken = $tw.utils.parseTokenString(source,pos,\">>\");\r\n\tif(!token) {\r\n\t\treturn null;\r\n\t}\r\n\tpos = token.end;\r\n\t// Update the end position\r\n\tnode.end = pos;\r\n\treturn node;\r\n};\n\n/*\r\nLook for an HTML attribute definition. Returns null if not found, otherwise returns {type: \"attribute\", name:, valueType: \"string|indirect|macro\", value:, start:, end:,}\r\n*/\r\nvar AttributeRules = null;\n\nexports.parseAttribute = function(source,pos) {\r\n\tvar node = {\r\n\t\tstart: pos\r\n\t};\r\n\t// Define our regexps\r\n\tvar reAttributeName = /([^\\/\\s>\"'=]+)/g,\r\n\t\treUnquotedAttribute = /([^\\/\\s<>\"'=]+)/g,\r\n\t\treFilteredValue = /\\{\\{\\{(.+?)\\}\\}\\}/g,\r\n\t\treIndirectValue = /\\{\\{([^\\}]+)\\}\\}/g;\r\n\t// Skip whitespace\r\n\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t// Get the attribute name\r\n\tvar name = $tw.utils.parseTokenRegExp(source,pos,reAttributeName);\r\n\tif(!name) {\r\n\t\treturn null;\r\n\t}\r\n\tnode.name = name.match[1];\r\n\tpos = name.end;\r\n\t// Skip whitespace\r\n\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t// Look for an equals sign\r\n\tvar token = $tw.utils.parseTokenString(source,pos,\"=\");\r\n\tif(token) {\r\n\t\tpos = token.end;\r\n\t\t// Skip whitespace\r\n\t\tpos = $tw.utils.skipWhiteSpace(source,pos);\r\n\t\t// Look for a string literal\r\n\t\tvar stringLiteral = $tw.utils.parseStringLiteral(source,pos);\r\n\t\tif(stringLiteral) {\r\n\t\t\t\t\t\t\t\r\n\t\t\tnode.type = \"string\";\r\n\t\t\tnode.value = stringLiteral.value;\r\n\t\t\tnode.end = stringLiteral.end;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\treturn node;\r\n\t\t}\r\n\t\t// Load attribute rules if needed\r\n\t\tif (!AttributeRules) {\r\n\t\t\tAttributeRules = {};\r\n\t\t\t$tw.modules.applyMethods(\"attributerule\",AttributeRules);\r\n\t\t}\r\n\t\t// Look for an attribute rule\r\n\t\tvar match = null;\r\n\t\t$tw.utils.each(AttributeRules,function(rule) {\r\n\t\t\tmatch = rule(source,pos,node);\r\n\t\t\treturn !match;\r\n\t\t});\r\n\t\tif (match) return match;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t// Look for a unquoted value\r\n\t\tvar unquotedValue = $tw.utils.parseTokenRegExp(source,pos,reUnquotedAttribute);\r\n\t\tif(unquotedValue) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\tnode.type = \"string\";\r\n\t\t\tnode.value = unquotedValue.match[1];\r\n\t\t\tnode.end = unquotedValue.end;\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\treturn node;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t} else {\r\n\t\t\tnode.type = \"string\";\r\n\t\t\tnode.value = \"true\";\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\r\n\t\r\n\t} else {\r\n\t\tnode.type = \"string\";\r\n\t\tnode.value = \"true\";\r\n\t}\r\n\t// Update the end position\r\n\tnode.end = pos;\r\n\treturn node;\r\n};\n\n})();\r\n\t"
        },
        "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patchSource/core/modules/widgets/widget.js",
            "created": "20190629011900694",
            "modified": "20190630025250261",
            "tags": "",
            "type": "application/javascript",
            "text": "/*\\\r\ntitle: $:/core/modules/widgets/widget.js\r\ntype: application/javascript\r\nmodule-type: widget\n\nWidget base class\n\n\\*/\r\n(function(){\n\n/*jslint node: true, browser: true */\r\n/*global $tw: false */\r\n\"use strict\";\n\n/*\r\nCreate a widget object for a parse tree node\r\n\tparseTreeNode: reference to the parse tree node to be rendered\r\n\toptions: see below\r\nOptions include:\r\n\twiki: mandatory reference to wiki associated with this render tree\r\n\tparentWidget: optional reference to a parent renderer node for the context chain\r\n\tdocument: optional document object to use instead of global document\r\n*/\r\nvar Widget = function(parseTreeNode,options) {\r\n\t\tthis.initialise(parseTreeNode,options);\r\n};\n\n/*\r\nInitialise widget properties. These steps are pulled out of the constructor so that we can reuse them in subclasses\r\n*/\r\nWidget.prototype.initialise = function(parseTreeNode,options) {\r\n\t// Bail if parseTreeNode is undefined, meaning  that the widget constructor was called without any arguments so that it can be subclassed\r\n\tif(parseTreeNode === undefined) {\r\n\t\treturn;\r\n\t}\r\n\toptions = options || {};\r\n\t// Save widget info\r\n\tthis.parseTreeNode = parseTreeNode;\r\n\tthis.wiki = options.wiki;\r\n\tthis.parentWidget = options.parentWidget;\r\n\tthis.variablesConstructor = function() {};\r\n\tthis.variablesConstructor.prototype = this.parentWidget ? this.parentWidget.variables : {};\r\n\tthis.variables = new this.variablesConstructor();\r\n\tthis.document = options.document;\r\n\tthis.attributes = {};\r\n\tthis.children = [];\r\n\tthis.domNodes = [];\r\n\tthis.eventListeners = {};\r\n\t// Hashmap of the widget classes\r\n\tif(!this.widgetClasses) {\r\n\t\t// Get widget classes\r\n\t\tWidget.prototype.widgetClasses = $tw.modules.applyMethods(\"widget\");\r\n\t\t// Process any subclasses\r\n\t\t$tw.modules.forEachModuleOfType(\"widget-subclass\",function(title,module) {\r\n\t\t\tif(module.baseClass) {\r\n\t\t\t\tvar baseClass = Widget.prototype.widgetClasses[module.baseClass];\r\n\t\t\t\tif(!baseClass) {\r\n\t\t\t\t\tthrow \"Module '\" + title + \"' is attemping to extend a non-existent base class '\" + module.baseClass + \"'\";\r\n\t\t\t\t}\r\n\t\t\t\tvar subClass = module.constructor;\r\n\t\t\t\tsubClass.prototype = new baseClass();\r\n\t\t\t\t$tw.utils.extend(subClass.prototype,module.prototype);\r\n\t\t\t\tWidget.prototype.widgetClasses[module.name || module.baseClass] = subClass;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t// Hashmap of the attribute classes\r\n\tif(!this.attributeClasses) {\r\n\t\tWidget.prototype.attributeClasses = $tw.modules.applyMethods(\"attributevalue\");\r\n\t}\r\n};\n\n/*\r\nRender this widget into the DOM\r\n*/\r\nWidget.prototype.render = function(parent,nextSibling) {\r\n\tthis.parentDomNode = parent;\r\n\tthis.execute();\r\n\tthis.renderChildren(parent,nextSibling);\r\n};\n\n/*\r\nCompute the internal state of the widget\r\n*/\r\nWidget.prototype.execute = function() {\r\n\tthis.makeChildWidgets();\r\n};\n\n/*\r\nSet the value of a context variable\r\nname: name of the variable\r\nvalue: value of the variable\r\nparams: array of {name:, default:} for each parameter\r\nisMacroDefinition: true if the variable is set via a \\define macro pragma (and hence should have variable substitution performed)\r\n*/\r\nWidget.prototype.setVariable = function(name,value,params,isMacroDefinition) {\r\n\tthis.variables[name] = {value: value, params: params, isMacroDefinition: !!isMacroDefinition};\r\n};\n\n/*\r\nGet the prevailing value of a context variable\r\nname: name of variable\r\noptions: see below\r\nOptions include\r\nparams: array of {name:, value:} for each parameter\r\ndefaultValue: default value if the variable is not defined\n\nReturns an object with the following fields:\n\nparams: array of {name:,value:} of parameters passed to wikitext variables\r\ntext: text of variable, with parameters properly substituted\r\n*/\r\nWidget.prototype.getVariableInfo = function(name,options) {\r\n\toptions = options || {};\r\n\tvar actualParams = options.params || [],\r\n\t\tparentWidget = this.parentWidget;\r\n\t// Check for the variable defined in the parent widget (or an ancestor in the prototype chain)\r\n\tif(parentWidget && name in parentWidget.variables) {\r\n\t\tvar variable = parentWidget.variables[name],\r\n\t\t\tvalue = variable.value,\r\n\t\t\tparams = this.resolveVariableParameters(variable.params,actualParams);\r\n\t\t// Substitute any parameters specified in the definition\r\n\t\t$tw.utils.each(params,function(param) {\r\n\t\t\tvalue = $tw.utils.replaceString(value,new RegExp(\"\\\\$\" + $tw.utils.escapeRegExp(param.name) + \"\\\\$\",\"mg\"),param.value);\r\n\t\t});\r\n\t\t// Only substitute variable references if this variable was defined with the \\define pragma\r\n\t\tif(variable.isMacroDefinition) {\r\n\t\t\tvalue = this.substituteVariableReferences(value);\t\t\t\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttext: value,\r\n\t\t\tparams: params\r\n\t\t};\r\n\t}\r\n\t// If the variable doesn't exist in the parent widget then look for a macro module\r\n\treturn {\r\n\t\ttext: this.evaluateMacroModule(name,actualParams,options.defaultValue)\r\n\t};\r\n};\n\n/*\r\nSimplified version of getVariableInfo() that just returns the text\r\n*/\r\nWidget.prototype.getVariable = function(name,options) {\r\n\treturn this.getVariableInfo(name,options).text;\r\n};\n\nWidget.prototype.resolveVariableParameters = function(formalParams,actualParams) {\r\n\tformalParams = formalParams || [];\r\n\tactualParams = actualParams || [];\r\n\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\r\n\t\tparamInfo, paramValue,\r\n\t\tresults = [];\r\n\t// Step through each of the parameters in the macro definition\r\n\tfor(var p=0; p<formalParams.length; p++) {\r\n\t\t// Check if we've got a macro call parameter with the same name\r\n\t\tparamInfo = formalParams[p];\r\n\t\tparamValue = undefined;\r\n\t\tfor(var m=0; m<actualParams.length; m++) {\r\n\t\t\tif(actualParams[m].name === paramInfo.name) {\r\n\t\t\t\tparamValue = actualParams[m].value;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If not, use the next available anonymous macro call parameter\r\n\t\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\r\n\t\t\tnextAnonParameter++;\r\n\t\t}\r\n\t\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\r\n\t\t\tparamValue = actualParams[nextAnonParameter++].value;\r\n\t\t}\r\n\t\t// If we've still not got a value, use the default, if any\r\n\t\tparamValue = paramValue || paramInfo[\"default\"] || \"\";\r\n\t\t// Store the parameter name and value\r\n\t\tresults.push({name: paramInfo.name, value: paramValue});\r\n\t}\r\n\treturn results;\r\n};\n\nWidget.prototype.substituteVariableReferences = function(text) {\r\n\tvar self = this;\r\n\treturn (text || \"\").replace(/\\$\\(([^\\)\\$]+)\\)\\$/g,function(match,p1,offset,string) {\r\n\t\treturn self.getVariable(p1,{defaultValue: \"\"});\r\n\t});\r\n};\n\nWidget.prototype.evaluateMacroModule = function(name,actualParams,defaultValue) {\r\n\tif($tw.utils.hop($tw.macros,name)) {\r\n\t\tvar macro = $tw.macros[name],\r\n\t\t\targs = [];\r\n\t\tif(macro.params.length > 0) {\r\n\t\t\tvar nextAnonParameter = 0, // Next candidate anonymous parameter in macro call\r\n\t\t\t\tparamInfo, paramValue;\r\n\t\t\t// Step through each of the parameters in the macro definition\r\n\t\t\tfor(var p=0; p<macro.params.length; p++) {\r\n\t\t\t\t// Check if we've got a macro call parameter with the same name\r\n\t\t\t\tparamInfo = macro.params[p];\r\n\t\t\t\tparamValue = undefined;\r\n\t\t\t\tfor(var m=0; m<actualParams.length; m++) {\r\n\t\t\t\t\tif(actualParams[m].name === paramInfo.name) {\r\n\t\t\t\t\t\tparamValue = actualParams[m].value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// If not, use the next available anonymous macro call parameter\r\n\t\t\t\twhile(nextAnonParameter < actualParams.length && actualParams[nextAnonParameter].name) {\r\n\t\t\t\t\tnextAnonParameter++;\r\n\t\t\t\t}\r\n\t\t\t\tif(paramValue === undefined && nextAnonParameter < actualParams.length) {\r\n\t\t\t\t\tparamValue = actualParams[nextAnonParameter++].value;\r\n\t\t\t\t}\r\n\t\t\t\t// If we've still not got a value, use the default, if any\r\n\t\t\t\tparamValue = paramValue || paramInfo[\"default\"] || \"\";\r\n\t\t\t\t// Save the parameter\r\n\t\t\t\targs.push(paramValue);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse for(var i=0; i<actualParams.length; ++i) {\r\n\t\t\targs.push(actualParams[i].value);\r\n\t\t}\r\n\t\treturn (macro.run.apply(this,args) || \"\").toString();\r\n\t} else {\r\n\t\treturn defaultValue;\r\n\t}\r\n};\n\n/*\r\nCheck whether a given context variable value exists in the parent chain\r\n*/\r\nWidget.prototype.hasVariable = function(name,value) {\r\n\tvar node = this;\r\n\twhile(node) {\r\n\t\tif($tw.utils.hop(node.variables,name) && node.variables[name].value === value) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tnode = node.parentWidget;\r\n\t}\r\n\treturn false;\r\n};\n\n/*\r\nConstruct a qualifying string based on a hash of concatenating the values of a given variable in the parent chain\r\n*/\r\nWidget.prototype.getStateQualifier = function(name) {\r\n\tthis.qualifiers = this.qualifiers || Object.create(null);\r\n\tname = name || \"transclusion\";\r\n\tif(this.qualifiers[name]) {\r\n\t\treturn this.qualifiers[name];\r\n\t} else {\r\n\t\tvar output = [],\r\n\t\t\tnode = this;\r\n\t\twhile(node && node.parentWidget) {\r\n\t\t\tif($tw.utils.hop(node.parentWidget.variables,name)) {\r\n\t\t\t\toutput.push(node.getVariable(name));\r\n\t\t\t}\r\n\t\t\tnode = node.parentWidget;\r\n\t\t}\r\n\t\tvar value = $tw.utils.hashString(output.join(\"\"));\r\n\t\tthis.qualifiers[name] = value;\r\n\t\treturn value;\r\n\t}\r\n};\n\n/*\r\nCompute the current values of the attributes of the widget. Returns a hashmap of the names of the attributes that have changed\r\n*/\r\nWidget.prototype.computeAttributes = function() {\r\n\tvar changedAttributes = {},\r\n\t\tself = this,\r\n\t\tvalue;\r\n\tif (!this.attributeGizmos) {\r\n\t\t// First-time attribute preparation\r\n\t\tthis.attributeGizmos = {};\r\n\t\t$tw.utils.each(this.parseTreeNode.attributes,function(attribute,name) {\r\n\t\t\t// Does the attribute type have a known module?\r\n\t\t\tvar AttributeClass = self.attributeClasses[attribute.type];\r\n\t\t\tif (AttributeClass) {\r\n\t\t\t\t// Instantiate an attribute object.\r\n\t\t\t\tself.attributeGizmos[name] = new AttributeClass(self,attribute);\r\n\t\t\t\tvalue = self.attributeGizmos[name].value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Unknown attribute types are treated as strings.\r\n\t\t\t\t// String attributes don't change after the first computeAttributes().\r\n\t\t\t\tvalue = attribute.value;\r\n\t\t\t}\r\n\t\t\t// Is the value changed?\r\n\t\t\tif (self.attributes[name] !== value) {\r\n\t\t\t\tself.attributes[name] = value;\r\n\t\t\t\tchangedAttributes[name] = true;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}else {\r\n\t\t// Fully recompute all dynamic attributes (no selectivity is available)\r\n\t\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\r\n\t\t\tvalue = gizmo.compute();\r\n\t\t\tif(self.attributes[name] !== value) {\r\n\t\t\t\tself.attributes[name] = value;\r\n\t\t\t\tchangedAttributes[name] = true;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\treturn changedAttributes;\r\n};\n\n/*\r\nSelectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed\r\n*/\r\nWidget.prototype.refreshAttributes = function(changedTiddlers) {\r\n\tif (!this.attributeGizmos) return computeAttributes();\r\n\tvar changedAttributes = {},\r\n\t\tself = this,\r\n\t\tvalue;\r\n\t// Fully recompute all dynamic attributes (no selectivity is available)\r\n\t$tw.utils.each(this.attributeGizmos,function(gizmo,name) {\r\n\t\tvalue = gizmo.refresh(changedTiddlers);\r\n\t\tif(self.attributes[name] !== value) {\r\n\t\t\tself.attributes[name] = value;\r\n\t\t\tchangedAttributes[name] = true;\r\n\t\t}\r\n\t});\r\n\treturn changedAttributes;\r\n};\n\n/*\r\nCheck for the presence of an attribute\r\n*/\r\nWidget.prototype.hasAttribute = function(name) {\r\n\treturn $tw.utils.hop(this.attributes,name);\r\n};\n\n/*\r\nGet the value of an attribute\r\n*/\r\nWidget.prototype.getAttribute = function(name,defaultText) {\r\n\tif($tw.utils.hop(this.attributes,name)) {\r\n\t\treturn this.attributes[name];\r\n\t} else {\r\n\t\treturn defaultText;\r\n\t}\r\n};\n\n/*\r\nAssign the computed attributes of the widget to a domNode\r\noptions include:\r\nexcludeEventAttributes: ignores attributes whose name begins with \"on\"\r\n*/\r\nWidget.prototype.assignAttributes = function(domNode,options) {\r\n\toptions = options || {};\r\n\tvar self = this;\r\n\t$tw.utils.each(this.attributes,function(v,a) {\r\n\t\t// Check exclusions\r\n\t\tif(options.excludeEventAttributes && a.substr(0,2) === \"on\") {\r\n\t\t\tv = undefined;\r\n\t\t}\r\n\t\tif(v !== undefined) {\r\n\t\t\tvar b = a.split(\":\");\r\n\t\t\t// Setting certain attributes can cause a DOM error (eg xmlns on the svg element)\r\n\t\t\ttry {\r\n\t\t\t\tif (b.length == 2 && b[0] == \"xlink\"){\r\n\t\t\t\t\tdomNode.setAttributeNS(\"http://www.w3.org/1999/xlink\",b[1],v);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdomNode.setAttributeNS(null,a,v);\r\n\t\t\t\t}\r\n\t\t\t} catch(e) {\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n};\n\n/*\r\nMake child widgets correspondng to specified parseTreeNodes\r\n*/\r\nWidget.prototype.makeChildWidgets = function(parseTreeNodes) {\r\n\tthis.children = [];\r\n\tvar self = this;\r\n\t$tw.utils.each(parseTreeNodes || (this.parseTreeNode && this.parseTreeNode.children),function(childNode) {\r\n\t\tself.children.push(self.makeChildWidget(childNode));\r\n\t});\r\n};\n\n/*\r\nConstruct the widget object for a parse tree node\r\n*/\r\nWidget.prototype.makeChildWidget = function(parseTreeNode) {\r\n\tvar WidgetClass = this.widgetClasses[parseTreeNode.type];\r\n\tif(!WidgetClass) {\r\n\t\tWidgetClass = this.widgetClasses.text;\r\n\t\tparseTreeNode = {type: \"text\", text: \"Undefined widget '\" + parseTreeNode.type + \"'\"};\r\n\t}\r\n\treturn new WidgetClass(parseTreeNode,{\r\n\t\twiki: this.wiki,\r\n\t\tvariables: {},\r\n\t\tparentWidget: this,\r\n\t\tdocument: this.document\r\n\t});\r\n};\n\n/*\r\nGet the next sibling of this widget\r\n*/\r\nWidget.prototype.nextSibling = function() {\r\n\tif(this.parentWidget) {\r\n\t\tvar index = this.parentWidget.children.indexOf(this);\r\n\t\tif(index !== -1 && index < this.parentWidget.children.length-1) {\r\n\t\t\treturn this.parentWidget.children[index+1];\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\n\n/*\r\nGet the previous sibling of this widget\r\n*/\r\nWidget.prototype.previousSibling = function() {\r\n\tif(this.parentWidget) {\r\n\t\tvar index = this.parentWidget.children.indexOf(this);\r\n\t\tif(index !== -1 && index > 0) {\r\n\t\t\treturn this.parentWidget.children[index-1];\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\n\n/*\r\nRender the children of this widget into the DOM\r\n*/\r\nWidget.prototype.renderChildren = function(parent,nextSibling) {\r\n\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\tchildWidget.render(parent,nextSibling);\r\n\t});\r\n};\n\n/*\r\nAdd a list of event listeners from an array [{type:,handler:},...]\r\n*/\r\nWidget.prototype.addEventListeners = function(listeners) {\r\n\tvar self = this;\r\n\t$tw.utils.each(listeners,function(listenerInfo) {\r\n\t\tself.addEventListener(listenerInfo.type,listenerInfo.handler);\r\n\t});\r\n};\n\n/*\r\nAdd an event listener\r\n*/\r\nWidget.prototype.addEventListener = function(type,handler) {\r\n\tvar self = this;\r\n\tif(typeof handler === \"string\") { // The handler is a method name on this widget\r\n\t\tthis.eventListeners[type] = function(event) {\r\n\t\t\treturn self[handler].call(self,event);\r\n\t\t};\r\n\t} else { // The handler is a function\r\n\t\tthis.eventListeners[type] = function(event) {\r\n\t\t\treturn handler.call(self,event);\r\n\t\t};\r\n\t}\r\n};\n\n/*\r\nDispatch an event to a widget. If the widget doesn't handle the event then it is also dispatched to the parent widget\r\n*/\r\nWidget.prototype.dispatchEvent = function(event) {\r\n\t// Dispatch the event if this widget handles it\r\n\tvar listener = this.eventListeners[event.type];\r\n\tif(listener) {\r\n\t\t// Don't propagate the event if the listener returned false\r\n\t\tif(!listener(event)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t// Dispatch the event to the parent widget\r\n\tif(this.parentWidget) {\r\n\t\treturn this.parentWidget.dispatchEvent(event);\r\n\t}\r\n\treturn true;\r\n};\n\n/*\r\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\r\n*/\r\nWidget.prototype.refresh = function(changedTiddlers) {\r\n\treturn this.refreshChildren(changedTiddlers);\r\n};\n\n/*\r\nRebuild a previously rendered widget\r\n*/\r\nWidget.prototype.refreshSelf = function() {\r\n\tvar nextSibling = this.findNextSiblingDomNode();\r\n\tthis.removeChildDomNodes();\r\n\tthis.render(this.parentDomNode,nextSibling);\r\n};\n\n/*\r\nRefresh all the children of a widget\r\n*/\r\nWidget.prototype.refreshChildren = function(changedTiddlers) {\r\n\tvar self = this,\r\n\t\trefreshed = false;\r\n\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\trefreshed = childWidget.refresh(changedTiddlers) || refreshed;\r\n\t});\r\n\treturn refreshed;\r\n};\n\n/*\r\nFind the next sibling in the DOM to this widget. This is done by scanning the widget tree through all next siblings and their descendents that share the same parent DOM node\r\n*/\r\nWidget.prototype.findNextSiblingDomNode = function(startIndex) {\r\n\t// Refer to this widget by its index within its parents children\r\n\tvar parent = this.parentWidget,\r\n\t\tindex = startIndex !== undefined ? startIndex : parent.children.indexOf(this);\r\nif(index === -1) {\r\n\tthrow \"node not found in parents children\";\r\n}\r\n\t// Look for a DOM node in the later siblings\r\n\twhile(++index < parent.children.length) {\r\n\t\tvar domNode = parent.children[index].findFirstDomNode();\r\n\t\tif(domNode) {\r\n\t\t\treturn domNode;\r\n\t\t}\r\n\t}\r\n\t// Go back and look for later siblings of our parent if it has the same parent dom node\r\n\tvar grandParent = parent.parentWidget;\r\n\tif(grandParent && parent.parentDomNode === this.parentDomNode) {\r\n\t\tindex = grandParent.children.indexOf(parent);\r\n\t\tif(index !== -1) {\r\n\t\t\treturn parent.findNextSiblingDomNode(index);\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\n\n/*\r\nFind the first DOM node generated by a widget or its children\r\n*/\r\nWidget.prototype.findFirstDomNode = function() {\r\n\t// Return the first dom node of this widget, if we've got one\r\n\tif(this.domNodes.length > 0) {\r\n\t\treturn this.domNodes[0];\r\n\t}\r\n\t// Otherwise, recursively call our children\r\n\tfor(var t=0; t<this.children.length; t++) {\r\n\t\tvar domNode = this.children[t].findFirstDomNode();\r\n\t\tif(domNode) {\r\n\t\t\treturn domNode;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\n\n/*\r\nRemove any DOM nodes created by this widget or its children\r\n*/\r\nWidget.prototype.removeChildDomNodes = function() {\r\n\t// If this widget has directly created DOM nodes, delete them and exit. This assumes that any child widgets are contained within the created DOM nodes, which would normally be the case\r\n\tif(this.domNodes.length > 0) {\r\n\t\t$tw.utils.each(this.domNodes,function(domNode) {\r\n\t\t\tdomNode.parentNode.removeChild(domNode);\r\n\t\t});\r\n\t\tthis.domNodes = [];\r\n\t} else {\r\n\t\t// Otherwise, ask the child widgets to delete their DOM nodes\r\n\t\t$tw.utils.each(this.children,function(childWidget) {\r\n\t\t\tchildWidget.removeChildDomNodes();\r\n\t\t});\r\n\t}\r\n};\n\n/*\r\nInvoke the action widgets that are descendents of the current widget.\r\n*/\r\nWidget.prototype.invokeActions = function(triggeringWidget,event) {\r\n\tvar handled = false;\r\n\t// For each child widget\r\n\tfor(var t=0; t<this.children.length; t++) {\r\n\t\tvar child = this.children[t];\r\n\t\t// Invoke the child if it is an action widget\r\n\t\tif(child.invokeAction) {\r\n\t\t\tchild.refreshSelf();\r\n\t\t\tif(child.invokeAction(triggeringWidget,event)) {\r\n\t\t\t\thandled = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Propagate through through the child if it permits it\r\n\t\tif(child.allowActionPropagation() && child.invokeActions(triggeringWidget,event)) {\r\n\t\t\thandled = true;\r\n\t\t}\r\n\t}\r\n\treturn handled;\r\n};\n\n/*\r\nInvoke the action widgets defined in a string\r\n*/\r\nWidget.prototype.invokeActionString = function(actions,triggeringWidget,event,variables) {\r\n\tactions = actions || \"\";\r\n\tvar parser = this.wiki.parseText(\"text/vnd.tiddlywiki\",actions,{\r\n\t\t\tparentWidget: this,\r\n\t\t\tdocument: this.document\r\n\t\t}),\r\n\t\twidgetNode = this.wiki.makeWidget(parser,{\r\n\t\t\tparentWidget: this,\r\n\t\t\tdocument: this.document,\r\n\t\t\tvariables: variables\r\n\t\t});\r\n\tvar container = this.document.createElement(\"div\");\r\n\twidgetNode.render(container,null);\r\n\treturn widgetNode.invokeActions(this,event);\r\n};\n\nWidget.prototype.allowActionPropagation = function() {\r\n\treturn true;\r\n};\n\nexports.widget = Widget;\n\n})();\r\n"
        },
        "$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patch/core/modules/utils/parseutils.js",
            "text": "@@ -1,20 +1,19 @@\n /*%5C\n-%0D\n %0Atitle: $:/core/\n@@ -31,33 +31,32 @@\n ls/parseutils.js\n-%0D\n %0Atype: applicati\n@@ -60,33 +60,32 @@\n ation/javascript\n-%0D\n %0Amodule-type: ut\n@@ -212,33 +212,32 @@\n  parameters are:\n-%0D\n %0A** %60source%60: th\n@@ -256,33 +256,32 @@\n ing being parsed\n-%0D\n %0A** %60pos%60: the c\n@@ -311,33 +311,32 @@\n ithin the string\n-%0D\n %0A** Any further \n@@ -389,33 +389,32 @@\n  is being parsed\n-%0D\n %0A* The return va\n@@ -412,33 +412,32 @@\n return value is:\n-%0D\n %0A** null if the \n@@ -473,33 +473,32 @@\n ecified position\n-%0D\n %0A** an object re\n@@ -545,33 +545,32 @@\n standard fields:\n-%0D\n %0A*** %60type%60: str\n@@ -597,33 +597,32 @@\n ype of the token\n-%0D\n %0A*** %60start%60: st\n@@ -659,33 +659,32 @@\n he source string\n-%0D\n %0A*** %60end%60: end \n@@ -717,33 +717,32 @@\n he source string\n-%0D\n %0A*** Any further\n@@ -870,33 +870,32 @@\n itespace.%0D%0A%0D%0A%5C*/\n-%0D\n %0A(function()%7B%0D%0A%0D\n@@ -924,33 +924,32 @@\n browser: true */\n-%0D\n %0A/*global $tw: f\n@@ -947,33 +947,32 @@\n al $tw: false */\n-%0D\n %0A%22use strict%22;%0D%0A\n@@ -967,33 +967,32 @@\n e strict%22;%0D%0A%0D%0A/*\n-%0D\n %0ALook for a whit\n@@ -1077,37 +1077,35 @@\n , start:, end:,%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseWh\n@@ -1137,50 +1137,47 @@\n e,pos) %7B\n-%0D\n %0A%09var p = pos,c;\n-%0D\n %0A%09while(true) %7B\n-%0D\n %0A%09%09c = s\n@@ -1184,33 +1184,32 @@\n ource.charAt(p);\n-%0D\n %0A%09%09if((c === %22 %22\n@@ -1351,58 +1351,52 @@\n e spaces\n-%0D\n %0A%09%09%09p++;\n-%0D\n %0A%09%09%7D else %7B\n-%0D\n %0A%09%09%09break;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09if(p =\n@@ -1404,56 +1404,52 @@\n = pos) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09return %7B\n-%0D\n %0A%09%09%09type\n@@ -1463,63 +1463,57 @@\n espace%22,\n-%0D\n %0A%09%09%09start: pos,\n-%0D\n %0A%09%09%09end: p\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AConveni\n@@ -1579,37 +1579,35 @@\n r the whitespace\n-%0D\n %0A*/\n-%0D\n %0Aexports.skipWhi\n@@ -1638,42 +1638,39 @@\n e,pos) %7B\n-%0D\n %0A%09var c;\n-%0D\n %0A%09while(true) %7B\n-%0D\n %0A%09%09c = s\n@@ -1679,33 +1679,32 @@\n rce.charAt(pos);\n-%0D\n %0A%09%09if((c === %22 %22\n@@ -1846,75 +1846,68 @@\n e spaces\n-%0D\n %0A%09%09%09pos++;\n-%0D\n %0A%09%09%7D else %7B\n-%0D\n %0A%09%09%09return pos;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -2005,37 +2005,35 @@\n , start:, end:,%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseTo\n@@ -2064,33 +2064,32 @@\n rce,pos,token) %7B\n-%0D\n %0A%09var match = so\n@@ -2120,43 +2120,40 @@\n === pos;\n-%0D\n %0A%09if(match) %7B\n-%0D\n %0A%09%09return %7B\n-%0D\n %0A%09%09%09type\n@@ -2154,33 +2154,32 @@\n %09%09type: %22token%22,\n-%0D\n %0A%09%09%09value: token\n@@ -2179,33 +2179,31 @@\n : token,\n-%0D\n %0A%09%09%09start: pos,\n-%0D\n %0A%09%09%09end:\n@@ -2221,52 +2221,47 @@\n n.length\n-%0D\n %0A%09%09%7D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return null;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -2364,37 +2364,35 @@\n , start:, end:,%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseTo\n@@ -2433,32 +2433,30 @@\n Token) %7B\n-%0D\n %0A%09var node = %7B\n-%0D\n %0A%09%09type:\n@@ -2465,36 +2465,33 @@\n regexp%22,\n-%0D\n %0A%09%09start: pos\n-%0D\n %0A%09%7D;\n-%0D\n %0A%09reToke\n@@ -2500,33 +2500,32 @@\n lastIndex = pos;\n-%0D\n %0A%09node.match = r\n@@ -2536,33 +2536,32 @@\n en.exec(source);\n-%0D\n %0A%09if(node.match \n@@ -2582,33 +2582,32 @@\n index === pos) %7B\n-%0D\n %0A%09%09node.end = po\n@@ -2631,74 +2631,68 @@\n .length;\n-%0D\n %0A%09%09return node;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -2787,37 +2787,35 @@\n , start:, end:,%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseSt\n@@ -2850,32 +2850,30 @@\n e,pos) %7B\n-%0D\n %0A%09var node = %7B\n-%0D\n %0A%09%09type:\n@@ -2882,36 +2882,33 @@\n string%22,\n-%0D\n %0A%09%09start: pos\n-%0D\n %0A%09%7D;\n-%0D\n %0A%09var re\n@@ -2956,33 +2956,32 @@\n (?:'(%5B%5E'%5D*)')/g;\n-%0D\n %0A%09reString.lastI\n@@ -2983,33 +2983,32 @@\n lastIndex = pos;\n-%0D\n %0A%09var match = re\n@@ -3019,33 +3019,32 @@\n ng.exec(source);\n-%0D\n %0A%09if(match && ma\n@@ -3055,33 +3055,32 @@\n index === pos) %7B\n-%0D\n %0A%09%09node.value = \n@@ -3107,33 +3107,32 @@\n ed ? match%5B1%5D :(\n-%0D\n %0A%09%09%09match%5B2%5D !==\n@@ -3164,26 +3164,24 @@\n atch%5B3%5D \n-%0D\n %0A%09%09%09%09%09);\n-%0D\n %0A%09%09node.\n@@ -3208,74 +3208,68 @@\n .length;\n-%0D\n %0A%09%09return node;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -3376,37 +3376,35 @@\n :, start:, end:%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseMa\n@@ -3440,32 +3440,30 @@\n e,pos) %7B\n-%0D\n %0A%09var node = %7B\n-%0D\n %0A%09%09type:\n@@ -3481,36 +3481,33 @@\n ameter%22,\n-%0D\n %0A%09%09start: pos\n-%0D\n %0A%09%7D;\n-%0D\n %0A%09// Def\n@@ -3512,33 +3512,32 @@\n efine our regexp\n-%0D\n %0A%09var reMacroPar\n@@ -3644,33 +3644,32 @@\n %5B%5E%5Cs%3E%22'=%5D+)))/g;\n-%0D\n %0A%09// Skip whites\n@@ -3664,33 +3664,32 @@\n  Skip whitespace\n-%0D\n %0A%09pos = $tw.util\n@@ -3709,33 +3709,32 @@\n ace(source,pos);\n-%0D\n %0A%09// Look for th\n@@ -3736,33 +3736,32 @@\n or the parameter\n-%0D\n %0A%09var token = $t\n@@ -3814,52 +3814,48 @@\n ameter);\n-%0D\n %0A%09if(!token) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09pos = \n@@ -3856,33 +3856,32 @@\n pos = token.end;\n-%0D\n %0A%09// Get the par\n@@ -3886,33 +3886,32 @@\n arameter details\n-%0D\n %0A%09node.value = t\n@@ -3950,33 +3950,32 @@\n ken.match%5B2%5D : (\n-%0D\n %0A%09%09%09%09%09token.matc\n@@ -4005,33 +4005,32 @@\n ken.match%5B3%5D : (\n-%0D\n %0A%09%09%09%09%09%09token.mat\n@@ -4061,33 +4061,32 @@\n ken.match%5B4%5D : (\n-%0D\n %0A%09%09%09%09%09%09%09token.ma\n@@ -4118,33 +4118,32 @@\n ken.match%5B5%5D : (\n-%0D\n %0A%09%09%09%09%09%09%09%09token.m\n@@ -4184,76 +4184,69 @@\n h%5B6%5D : (\n-%0D\n %0A%09%09%09%09%09%09%09%09%09%22%22\n-%0D\n %0A%09%09%09%09%09%09%09%09)\n-%0D\n %0A%09%09%09%09%09%09%09)\n-%0D\n %0A%09%09%09%09%09%09)\n-%0D\n %0A%09%09%09%09%09)\n-%0D\n %0A%09%09%09%09);\n-%0D\n %0A%09if(tok\n@@ -4251,33 +4251,32 @@\n oken.match%5B1%5D) %7B\n-%0D\n %0A%09%09node.name = t\n@@ -4281,37 +4281,35 @@\n  token.match%5B1%5D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Update the \n@@ -4312,33 +4312,32 @@\n the end position\n-%0D\n %0A%09node.end = pos\n@@ -4337,42 +4337,39 @@\n d = pos;\n-%0D\n %0A%09return node;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -4465,37 +4465,35 @@\n :, start:, end:%7D\n-%0D\n %0A*/\n-%0D\n %0Aexports.parseMa\n@@ -4530,32 +4530,30 @@\n e,pos) %7B\n-%0D\n %0A%09var node = %7B\n-%0D\n %0A%09%09type:\n@@ -4565,51 +4565,47 @@\n rocall%22,\n-%0D\n %0A%09%09start: pos,\n-%0D\n %0A%09%09params: %5B%5D\n-%0D\n %0A%09%7D;\n-%0D\n %0A%09// Def\n@@ -4611,33 +4611,32 @@\n fine our regexps\n-%0D\n %0A%09var reMacroNam\n@@ -4647,33 +4647,32 @@\n /(%5B%5E%5Cs%3E%22'=%5D+)/g;\n-%0D\n %0A%09// Skip whites\n@@ -4667,33 +4667,32 @@\n  Skip whitespace\n-%0D\n %0A%09pos = $tw.util\n@@ -4712,33 +4712,32 @@\n ace(source,pos);\n-%0D\n %0A%09// Look for a \n@@ -4749,33 +4749,32 @@\n e less than sign\n-%0D\n %0A%09var token = $t\n@@ -4815,52 +4815,48 @@\n s,%22%3C%3C%22);\n-%0D\n %0A%09if(!token) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09pos = \n@@ -4857,33 +4857,32 @@\n pos = token.end;\n-%0D\n %0A%09// Get the mac\n@@ -4880,33 +4880,32 @@\n t the macro name\n-%0D\n %0A%09var name = $tw\n@@ -4952,51 +4952,47 @@\n roName);\n-%0D\n %0A%09if(!name) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09node.n\n@@ -5003,33 +5003,32 @@\n = name.match%5B1%5D;\n-%0D\n %0A%09pos = name.end\n@@ -5020,33 +5020,32 @@\n %09pos = name.end;\n-%0D\n %0A%09// Process par\n@@ -5043,33 +5043,32 @@\n ocess parameters\n-%0D\n %0A%09var parameter \n@@ -5103,33 +5103,32 @@\n ter(source,pos);\n-%0D\n %0A%09while(paramete\n@@ -5123,33 +5123,32 @@\n ile(parameter) %7B\n-%0D\n %0A%09%09node.params.p\n@@ -5154,33 +5154,32 @@\n push(parameter);\n-%0D\n %0A%09%09pos = paramet\n@@ -5177,33 +5177,32 @@\n = parameter.end;\n-%0D\n %0A%09%09// Get the ne\n@@ -5205,33 +5205,32 @@\n e next parameter\n-%0D\n %0A%09%09parameter = $\n@@ -5262,37 +5262,35 @@\n ter(source,pos);\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Skip whites\n@@ -5285,33 +5285,32 @@\n  Skip whitespace\n-%0D\n %0A%09pos = $tw.util\n@@ -5330,33 +5330,32 @@\n ace(source,pos);\n-%0D\n %0A%09// Look for a \n@@ -5370,33 +5370,32 @@\n reater than sign\n-%0D\n %0A%09token = $tw.ut\n@@ -5432,52 +5432,48 @@\n s,%22%3E%3E%22);\n-%0D\n %0A%09if(!token) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09pos = \n@@ -5474,33 +5474,32 @@\n pos = token.end;\n-%0D\n %0A%09// Update the \n@@ -5502,33 +5502,32 @@\n the end position\n-%0D\n %0A%09node.end = pos\n@@ -5527,42 +5527,39 @@\n d = pos;\n-%0D\n %0A%09return node;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ALook fo\n@@ -5720,20 +5720,48 @@\n , end:,%7D\n-%0D\n %0A*/\n+%0Avar AttributeRules = null;%0D%0A\n %0D%0Aexport\n@@ -5801,51 +5801,47 @@\n e,pos) %7B\n-%0D\n %0A%09var node = %7B\n-%0D\n %0A%09%09start: pos\n-%0D\n %0A%09%7D;\n-%0D\n %0A%09// Def\n@@ -5847,33 +5847,32 @@\n fine our regexps\n-%0D\n %0A%09var reAttribut\n@@ -5889,33 +5889,32 @@\n %5B%5E%5C/%5Cs%3E%22'=%5D+)/g,\n-%0D\n %0A%09%09reUnquotedAtt\n@@ -5933,33 +5933,32 @@\n %5E%5C/%5Cs%3C%3E%22'=%5D+)/g,\n-%0D\n %0A%09%09reFilteredVal\n@@ -5975,33 +5975,32 @@\n %5C%7B(.+?)%5C%7D%5C%7D%5C%7D/g,\n-%0D\n %0A%09%09reIndirectVal\n@@ -6016,33 +6016,32 @@\n %7B(%5B%5E%5C%7D%5D+)%5C%7D%5C%7D/g;\n-%0D\n %0A%09// Skip whites\n@@ -6036,33 +6036,32 @@\n  Skip whitespace\n-%0D\n %0A%09pos = $tw.util\n@@ -6081,33 +6081,32 @@\n ace(source,pos);\n-%0D\n %0A%09// Get the att\n@@ -6108,33 +6108,32 @@\n e attribute name\n-%0D\n %0A%09var name = $tw\n@@ -6184,51 +6184,47 @@\n teName);\n-%0D\n %0A%09if(!name) %7B\n-%0D\n %0A%09%09return null;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09node.n\n@@ -6235,33 +6235,32 @@\n = name.match%5B1%5D;\n-%0D\n %0A%09pos = name.end\n@@ -6252,33 +6252,32 @@\n %09pos = name.end;\n-%0D\n %0A%09// Skip whites\n@@ -6272,33 +6272,32 @@\n  Skip whitespace\n-%0D\n %0A%09pos = $tw.util\n@@ -6317,33 +6317,32 @@\n ace(source,pos);\n-%0D\n %0A%09// Look for an\n@@ -6345,33 +6345,32 @@\n r an equals sign\n-%0D\n %0A%09var token = $t\n@@ -6410,31 +6410,29 @@\n os,%22=%22);\n-%0D\n %0A%09if(token) %7B\n-%0D\n %0A%09%09pos =\n@@ -6434,33 +6434,32 @@\n pos = token.end;\n-%0D\n %0A%09%09// Skip white\n@@ -6455,33 +6455,32 @@\n  Skip whitespace\n-%0D\n %0A%09%09pos = $tw.uti\n@@ -6501,33 +6501,32 @@\n ace(source,pos);\n-%0D\n %0A%09%09// Look for a\n@@ -6532,33 +6532,32 @@\n a string literal\n-%0D\n %0A%09%09var stringLit\n@@ -6596,33 +6596,32 @@\n ral(source,pos);\n-%0D\n %0A%09%09if(stringLite\n@@ -6626,46 +6626,24 @@\n teral) %7B\n-%0D\n %0A%09%09%09\n-pos = stringLiteral.end;%0D\n+%09%09%09%09\n %0A%09%09%09node\n@@ -6651,33 +6651,32 @@\n type = %22string%22;\n-%0D\n %0A%09%09%09node.value =\n@@ -6696,552 +6696,484 @@\n l.value;\n-%0D\n %0A%09%09\n-%7D else %7B%0D%0A%09%09%09// Look for a filtered value%0D%0A%09%09%09var filteredValue = $tw.utils.parseTokenRegExp(source,pos,reFilteredValue);%0D%0A%09%09%09if(filteredValue\n+%09node.end = stringLiteral.end;%0A%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%0A%09%09%09return node;%0A%09%09%7D%0A%09%09// Load attribute rules if needed%0A%09%09if (!AttributeRules\n ) %7B\n-%0D\n %0A%09%09%09\n-%09pos = filteredValue.end;%0D%0A%09%09%09%09node.type = %22filtered%22;%0D%0A%09%09%09%09node.filter = filteredValue.match%5B1%5D;%0D%0A%09%09%09%7D else %7B%0D%0A%09%09%09%09// Look for an indirect value%0D%0A%09%09%09%09var indirectValue = $tw.utils.parseTokenRegExp(source,pos,reIndirectValue);%0D%0A%09%09%09%09if(indirectValu\n+AttributeRules = %7B%7D;%0A%09%09%09$tw.modules.applyMethods(%22attributerule%22,AttributeRules);%0A%09%09%7D%0A%09%09// Look for an attribute rule%0A%09%09var match = null;%0A%09%09$tw.utils.each(AttributeRules,function(rul\n e) %7B\n-%0D\n %0A%09%09%09\n-%09%09pos = indirectValue.end;%0D%0A%09%09%09%09%09node.type = %22indirect%22;%0D%0A%09%09%09%09%09node.textReference = indirectValue.match%5B1%5D;%0D%0A%09%09%09%09%7D else %7B%0D\n+match = rule(source,pos,node);%0A%09%09%09return !match;%0A%09%09%7D);%0A%09%09if (match) return match;%0A%09%09%09%09%09%09%09%09%09%09%09%09%09\n %0A%09%09%09\n+%0A\n %09%09// Loo\n@@ -7186,37 +7186,33 @@\n a unquoted value\n-%0D%0A%09%09%09\n+%0A\n %09%09var unquotedVa\n@@ -7268,37 +7268,33 @@\n uotedAttribute);\n-%0D%0A%09%09%09\n+%0A\n %09%09if(unquotedVal\n@@ -7298,53 +7298,26 @@\n Value) %7B\n-%0D\n %0A%09%09%09%09%09%09\n-pos = unquotedValue.end;%0D%0A\n %09%09\n-%09\n+%0A\n %09%09%09node.\n@@ -7324,37 +7324,33 @@\n type = %22string%22;\n-%0D%0A%09%09%09\n+%0A\n %09%09%09node.value = \n@@ -7372,304 +7372,163 @@\n atch%5B1%5D;\n-%0D\n %0A%09%09%09\n-%09%09%7D else %7B%0D%0A%09%09%09%09%09%09// Look for a macro invocation value%0D%0A%09%09%09%09%09%09var macroInvocation = $tw.utils.parseMacroInvocation(source,pos);%0D%0A%09%09%09%09%09%09if(macroInvocation) %7B%0D%0A%09%09%09%09%09%09%09pos = macroInvocation.end;%0D%0A%09%09%09%09%09%09%09node.type = %22macro%22;%0D%0A%09%09%09%09%09%09%09node.value = macroInvocation;%0D\n+node.end = unquotedValue.end;%0A%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%0A%09%09%09%09%09%09%09%09%09%0A%09%09%09return node;\n %0A%09%09%09%09\n+%09%09%09%09%09%0A\n %09%09%7D else %7B\n-%0D%0A%09%09\n+%0A\n %09%09%09\n-%09%09\n node.typ\n@@ -7540,25 +7540,20 @@\n string%22;\n-%0D%0A%09%09\n+%0A\n %09%09%09\n-%09%09\n node.val\n@@ -7564,63 +7564,40 @@\n  %22true%22;\n-%0D\n %0A%09%09\n-%09%09%09%09%7D%0D%0A%09%09%09%09%09%7D%0D%0A%09%09%09%09%7D%0D%0A%09%09%09%7D%0D%0A%09%09%7D%0D\n+%7D%0A%09%09%0A%09%09%0A%09%0A%09\n %0A%09%7D else %7B\n-%0D\n %0A%09%09node.\n@@ -7604,33 +7604,32 @@\n type = %22string%22;\n-%0D\n %0A%09%09node.value = \n@@ -7635,21 +7635,19 @@\n  %22true%22;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Upd\n@@ -7658,33 +7658,32 @@\n the end position\n-%0D\n %0A%09node.end = pos\n@@ -7683,38 +7683,36 @@\n d = pos;\n-%0D\n %0A%09return node;\n-%0D\n %0A%7D;%0D%0A%0D%0A%7D)();\n-%0D\n %0A\n+%09\n",
            "created": "20191227073702611",
            "modified": "20191227073702611",
            "modloader-source": "$:/core",
            "modloader-target": "$:/core/modules/utils/parseutils.js",
            "type": "text/x-patch"
        },
        "$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js": {
            "title": "$:/plugins/ebalster/attribute-modules/patch/core/modules/widgets/widget.js",
            "text": "@@ -1,20 +1,19 @@\n /*%5C\n-%0D\n %0Atitle: $:/core/\n@@ -29,33 +29,32 @@\n idgets/widget.js\n-%0D\n %0Atype: applicati\n@@ -58,33 +58,32 @@\n ation/javascript\n-%0D\n %0Amodule-type: wi\n@@ -106,33 +106,32 @@\n ase class%0D%0A%0D%0A%5C*/\n-%0D\n %0A(function()%7B%0D%0A%0D\n@@ -160,33 +160,32 @@\n browser: true */\n-%0D\n %0A/*global $tw: f\n@@ -183,33 +183,32 @@\n al $tw: false */\n-%0D\n %0A%22use strict%22;%0D%0A\n@@ -203,33 +203,32 @@\n e strict%22;%0D%0A%0D%0A/*\n-%0D\n %0ACreate a widget\n@@ -248,33 +248,32 @@\n  parse tree node\n-%0D\n %0A%09parseTreeNode:\n@@ -312,33 +312,32 @@\n e to be rendered\n-%0D\n %0A%09options: see b\n@@ -332,33 +332,32 @@\n tions: see below\n-%0D\n %0AOptions include\n@@ -349,33 +349,32 @@\n Options include:\n-%0D\n %0A%09wiki: mandator\n@@ -417,33 +417,32 @@\n this render tree\n-%0D\n %0A%09parentWidget: \n@@ -499,33 +499,32 @@\n he context chain\n-%0D\n %0A%09document: opti\n@@ -569,37 +569,35 @@\n  global document\n-%0D\n %0A*/\n-%0D\n %0Avar Widget = fu\n@@ -619,34 +619,34 @@\n eNode,options) %7B\n-%0D\n %0A\n+%09\n %09this.initialise\n@@ -661,43 +661,41 @@\n eeNode,options);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AInitialise widg\n@@ -786,37 +786,35 @@\n em in subclasses\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -853,33 +853,32 @@\n eNode,options) %7B\n-%0D\n %0A%09// Bail if par\n@@ -992,33 +992,32 @@\n an be subclassed\n-%0D\n %0A%09if(parseTreeNo\n@@ -1035,32 +1035,29 @@\n fined) %7B\n-%0D\n %0A%09%09return;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09option\n@@ -1066,33 +1066,32 @@\n = options %7C%7C %7B%7D;\n-%0D\n %0A%09// Save widget\n@@ -1087,33 +1087,32 @@\n Save widget info\n-%0D\n %0A%09this.parseTree\n@@ -1124,33 +1124,32 @@\n = parseTreeNode;\n-%0D\n %0A%09this.wiki = op\n@@ -1151,33 +1151,32 @@\n  = options.wiki;\n-%0D\n %0A%09this.parentWid\n@@ -1194,33 +1194,32 @@\n ns.parentWidget;\n-%0D\n %0A%09this.variables\n@@ -1238,33 +1238,32 @@\n = function() %7B%7D;\n-%0D\n %0A%09this.variables\n@@ -1331,33 +1331,32 @@\n .variables : %7B%7D;\n-%0D\n %0A%09this.variables\n@@ -1382,33 +1382,32 @@\n esConstructor();\n-%0D\n %0A%09this.document \n@@ -1417,33 +1417,32 @@\n ptions.document;\n-%0D\n %0A%09this.attribute\n@@ -1440,33 +1440,32 @@\n attributes = %7B%7D;\n-%0D\n %0A%09this.children \n@@ -1461,33 +1461,32 @@\n s.children = %5B%5D;\n-%0D\n %0A%09this.domNodes \n@@ -1482,33 +1482,32 @@\n s.domNodes = %5B%5D;\n-%0D\n %0A%09this.eventList\n@@ -1509,33 +1509,32 @@\n tListeners = %7B%7D;\n-%0D\n %0A%09// Hashmap of \n@@ -1543,33 +1543,32 @@\n e widget classes\n-%0D\n %0A%09if(!this.widge\n@@ -1570,33 +1570,32 @@\n widgetClasses) %7B\n-%0D\n %0A%09%09// Get widget\n@@ -1594,33 +1594,32 @@\n t widget classes\n-%0D\n %0A%09%09Widget.protot\n@@ -1665,33 +1665,32 @@\n thods(%22widget%22);\n-%0D\n %0A%09%09// Process an\n@@ -1693,33 +1693,32 @@\n s any subclasses\n-%0D\n %0A%09%09$tw.modules.f\n@@ -1770,33 +1770,32 @@\n (title,module) %7B\n-%0D\n %0A%09%09%09if(module.ba\n@@ -1796,33 +1796,32 @@\n ule.baseClass) %7B\n-%0D\n %0A%09%09%09%09var baseCla\n@@ -1866,33 +1866,32 @@\n dule.baseClass%5D;\n-%0D\n %0A%09%09%09%09if(!baseCla\n@@ -1887,33 +1887,32 @@\n if(!baseClass) %7B\n-%0D\n %0A%09%09%09%09%09throw %22Mod\n@@ -2000,40 +2000,38 @@\n baseClass + %22'%22;\n-%0D\n %0A%09%09%09%09%7D\n-%0D\n %0A%09%09%09%09var subClas\n@@ -2045,33 +2045,32 @@\n ule.constructor;\n-%0D\n %0A%09%09%09%09subClass.pr\n@@ -2087,33 +2087,32 @@\n new baseClass();\n-%0D\n %0A%09%09%09%09$tw.utils.e\n@@ -2146,33 +2146,32 @@\n dule.prototype);\n-%0D\n %0A%09%09%09%09Widget.prot\n@@ -2234,44 +2234,191 @@\n ubClass;\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%7D);\n-%0D\n+%0A%09%7D%0A%09// Hashmap of the attribute classes%0A%09if(!this.attributeClasses) %7B%0A%09%09Widget.prototype.attributeClasses = $tw.modules.applyMethods(%22attributevalue%22);\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ARender \n@@ -2433,37 +2433,35 @@\n get into the DOM\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -2493,33 +2493,32 @@\n t,nextSibling) %7B\n-%0D\n %0A%09this.parentDom\n@@ -2523,33 +2523,32 @@\n omNode = parent;\n-%0D\n %0A%09this.execute()\n@@ -2540,33 +2540,32 @@\n %09this.execute();\n-%0D\n %0A%09this.renderChi\n@@ -2582,43 +2582,41 @@\n nt,nextSibling);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ACompute the int\n@@ -2632,37 +2632,35 @@\n te of the widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -2675,33 +2675,32 @@\n e = function() %7B\n-%0D\n %0A%09this.makeChild\n@@ -2701,43 +2701,41 @@\n eChildWidgets();\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ASet the value o\n@@ -2746,33 +2746,32 @@\n context variable\n-%0D\n %0Aname: name of t\n@@ -2773,33 +2773,32 @@\n  of the variable\n-%0D\n %0Avalue: value of\n@@ -2802,33 +2802,32 @@\n  of the variable\n-%0D\n %0Aparams: array o\n@@ -2856,33 +2856,32 @@\n r each parameter\n-%0D\n %0AisMacroDefiniti\n@@ -2986,37 +2986,35 @@\n ution performed)\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -3068,33 +3068,32 @@\n croDefinition) %7B\n-%0D\n %0A%09this.variables\n@@ -3164,43 +3164,41 @@\n acroDefinition%7D;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AGet the prevail\n@@ -3220,33 +3220,32 @@\n context variable\n-%0D\n %0Aname: name of v\n@@ -3243,33 +3243,32 @@\n name of variable\n-%0D\n %0Aoptions: see be\n@@ -3270,34 +3270,32 @@\n ee below\n-%0D\n %0AOptions include\n-%0D\n %0Aparams:\n@@ -3330,33 +3330,32 @@\n r each parameter\n-%0D\n %0AdefaultValue: d\n@@ -3515,33 +3515,32 @@\n kitext variables\n-%0D\n %0Atext: text of v\n@@ -3576,37 +3576,35 @@\n erly substituted\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -3639,33 +3639,32 @@\n (name,options) %7B\n-%0D\n %0A%09options = opti\n@@ -3665,33 +3665,32 @@\n = options %7C%7C %7B%7D;\n-%0D\n %0A%09var actualPara\n@@ -3707,33 +3707,32 @@\n ns.params %7C%7C %5B%5D,\n-%0D\n %0A%09%09parentWidget \n@@ -3743,33 +3743,32 @@\n is.parentWidget;\n-%0D\n %0A%09// Check for t\n@@ -3839,33 +3839,32 @@\n prototype chain)\n-%0D\n %0A%09if(parentWidge\n@@ -3893,33 +3893,32 @@\n get.variables) %7B\n-%0D\n %0A%09%09var variable \n@@ -3940,33 +3940,32 @@\n variables%5Bname%5D,\n-%0D\n %0A%09%09%09value = vari\n@@ -3967,33 +3967,32 @@\n  variable.value,\n-%0D\n %0A%09%09%09params = thi\n@@ -4041,33 +4041,32 @@\n s,actualParams);\n-%0D\n %0A%09%09// Substitute\n@@ -4100,33 +4100,32 @@\n n the definition\n-%0D\n %0A%09%09$tw.utils.eac\n@@ -4142,33 +4142,32 @@\n unction(param) %7B\n-%0D\n %0A%09%09%09value = $tw.\n@@ -4265,40 +4265,38 @@\n %22),param.value);\n-%0D\n %0A%09%09%7D);\n-%0D\n %0A%09%09// Only subst\n@@ -4365,33 +4365,32 @@\n e %5Cdefine pragma\n-%0D\n %0A%09%09if(variable.i\n@@ -4400,33 +4400,32 @@\n croDefinition) %7B\n-%0D\n %0A%09%09%09value = this\n@@ -4464,51 +4464,47 @@\n lue);%09%09%09\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09return %7B\n-%0D\n %0A%09%09%09text: value,\n-%0D\n %0A%09%09%09para\n@@ -4505,43 +4505,40 @@\n %09%09params: params\n-%0D\n %0A%09%09%7D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// If the vari\n@@ -4605,28 +4605,26 @@\n o module\n-%0D\n %0A%09return %7B\n-%0D\n %0A%09%09text:\n@@ -4688,32 +4688,29 @@\n ltValue)\n-%0D\n %0A%09%7D;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ASimplif\n@@ -4760,37 +4760,35 @@\n returns the text\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -4819,33 +4819,32 @@\n (name,options) %7B\n-%0D\n %0A%09return this.ge\n@@ -4868,33 +4868,32 @@\n e,options).text;\n-%0D\n %0A%7D;%0D%0A%0D%0AWidget.pr\n@@ -4957,33 +4957,32 @@\n ,actualParams) %7B\n-%0D\n %0A%09formalParams =\n@@ -4993,33 +4993,32 @@\n malParams %7C%7C %5B%5D;\n-%0D\n %0A%09actualParams =\n@@ -5029,33 +5029,32 @@\n ualParams %7C%7C %5B%5D;\n-%0D\n %0A%09var nextAnonPa\n@@ -5109,33 +5109,32 @@\n er in macro call\n-%0D\n %0A%09%09paramInfo, pa\n@@ -5142,34 +5142,32 @@\n amValue,\n-%0D\n %0A%09%09results = %5B%5D;\n-%0D\n %0A%09// Ste\n@@ -5214,33 +5214,32 @@\n macro definition\n-%0D\n %0A%09for(var p=0; p\n@@ -5258,33 +5258,32 @@\n s.length; p++) %7B\n-%0D\n %0A%09%09// Check if w\n@@ -5324,33 +5324,32 @@\n th the same name\n-%0D\n %0A%09%09paramInfo = f\n@@ -5355,33 +5355,32 @@\n formalParams%5Bp%5D;\n-%0D\n %0A%09%09paramValue = \n@@ -5381,33 +5381,32 @@\n lue = undefined;\n-%0D\n %0A%09%09for(var m=0; \n@@ -5426,33 +5426,32 @@\n s.length; m++) %7B\n-%0D\n %0A%09%09%09if(actualPar\n@@ -5475,33 +5475,32 @@\n aramInfo.name) %7B\n-%0D\n %0A%09%09%09%09paramValue \n@@ -5515,44 +5515,41 @@\n Params%5Bm%5D.value;\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09// If not, us\n@@ -5591,33 +5591,32 @@\n o call parameter\n-%0D\n %0A%09%09while(nextAno\n@@ -5682,33 +5682,32 @@\n rameter%5D.name) %7B\n-%0D\n %0A%09%09%09nextAnonPara\n@@ -5706,38 +5706,36 @@\n AnonParameter++;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09if(paramValue\n@@ -5786,33 +5786,32 @@\n Params.length) %7B\n-%0D\n %0A%09%09%09paramValue =\n@@ -5843,38 +5843,36 @@\n ameter++%5D.value;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09// If we've s\n@@ -5908,33 +5908,32 @@\n  default, if any\n-%0D\n %0A%09%09paramValue = \n@@ -5965,33 +5965,32 @@\n default%22%5D %7C%7C %22%22;\n-%0D\n %0A%09%09// Store the \n@@ -6005,33 +6005,32 @@\n r name and value\n-%0D\n %0A%09%09results.push(\n@@ -6064,37 +6064,35 @@\n e: paramValue%7D);\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return results\n@@ -6084,33 +6084,32 @@\n %09return results;\n-%0D\n %0A%7D;%0D%0A%0D%0AWidget.pr\n@@ -6155,33 +6155,32 @@\n function(text) %7B\n-%0D\n %0A%09var self = thi\n@@ -6173,33 +6173,32 @@\n var self = this;\n-%0D\n %0A%09return (text %7C\n@@ -6259,33 +6259,32 @@\n offset,string) %7B\n-%0D\n %0A%09%09return self.g\n@@ -6309,39 +6309,37 @@\n aultValue: %22%22%7D);\n-%0D\n %0A%09%7D);\n-%0D\n %0A%7D;%0D%0A%0D%0AWidget.pr\n@@ -6402,33 +6402,32 @@\n ,defaultValue) %7B\n-%0D\n %0A%09if($tw.utils.h\n@@ -6440,33 +6440,32 @@\n .macros,name)) %7B\n-%0D\n %0A%09%09var macro = $\n@@ -6480,32 +6480,30 @@\n s%5Bname%5D,\n-%0D\n %0A%09%09%09args = %5B%5D;\n-%0D\n %0A%09%09if(ma\n@@ -6518,33 +6518,32 @@\n ms.length %3E 0) %7B\n-%0D\n %0A%09%09%09var nextAnon\n@@ -6600,33 +6600,32 @@\n er in macro call\n-%0D\n %0A%09%09%09%09paramInfo, \n@@ -6627,33 +6627,32 @@\n nfo, paramValue;\n-%0D\n %0A%09%09%09// Step thro\n@@ -6693,33 +6693,32 @@\n macro definition\n-%0D\n %0A%09%09%09for(var p=0;\n@@ -6739,33 +6739,32 @@\n s.length; p++) %7B\n-%0D\n %0A%09%09%09%09// Check if\n@@ -6807,33 +6807,32 @@\n th the same name\n-%0D\n %0A%09%09%09%09paramInfo =\n@@ -6840,33 +6840,32 @@\n macro.params%5Bp%5D;\n-%0D\n %0A%09%09%09%09paramValue \n@@ -6868,33 +6868,32 @@\n lue = undefined;\n-%0D\n %0A%09%09%09%09for(var m=0\n@@ -6915,33 +6915,32 @@\n s.length; m++) %7B\n-%0D\n %0A%09%09%09%09%09if(actualP\n@@ -6966,33 +6966,32 @@\n aramInfo.name) %7B\n-%0D\n %0A%09%09%09%09%09%09paramValu\n@@ -7016,32 +7016,29 @@\n %5D.value;\n-%0D\n %0A%09%09%09%09%09%7D\n-%0D\n %0A%09%09%09%09%7D\n-%0D\n %0A%09%09%09%09// \n@@ -7090,33 +7090,32 @@\n o call parameter\n-%0D\n %0A%09%09%09%09while(nextA\n@@ -7183,33 +7183,32 @@\n rameter%5D.name) %7B\n-%0D\n %0A%09%09%09%09%09nextAnonPa\n@@ -7209,40 +7209,38 @@\n AnonParameter++;\n-%0D\n %0A%09%09%09%09%7D\n-%0D\n %0A%09%09%09%09if(paramVal\n@@ -7293,33 +7293,32 @@\n Params.length) %7B\n-%0D\n %0A%09%09%09%09%09paramValue\n@@ -7352,40 +7352,38 @@\n ameter++%5D.value;\n-%0D\n %0A%09%09%09%09%7D\n-%0D\n %0A%09%09%09%09// If we've\n@@ -7421,33 +7421,32 @@\n  default, if any\n-%0D\n %0A%09%09%09%09paramValue \n@@ -7480,33 +7480,32 @@\n default%22%5D %7C%7C %22%22;\n-%0D\n %0A%09%09%09%09// Save the\n@@ -7506,33 +7506,32 @@\n ve the parameter\n-%0D\n %0A%09%09%09%09args.push(p\n@@ -7533,44 +7533,41 @@\n ush(paramValue);\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09else for(var \n@@ -7592,33 +7592,32 @@\n s.length; ++i) %7B\n-%0D\n %0A%09%09%09args.push(ac\n@@ -7629,38 +7629,36 @@\n arams%5Bi%5D.value);\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09return (macro\n@@ -7689,44 +7689,42 @@\n  %22%22).toString();\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09return defaul\n@@ -7722,47 +7722,44 @@\n rn defaultValue;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ACheck whether a\n@@ -7806,37 +7806,35 @@\n the parent chain\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -7863,33 +7863,32 @@\n on(name,value) %7B\n-%0D\n %0A%09var node = thi\n@@ -7889,33 +7889,31 @@\n  = this;\n-%0D\n %0A%09while(node) %7B\n-%0D\n %0A%09%09if($t\n@@ -7987,39 +7987,36 @@\n value) %7B\n-%0D\n %0A%09%09%09return true;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09node \n@@ -8035,47 +8035,43 @@\n tWidget;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return false;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AConstru\n@@ -8168,37 +8168,35 @@\n the parent chain\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -8225,33 +8225,32 @@\n function(name) %7B\n-%0D\n %0A%09this.qualifier\n@@ -8284,33 +8284,32 @@\n ct.create(null);\n-%0D\n %0A%09name = name %7C%7C\n@@ -8316,33 +8316,32 @@\n  %22transclusion%22;\n-%0D\n %0A%09if(this.qualif\n@@ -8345,33 +8345,32 @@\n lifiers%5Bname%5D) %7B\n-%0D\n %0A%09%09return this.q\n@@ -8377,44 +8377,42 @@\n ualifiers%5Bname%5D;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09var output = \n@@ -8414,34 +8414,32 @@\n ut = %5B%5D,\n-%0D\n %0A%09%09%09node = this;\n-%0D\n %0A%09%09while\n@@ -8459,33 +8459,32 @@\n .parentWidget) %7B\n-%0D\n %0A%09%09%09if($tw.utils\n@@ -8516,33 +8516,32 @@\n riables,name)) %7B\n-%0D\n %0A%09%09%09%09output.push\n@@ -8557,39 +8557,37 @@\n Variable(name));\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%09node = node.\n@@ -8591,38 +8591,36 @@\n de.parentWidget;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09var value = $\n@@ -8648,33 +8648,32 @@\n utput.join(%22%22));\n-%0D\n %0A%09%09this.qualifie\n@@ -8689,48 +8689,44 @@\n = value;\n-%0D\n %0A%09%09return value;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ACompute\n@@ -8836,37 +8836,35 @@\n hat have changed\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -8889,33 +8889,32 @@\n s = function() %7B\n-%0D\n %0A%09var changedAtt\n@@ -8926,44 +8926,139 @@\n es = %7B%7D,\n-%0D\n %0A%09%09self = this,\n-%0D\n %0A%09%09value;\n-%0D\n %0A\n+%09if (!this.attributeGizmos) %7B%0A%09%09// First-time attribute preparation%0A%09%09this.attributeGizmos = %7B%7D;%0A%09\n %09$tw.uti\n@@ -9121,515 +9121,1465 @@\n ,name) %7B\n-%0D\n %0A%09%09\n-if(\n+%09// Does the \n attribute\n-.\n+ \n type \n-=== %22filtered%22) %7B%0D%0A%09%09%09value = self.wiki.filterTiddlers(attribute.filter,self)%5B0%5D %7C%7C %22%22;%0D%0A%09%09%7D else if(attribute.type === %22indirect%22) %7B%0D%0A%09%09%09value = self.wiki.getTextReference(attribute.textReference,%22%22,self.getVariable(%22currentTiddler%22)\n+have a known module?%0A%09%09%09var AttributeClass = self.attributeClasses%5Battribute.type%5D;%0A%09%09%09if (AttributeClass) %7B%0A%09%09%09%09// Instantiate an attribute object.%0A%09%09%09%09self.attributeGizmos%5Bname%5D = new AttributeClass(self,attribute);%0A%09%09%09%09value = self.attributeGizmos%5Bname%5D.value;%0A%09%09%09%7D%0A%09%09%09else %7B%0A%09%09%09%09// Unknown attribute types are treated as strings.%0A%09%09%09%09// String attributes don't change after the first computeAttributes().%0A%09%09%09%09value = attribute.value;%0A%09%09%09%7D%0A%09%09%09// Is the value changed?%0A%09%09%09if (self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%7D%0A%09%09%09return true;%0A%09%09%7D\n );\n-%0D\n %0A%09\n-%09%7D \n+%7D\n else \n-if(attribute.type === %22macro%22\n+%7B%0A%09%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09%09$tw.utils.each(this.attributeGizmos,function(gizmo,name\n ) %7B\n-%0D\n %0A%09%09%09value = \n-self.getVariable(attribute.value.name,%7Bparams: attribute.value.params%7D);%0D%0A%09%09%7D else %7B // String attribute%0D%0A%09%09%09value = attribute.value;%0D%0A%09%09%7D%0D%0A%09%09// Check whether the attribute has changed%0D\n+gizmo.compute();%0A%09%09%09if(self.attributes%5Bname%5D !== value) %7B%0A%09%09%09%09self.attributes%5Bname%5D = value;%0A%09%09%09%09changedAttributes%5Bname%5D = true;%0A%09%09%09%7D%0A%09%09%7D);%0A%09%7D%0A%09return changedAttributes;%0A%7D;%0D%0A%0D%0A/*%0ASelectively re-compute previously computed attributes. Returns a hashmap of the names of the attributes that have changed%0A*/%0AWidget.prototype.refreshAttributes = function(changedTiddlers) %7B%0A%09if (!this.attributeGizmos) return computeAttributes();%0A%09var changedAttributes = %7B%7D,%0A%09%09self = this,%0A%09%09value;%0A%09// Fully recompute all dynamic attributes (no selectivity is available)%0A%09$tw.utils.each(this.attributeGizmos,function(gizmo,name) %7B%0A%09%09value = gizmo.refresh(changedTiddlers);\n %0A%09%09if(se\n@@ -10602,33 +10602,32 @@\n me%5D !== value) %7B\n-%0D\n %0A%09%09%09self.attribu\n@@ -10636,33 +10636,32 @@\n s%5Bname%5D = value;\n-%0D\n %0A%09%09%09changedAttri\n@@ -10671,44 +10671,41 @@\n es%5Bname%5D = true;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D);\n-%0D\n %0A%09return changed\n@@ -10707,43 +10707,41 @@\n angedAttributes;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ACheck for the p\n@@ -10755,37 +10755,35 @@\n  of an attribute\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -10807,33 +10807,32 @@\n function(name) %7B\n-%0D\n %0A%09return $tw.uti\n@@ -10852,43 +10852,41 @@\n ttributes,name);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AGet the value o\n@@ -10891,37 +10891,35 @@\n  of an attribute\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -10955,33 +10955,32 @@\n e,defaultText) %7B\n-%0D\n %0A%09if($tw.utils.h\n@@ -10998,33 +10998,32 @@\n ributes,name)) %7B\n-%0D\n %0A%09%09return this.a\n@@ -11030,44 +11030,42 @@\n ttributes%5Bname%5D;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09return defaul\n@@ -11062,47 +11062,44 @@\n urn defaultText;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AAssign the comp\n@@ -11132,33 +11132,32 @@\n get to a domNode\n-%0D\n %0Aoptions include\n@@ -11149,33 +11149,32 @@\n options include:\n-%0D\n %0AexcludeEventAtt\n@@ -11220,37 +11220,35 @@\n begins with %22on%22\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -11287,33 +11287,32 @@\n mNode,options) %7B\n-%0D\n %0A%09options = opti\n@@ -11313,33 +11313,32 @@\n = options %7C%7C %7B%7D;\n-%0D\n %0A%09var self = thi\n@@ -11331,33 +11331,32 @@\n var self = this;\n-%0D\n %0A%09$tw.utils.each\n@@ -11379,33 +11379,32 @@\n ,function(v,a) %7B\n-%0D\n %0A%09%09// Check excl\n@@ -11401,33 +11401,32 @@\n Check exclusions\n-%0D\n %0A%09%09if(options.ex\n@@ -11466,33 +11466,32 @@\n 0,2) === %22on%22) %7B\n-%0D\n %0A%09%09%09v = undefine\n@@ -11484,38 +11484,36 @@\n %09%09v = undefined;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09if(v !== unde\n@@ -11512,33 +11512,32 @@\n !== undefined) %7B\n-%0D\n %0A%09%09%09var b = a.sp\n@@ -11537,33 +11537,32 @@\n  = a.split(%22:%22);\n-%0D\n %0A%09%09%09// Setting c\n@@ -11630,27 +11630,25 @@\n element)\n-%0D\n %0A%09%09%09try %7B\n-%0D\n %0A%09%09%09%09if \n@@ -11674,33 +11674,32 @@\n %5B0%5D == %22xlink%22)%7B\n-%0D\n %0A%09%09%09%09%09domNode.se\n@@ -11750,31 +11750,29 @@\n b%5B1%5D,v);\n-%0D\n %0A%09%09%09%09%7D else %7B\n-%0D\n %0A%09%09%09%09%09do\n@@ -11802,68 +11802,61 @@\n ll,a,v);\n-%0D\n %0A%09%09%09%09%7D\n-%0D\n %0A%09%09%09%7D catch(e) %7B\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AMake ch\n@@ -11899,37 +11899,35 @@\n d parseTreeNodes\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -11965,33 +11965,32 @@\n arseTreeNodes) %7B\n-%0D\n %0A%09this.children \n@@ -11986,33 +11986,32 @@\n s.children = %5B%5D;\n-%0D\n %0A%09var self = thi\n@@ -12004,33 +12004,32 @@\n var self = this;\n-%0D\n %0A%09$tw.utils.each\n@@ -12112,33 +12112,32 @@\n ion(childNode) %7B\n-%0D\n %0A%09%09self.children\n@@ -12175,33 +12175,30 @@\n dNode));\n-%0D\n %0A%09%7D);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AConstru\n@@ -12231,37 +12231,35 @@\n  parse tree node\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -12295,33 +12295,32 @@\n parseTreeNode) %7B\n-%0D\n %0A%09var WidgetClas\n@@ -12354,33 +12354,32 @@\n eTreeNode.type%5D;\n-%0D\n %0A%09if(!WidgetClas\n@@ -12374,33 +12374,32 @@\n (!WidgetClass) %7B\n-%0D\n %0A%09%09WidgetClass =\n@@ -12415,33 +12415,32 @@\n getClasses.text;\n-%0D\n %0A%09%09parseTreeNode\n@@ -12504,37 +12504,35 @@\n ode.type + %22'%22%7D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return new Wid\n@@ -12547,33 +12547,32 @@\n (parseTreeNode,%7B\n-%0D\n %0A%09%09wiki: this.wi\n@@ -12566,33 +12566,32 @@\n wiki: this.wiki,\n-%0D\n %0A%09%09variables: %7B%7D\n@@ -12583,33 +12583,32 @@\n %09%09variables: %7B%7D,\n-%0D\n %0A%09%09parentWidget:\n@@ -12605,33 +12605,32 @@\n entWidget: this,\n-%0D\n %0A%09%09document: thi\n@@ -12639,33 +12639,30 @@\n document\n-%0D\n %0A%09%7D);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AGet the\n@@ -12681,37 +12681,35 @@\n g of this widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -12728,33 +12728,32 @@\n g = function() %7B\n-%0D\n %0A%09if(this.parent\n@@ -12753,33 +12753,32 @@\n .parentWidget) %7B\n-%0D\n %0A%09%09var index = t\n@@ -12809,33 +12809,32 @@\n n.indexOf(this);\n-%0D\n %0A%09%09if(index !== \n@@ -12877,33 +12877,32 @@\n dren.length-1) %7B\n-%0D\n %0A%09%09%09return this.\n@@ -12932,51 +12932,46 @@\n ndex+1%5D;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return null;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AGet the\n@@ -12994,37 +12994,35 @@\n g of this widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -13045,33 +13045,32 @@\n g = function() %7B\n-%0D\n %0A%09if(this.parent\n@@ -13070,33 +13070,32 @@\n .parentWidget) %7B\n-%0D\n %0A%09%09var index = t\n@@ -13126,33 +13126,32 @@\n n.indexOf(this);\n-%0D\n %0A%09%09if(index !== \n@@ -13160,33 +13160,32 @@\n  && index %3E 0) %7B\n-%0D\n %0A%09%09%09return this.\n@@ -13215,51 +13215,46 @@\n ndex-1%5D;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return null;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ARender \n@@ -13285,37 +13285,35 @@\n get into the DOM\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -13361,108 +13361,84 @@\n bling) %7B\n-%0D\n %0A%09\n-var children = this.children;%0D%0A%09for(var i = 0; i %3C children.length; i++\n+$tw.utils.each(this.children,function(childWidget\n ) %7B\n-%0D\n %0A%09%09child\n-ren%5Bi%5D\n+Widget\n .render(\n@@ -13457,32 +13457,30 @@\n ibling);\n-%0D\n %0A%09%7D\n+)\n ;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AAdd a l\n@@ -13530,37 +13530,35 @@\n :,handler:%7D,...%5D\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -13592,33 +13592,32 @@\n ion(listeners) %7B\n-%0D\n %0A%09var self = thi\n@@ -13610,33 +13610,32 @@\n var self = this;\n-%0D\n %0A%09$tw.utils.each\n@@ -13661,33 +13661,32 @@\n (listenerInfo) %7B\n-%0D\n %0A%09%09self.addEvent\n@@ -13734,33 +13734,30 @@\n andler);\n-%0D\n %0A%09%7D);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AAdd an \n@@ -13762,37 +13762,35 @@\n n event listener\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -13826,33 +13826,32 @@\n (type,handler) %7B\n-%0D\n %0A%09var self = thi\n@@ -13844,33 +13844,32 @@\n var self = this;\n-%0D\n %0A%09if(typeof hand\n@@ -13926,33 +13926,32 @@\n e on this widget\n-%0D\n %0A%09%09this.eventLis\n@@ -13974,33 +13974,32 @@\n unction(event) %7B\n-%0D\n %0A%09%09%09return self%5B\n@@ -14016,39 +14016,37 @@\n all(self,event);\n-%0D\n %0A%09%09%7D;\n-%0D\n %0A%09%7D else %7B // Th\n@@ -14060,33 +14060,32 @@\n er is a function\n-%0D\n %0A%09%09this.eventLis\n@@ -14108,33 +14108,32 @@\n unction(event) %7B\n-%0D\n %0A%09%09%09return handl\n@@ -14152,37 +14152,33 @@\n ,event);\n-%0D\n %0A%09%09%7D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ADispatc\n@@ -14279,37 +14279,35 @@\n he parent widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -14333,33 +14333,32 @@\n unction(event) %7B\n-%0D\n %0A%09// Dispatch th\n@@ -14382,33 +14382,32 @@\n idget handles it\n-%0D\n %0A%09var listener =\n@@ -14439,34 +14439,32 @@\n t.type%5D;\n-%0D\n %0A%09if(listener) %7B\n-%0D\n %0A%09%09// Do\n@@ -14509,33 +14509,32 @@\n r returned false\n-%0D\n %0A%09%09if(!listener(\n@@ -14534,33 +14534,32 @@\n stener(event)) %7B\n-%0D\n %0A%09%09%09return false\n@@ -14551,42 +14551,39 @@\n %09%09%09return false;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Dispatch th\n@@ -14602,33 +14602,32 @@\n he parent widget\n-%0D\n %0A%09if(this.parent\n@@ -14627,33 +14627,32 @@\n .parentWidget) %7B\n-%0D\n %0A%09%09return this.p\n@@ -14684,46 +14684,42 @@\n (event);\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return true;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ASelecti\n@@ -14816,37 +14816,35 @@\n ded re-rendering\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -14874,33 +14874,32 @@\n angedTiddlers) %7B\n-%0D\n %0A%09return this.re\n@@ -14921,43 +14921,41 @@\n hangedTiddlers);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ARebuild a previ\n@@ -14967,37 +14967,35 @@\n  rendered widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -15014,33 +15014,32 @@\n f = function() %7B\n-%0D\n %0A%09var nextSiblin\n@@ -15064,33 +15064,32 @@\n iblingDomNode();\n-%0D\n %0A%09this.removeChi\n@@ -15093,33 +15093,32 @@\n ChildDomNodes();\n-%0D\n %0A%09this.render(th\n@@ -15139,43 +15139,41 @@\n de,nextSibling);\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ARefresh all the\n@@ -15185,37 +15185,35 @@\n dren of a widget\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -15259,49 +15259,34 @@\n dlers) %7B\n-%0D\n %0A%09var \n-children = this.children,%0D\n+self = this,\n %0A%09%09refre\n@@ -15298,63 +15298,70 @@\n = false;\n-%0D\n %0A%09\n-for (var i = 0; i %3C children.length; i++\n+$tw.utils.each(this.children,function(childWidget\n ) %7B\n-%0D\n %0A%09%09refre\n@@ -15372,22 +15372,22 @@\n  = child\n-ren%5Bi%5D\n+Widget\n .refresh\n@@ -15409,37 +15409,37 @@\n s) %7C%7C refreshed;\n-%0D\n %0A%09%7D\n-%0D\n+);\n %0A%09return refresh\n@@ -15433,43 +15433,41 @@\n eturn refreshed;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AFind the next s\n@@ -15616,37 +15616,35 @@\n  parent DOM node\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -15684,33 +15684,32 @@\n on(startIndex) %7B\n-%0D\n %0A%09// Refer to th\n@@ -15750,33 +15750,32 @@\n parents children\n-%0D\n %0A%09var parent = t\n@@ -15783,33 +15783,32 @@\n is.parentWidget,\n-%0D\n %0A%09%09index = start\n@@ -15864,33 +15864,32 @@\n n.indexOf(this);\n-%0D\n %0Aif(index === -1\n@@ -15883,33 +15883,32 @@\n (index === -1) %7B\n-%0D\n %0A%09throw %22node no\n@@ -15936,20 +15936,18 @@\n ildren%22;\n-%0D\n %0A%7D\n-%0D\n %0A%09// Loo\n@@ -15976,33 +15976,32 @@\n e later siblings\n-%0D\n %0A%09while(++index \n@@ -16019,33 +16019,32 @@\n ildren.length) %7B\n-%0D\n %0A%09%09var domNode =\n@@ -16086,34 +16086,32 @@\n mNode();\n-%0D\n %0A%09%09if(domNode) %7B\n-%0D\n %0A%09%09%09retu\n@@ -16113,42 +16113,39 @@\n %09return domNode;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Go back and\n@@ -16209,33 +16209,32 @@\n  parent dom node\n-%0D\n %0A%09var grandParen\n@@ -16249,33 +16249,32 @@\n nt.parentWidget;\n-%0D\n %0A%09if(grandParent\n@@ -16315,33 +16315,32 @@\n parentDomNode) %7B\n-%0D\n %0A%09%09index = grand\n@@ -16363,33 +16363,32 @@\n indexOf(parent);\n-%0D\n %0A%09%09if(index !== \n@@ -16384,33 +16384,32 @@\n (index !== -1) %7B\n-%0D\n %0A%09%09%09return paren\n@@ -16440,51 +16440,46 @@\n (index);\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return null;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AFind th\n@@ -16524,37 +16524,35 @@\n  or its children\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -16576,33 +16576,32 @@\n e = function() %7B\n-%0D\n %0A%09// Return the \n@@ -16639,33 +16639,32 @@\n if we've got one\n-%0D\n %0A%09if(this.domNod\n@@ -16671,33 +16671,32 @@\n es.length %3E 0) %7B\n-%0D\n %0A%09%09return this.d\n@@ -16698,37 +16698,35 @@\n his.domNodes%5B0%5D;\n-%0D\n %0A%09%7D\n-%0D\n %0A%09// Otherwise, \n@@ -16746,33 +16746,32 @@\n all our children\n-%0D\n %0A%09for(var t=0; t\n@@ -16791,33 +16791,32 @@\n n.length; t++) %7B\n-%0D\n %0A%09%09var domNode =\n@@ -16852,34 +16852,32 @@\n mNode();\n-%0D\n %0A%09%09if(domNode) %7B\n-%0D\n %0A%09%09%09retu\n@@ -16887,51 +16887,46 @@\n domNode;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return null;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0ARemove \n@@ -16969,37 +16969,35 @@\n  or its children\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -17024,33 +17024,32 @@\n s = function() %7B\n-%0D\n %0A%09// If this wid\n@@ -17210,33 +17210,32 @@\n ally be the case\n-%0D\n %0A%09if(this.domNod\n@@ -17242,33 +17242,32 @@\n es.length %3E 0) %7B\n-%0D\n %0A%09%09$tw.utils.eac\n@@ -17293,33 +17293,32 @@\n ction(domNode) %7B\n-%0D\n %0A%09%09%09domNode.pare\n@@ -17337,40 +17337,38 @@\n eChild(domNode);\n-%0D\n %0A%09%09%7D);\n-%0D\n %0A%09%09this.domNodes\n@@ -17373,28 +17373,26 @@\n es = %5B%5D;\n-%0D\n %0A%09%7D else %7B\n-%0D\n %0A%09%09// Ot\n@@ -17439,33 +17439,32 @@\n  their DOM nodes\n-%0D\n %0A%09%09$tw.utils.eac\n@@ -17494,33 +17494,32 @@\n n(childWidget) %7B\n-%0D\n %0A%09%09%09childWidget.\n@@ -17540,38 +17540,34 @@\n Nodes();\n-%0D\n %0A%09%09%7D);\n-%0D\n %0A%09%7D\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AInvoke \n@@ -17620,37 +17620,35 @@\n  current widget.\n-%0D\n %0A*/\n-%0D\n %0AWidget.prototyp\n@@ -17691,33 +17691,32 @@\n gWidget,event) %7B\n-%0D\n %0A%09var handled = \n@@ -17713,33 +17713,32 @@\n handled = false;\n-%0D\n %0A%09// For each ch\n@@ -17739,33 +17739,32 @@\n ach child widget\n-%0D\n %0A%09for(var t=0; t\n@@ -17784,33 +17784,32 @@\n n.length; t++) %7B\n-%0D\n %0A%09%09var child = t\n@@ -17816,33 +17816,32 @@\n his.children%5Bt%5D;\n-%0D\n %0A%09%09// Invoke the\n@@ -17864,33 +17864,32 @@\n an action widget\n-%0D\n %0A%09%09if(child.invo\n@@ -17891,33 +17891,32 @@\n .invokeAction) %7B\n-%0D\n %0A%09%09%09child.refres\n@@ -17915,33 +17915,32 @@\n d.refreshSelf();\n-%0D\n %0A%09%09%09if(child.inv\n@@ -17967,33 +17967,32 @@\n Widget,event)) %7B\n-%0D\n %0A%09%09%09%09handled = t\n@@ -17995,28 +17995,25 @@\n  = true;\n-%0D\n %0A%09%09%09%7D\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%09// Pr\n@@ -18054,33 +18054,32 @@\n if it permits it\n-%0D\n %0A%09%09if(child.allo\n@@ -18140,33 +18140,32 @@\n Widget,event)) %7B\n-%0D\n %0A%09%09%09handled = tr\n@@ -18167,26 +18167,23 @@\n  = true;\n-%0D\n %0A%09%09%7D\n-%0D\n %0A%09%7D\n-%0D\n %0A%09return\n@@ -18191,27 +18191,25 @@\n handled;\n-%0D\n %0A%7D;%0D%0A%0D%0A/*\n-%0D\n %0AInvoke \n@@ -18246,21 +18246,19 @@\n a string\n-%0D\n %0A*/\n-%0D\n %0AWidget.\n@@ -18332,33 +18332,32 @@\n ent,variables) %7B\n-%0D\n %0A%09actions = acti\n@@ -18358,33 +18358,32 @@\n = actions %7C%7C %22%22;\n-%0D\n %0A%09var parser = t\n@@ -18424,33 +18424,32 @@\n ywiki%22,actions,%7B\n-%0D\n %0A%09%09%09parentWidget\n@@ -18447,33 +18447,32 @@\n entWidget: this,\n-%0D\n %0A%09%09%09document: th\n@@ -18482,24 +18482,22 @@\n document\n-%0D\n %0A%09%09%7D),\n-%0D\n %0A%09%09widge\n@@ -18525,33 +18525,32 @@\n eWidget(parser,%7B\n-%0D\n %0A%09%09%09parentWidget\n@@ -18548,33 +18548,32 @@\n entWidget: this,\n-%0D\n %0A%09%09%09document: th\n@@ -18576,33 +18576,32 @@\n : this.document,\n-%0D\n %0A%09%09%09variables: v\n@@ -18608,24 +18608,22 @@\n ariables\n-%0D\n %0A%09%09%7D);\n-%0D\n %0A%09var co\n@@ -18659,33 +18659,32 @@\n eElement(%22div%22);\n-%0D\n %0A%09widgetNode.ren\n@@ -18695,33 +18695,32 @@\n container,null);\n-%0D\n %0A%09return widgetN\n@@ -18741,33 +18741,32 @@\n ons(this,event);\n-%0D\n %0A%7D;%0D%0A%0D%0AWidget.pr\n@@ -18810,32 +18810,30 @@\n tion() %7B\n-%0D\n %0A%09return true;\n-%0D\n %0A%7D;%0D%0A%0D%0Ae\n@@ -18856,18 +18856,17 @@\n Widget;%0D%0A%0D%0A%7D)();\n-%0D\n %0A\n",
            "created": "20191227073748708",
            "modified": "20191227073748708",
            "modloader-source": "$:/core",
            "modloader-target": "$:/core/modules/widgets/widget.js",
            "type": "text/x-patch"
        }
    }
}