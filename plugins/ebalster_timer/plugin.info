{
    "created": "20180106071024209",
    "modified": "20190726021015080",
    "plugin-type": "plugin",
    "revision": "0",
    "tags": "",
    "title": "$:/plugins/ebalster/timer",
    "type": "application/json",
    "version": "0.0.2",

    "tiddlers": {
        "$:/plugins/ebalster/timer/widgets/timer.js": {
            "text": "/*\\\ntitle: $:/plugins/ebalster/timer/widgets/timer.js\ntype: application/javascript\nmodule-type: widget\n\nWidget for triggering ActionWidgets on a timed interval\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n\nvar TimerWidget = function(parseTreeNode,options) {\n\tthis.initialise(parseTreeNode,options);\n};\n\n/*\nInherit from the base widget class\n*/\nTimerWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nTimerWidget.prototype.render = function(parent,nextSibling) {\n\tvar self = this;\n\tthis.parentDomNode = parent;\n\tthis.computeAttributes();\n\tthis.execute();\n\tthis.renderChildren(parent,nextSibling);\n\t// The timer callback...\n\tvar timerWidgetFunction = function timerWidgetFunction() {\n\t\t// Only perform actions if the TimerWidget is still in the widget tree.\n\t\tif (self.stillInWidgetTree()) {\n\t\t\tvar event = new CustomEvent(\"TimerWidget\");\n\t\t\tself.invokeActions(self,event);\n\t\t\tif(self.message) self.dispatchMessage(event);\n\t\t\t//if(self.set)     self.setTiddler();\n\t\t\tif(self.actions) self.invokeActionString(self.actions,self,event);\n\t\t}\n\t};\n\t// How long should we wait?\n\tif (window) {\n\t\t// Unregister the old timer event\n\t\tif (this.timeoutID)  window.clearTimeout (this.timeoutID);\n\t\tif (this.intervalID) window.clearInterval(this.intervalID);\n\t\tthis.timeoutID = this.intervalID = null;\n\t\tif (this.time && this.time.length) {\n\t\t\tvar currentTime = Date.now(), targetTime = null;\n\t\t\tif (this.time.length >= 14) {\n\t\t\t\t//TiddlyWiki date in native format\n\t\t\t\ttargetTime = $tw.utils.parseDate(this.time);\n\t\t\t\tif (targetTime) targetTime = targetTime.getTime();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//Unix epoch time in milliseconds\n\t\t\t\ttargetTime = parseFloat(this.time);\n\t\t\t}\n\t\t\tif (targetTime && targetTime > currentTime) {\n\t\t\t\t// Register a timeout event\n\t\t\t\tthis.timeoutID = window.setTimeout(timerWidgetFunction, targetTime-currentTime);\n\t\t\t}\n\t\t}\n\t\telse if (this.interval && this.interval.length) {\n\t\t\tvar interval = parseFloat(this.interval);\n\t\t\tif (interval && interval > 0) {\n\t\t\t\t// Register an interval event\n\t\t\t\tthis.intervalID = window.setInterval(timerWidgetFunction, interval*1000);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n};\n\n/*\nDetect if the timer widget is still in the tree, by crawling up to the RootWidget.\n*/\nTimerWidget.prototype.stillInWidgetTree = function() {\n\tvar widget = this;\n\twhile (widget) {\n\t\tvar parent = widget.parentWidget;\n\t\tif (parent) {\n\t\t\t// Return false if some ancestor has disowned us.\n\t\t\tif (!parent.children || parent.children.indexOf(widget) < 0) return false;\n\t\t}\n\t\telse {\n\t\t\t// Return true if we get to the root widget.\n\t\t\treturn widget === $tw.rootWidget;\n\t\t}\n\t\twidget = parent;\n\t}\n};\n\n/*\nWe don't allow actions to propagate because we trigger actions ourselves\n*/\nTimerWidget.prototype.allowActionPropagation = function() {\n\treturn false;\n};\n\nTimerWidget.prototype.dispatchMessage = function(event) {\n\tthis.dispatchEvent({type: this.message, param: this.param, tiddlerTitle: this.getVariable(\"currentTiddler\"), event: event});\n};\n\n/*TimerWidget.prototype.setTiddler = function() {\n\tthis.wiki.setTextReference(this.set,this.setTo,this.getVariable(\"currentTiddler\"));\n};*/\n\n/*\nCompute the internal state of the widget\n*/\nTimerWidget.prototype.execute = function() {\n\t// Get attributes\n\tthis.actions = this.getAttribute(\"actions\");\n\tthis.message = this.getAttribute(\"message\");\n\tthis.param = this.getAttribute(\"param\");\n\tthis.interval = this.getAttribute(\"interval\");\n\tthis.time = this.getAttribute(\"time\");\n\t//this.set = this.getAttribute(\"set\");\n\t//this.setTo = this.getAttribute(\"setTo\");\n\t// Make child widgets\n\tthis.makeChildWidgets();\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nTimerWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\tif(changedAttributes.time || changedAttributes.interval || changedAttributes.message || changedAttributes.param || changedAttributes.actions) {\n\t\t// || changedAttributes.set || changedAttributes.setTo || (this.set && changedTiddlers[this.set])\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\treturn this.refreshChildren(changedTiddlers);\n};\n\nexports.timer = TimerWidget;\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/ebalster/timer/widgets/timer.js",
            "tags": "",
            "revision": "0",
            "module-type": "widget",
            "modified": "20190726012139500",
            "created": "20180106041642233"
        }
    }
}